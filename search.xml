<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Xcode中的环境变量]]></title>
    <url>%2F2017%2F06%2F05%2FiOS-Xcode%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[了解Xcode的内置环境变量可以使我们方便的管理工程，是开发者应该额外了解的开发技巧。同时Xcode的内置环境变量对于使用脚本作自动化集成和测试都有着重要的意义。本文主要介绍一些Xcode中常用的内置环境变量。 ARCHSARCHS是target所支持的arm架构，主要包含32位的armv7架构，64位的arm64架构，以及遗失的armv7s架构。armv7s在Xcode6之后就默认舍弃了。 ARCHS_STANDARD = armv7 arm64 ARCHS_STANDARD_32_64_BIT = armv7 arm64 ARCHS_STANDARD_32_BIT = armv7 ARCHS_STANDARD_64_BIT = arm64 ARCHS_STANDARD_INCLUDING_64_BIT = armv7 arm64 ARCHS_UNIVERSAL_IPHONE_OS = armv7 arm64 除此之外还有i386架构，以及x86_64架构，这两个主要是针对iPhone Simulator的。 BUILD_DIR/BUILD_ROOT实际的build生产目录，绝对路径。一般是build目录下的Products目录。通常情况下编译后Xcode会在build目录下生成两个文件夹，Products目录是编译后的结果目录，intermediates文件夹是生成临时文件的存放目录 BUILT_PRODUCTS_DIRProducts目录下的一个子目录，实际的名字由项目的编译版本和是否为真机共同决定。 Debug-iphoneos Debug-iphonesimulator Release-iphonesimulator Release-iphoneos CONFIGURATION项目的build选项，通常为release和debug EFFECTIVE_PLATFORM_NAME当模似器时为值为-iphonesimulator 当为真机时为-iphoneos PROJECT_TEMP_DIRintermediates目录下的build文件夹 PRODUCT_SETTINGS_PATH项目的plist配置文件 PROJECT_NAME项目的名称 TARGET_NAMEtarget名称 PROJECT_FILE_PATH.xcodeproj文件路径 查看全部环境变量执行xcodebuild -showBuildSettings &gt; buildSettings.txt,]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-Studio中的快捷键(Mac)]]></title>
    <url>%2F2017%2F05%2F17%2FAndroid-Studio%E4%B8%AD%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE-Mac%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。学习安卓开发已经快两个月了，但是android studio用的并不是很熟练，总要用鼠标傻傻的点来点去很不方便。这里总结下个人的快捷键使用，希望可以帮助到入门的初学者。 Command + Shift + ↑↓ 上下移动行 Command + K 提交代码到VCS Command + / 增加//注释 Command + Option + / 增加//注释 Command + +/- 展开收缩代码块/方法 Control + Space 打开智能提示 Command + N Generate面板，可以创建getter，setter，构造方法等。 Command + D 运行debug模式 Command + Shift + O 搜索文件 Command + O 搜索类 Option + Enter 变量快速声明 Command + [ 切换到上一个访问位置 Command + Shift + E 打开最近访问的文件 Command + B 跳转到方法声明或变量声明 Command + U 进入到父类 Command + Option + L 代码格式化To Be Continued…]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS中的那些锁]]></title>
    <url>%2F2017%2F05%2F12%2FiOS-iOS%E4%B8%AD%E7%9A%84%E9%82%A3%E4%BA%9B%E9%94%81%2F</url>
    <content type="text"><![CDATA[NSLock锁，通常被用来协调多线程中访问操作，可用于协调访问应用程序的全局数据或保护代码的关键部分的原子性操作。 APINSLock的API很少，只有两个方法和一个属性,同时遵循协议NSLocking 123456/* 尝试进行加锁，如果加锁成功会返回`YES`,反之会返回`NO`。*／- (BOOL)tryLock;／*该方法会在给定的时间进行加锁操作，如果执行成功返回`YES`*／- (BOOL)lockBeforeDate:(NSDate *)limit;@property (nullable, copy) NSString *name NSLock类底层使用POSIX线程实现了所行为，在执行解锁unlock方法前需要确保在相同线程中进行过加锁lock/tryLock操作。在不同的线程中加解锁会导致不确定的行为。加锁和解锁需要成对出现，并且在解锁之前不可以进行再次加锁，这种情况可能会导致deadlock,在实际运行的时候会出现类似这样的报错-[NSLock lock]: deadlock (&lt;NSLock: 0x6000000c4830&gt; &#39;(null)&#39;)。如果有递归调用方法的情况，可以考虑使用递归锁(后文介绍)。 简单示例1234567891011121314151617@property (strong,nonatomic)NSLock *lock;@property (strong,nonatomic)NSMutableArray *dataResult;- (instancetype)init &#123; if (self = [super init]) &#123; _lock = [[NSLock alloc] init]; _dataResult = [[NSMutableArray alloc] init]; &#125; return self;&#125;- (void)push:(id)obj &#123; if (obj != NULL &amp;&amp; [_lock tryLock]) &#123; [_dataResult addObject:obj]; [_lock unlock]; &#125;&#125; 通常情况下，只有写操作或者改变值操作进行加锁处理，而读取数据并不进行加锁，这样的操作可以提高运行效率。并且在此强调，加解锁的线程一定要保证唯一性。 @synchronizedsynchronized关键字是clang预定义的关键词，向synchronized中传入一个唯一的标识用来区分保护锁。synchronized不需要像NSLock一样要考虑在加解锁需要在同一线程中的问题，也不需要考虑同一个线程中连续加锁的问题。但是性能上却比NSLock要差一些，作为预处理方法，使用synchronized方法隐式的添加了一个异常处理块来保护代码，在异常触发的时候自动释放掉锁。 示例12345- (void)push:(id)obj &#123; @synchronized (self) &#123; [_dataResult addObject:obj]; &#125;&#125; 延伸@synchronized方法中究竟做了什么？我们不妨可以通过将Objective-C代码片段转化为C代码来一探究竟。编写一个使用了@synchronized的方法示例 123456789101112131415161718@interface LockObj ()@property (strong,nonatomic)NSMutableArray *dataResult;@end@implementation LockObj- (instancetype)init &#123; if (self = [super init]) &#123; _dataResult = [[NSMutableArray alloc] init]; &#125; return self;&#125;- (void)push:(id)obj &#123; @synchronized (self) &#123; [_dataResult addObject:obj]; &#125;&#125;@end 接下来使用clang -rewrite-objc命令将Objective-C代码转化为C/C++代码。 1clang -rewrite-objc LockObj.m -o lock.output 查看lock.output文件，会找到下面的代码 1234567891011121314151617static void _I_LockObj_push_(LockObj * self, SEL _cmd, id obj) &#123; &#123; id _rethrow = 0; id _sync_obj = (id)self; objc_sync_enter(_sync_obj);try &#123; struct _SYNC_EXIT &#123; _SYNC_EXIT(id arg) : sync_exit(arg) &#123;&#125; ~_SYNC_EXIT() &#123;objc_sync_exit(sync_exit);&#125; id sync_exit; &#125; _sync_exit(_sync_obj); ((void (*)(id, SEL, ObjectType))(void *)objc_msgSend)((id)(*(NSMutableArray **)((char *)self + OBJC_IVAR_$_LockObj$_dataResult)), sel_registerName("addObject:"), (id)obj); &#125; catch (id e) &#123;_rethrow = e;&#125;&#123; struct _FIN &#123; _FIN(id reth) : rethrow(reth) &#123;&#125; ~_FIN() &#123; if (rethrow) objc_exception_throw(rethrow); &#125; id rethrow; &#125; _fin_force_rethow(_rethrow);&#125;&#125;&#125; 可以发现@synchronized方法其实是调用了类似如下的代码 12345678910111213&#123; id _rethrow = 0; id _sync_obj = (id)self; objc_sync_enter(_sync_obj); id sync_exit; @try &#123; //dosomethong &#125; @catch (NSException *exp) &#123; objc_exception_throw(exp); &#125; @finally &#123; objc_sync_exit(sync_exit); &#125; &#125; objc_sync_enter和objc_sync_exit是定义在&lt;objc/objc-sync.h&gt;文件中的。其注释已经明确的告诉了我们想知道的： 1234567891011121314151617181920/** * Begin synchronizing on 'obj'. * Allocates recursive pthread_mutex associated with 'obj' if needed. * * @param obj The object to begin synchronizing on. * * @return OBJC_SYNC_SUCCESS once lock is acquired. */ OBJC_EXPORT int objc_sync_enter(id obj)OBJC_AVAILABLE(10.3, 2.0, 9.0, 1.0);/** * End synchronizing on 'obj'. * * @param obj The objet to end synchronizing on. * * @return OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR */OBJC_EXPORT int objc_sync_exit(id obj) OBJC_AVAILABLE(10.3, 2.0, 9.0, 1.0); 没错，@synchronized创建的是PTHREAD_MUTEX_RECURSIVE类型的互斥锁。 NSConditionLock条件锁，顾名思义，就是在某些条件下才进入线程执行代码，其余条件进入等待状态，等待条件的线程会被阻塞住直到另一个线程中显示的发出信号。其与互斥锁有一些微妙的区别。。其底层基于POSIX线程机制的。 API123456789- (instancetype)initWithCondition:(NSInteger)condition;@property (readonly) NSInteger condition;- (void)lockWhenCondition:(NSInteger)condition;- (BOOL)tryLock;- (BOOL)tryLockWhenCondition:(NSInteger)condition;- (void)unlockWithCondition:(NSInteger)condition;- (BOOL)lockBeforeDate:(NSDate *)limit;- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit; initWithCondition会创建一个条件锁，并设置condition时进行加锁，未解锁前其他线程将会暂停等待。lockWhenCondition将条件锁的加锁条件设置为某值，之前设置的值会被丢弃，未解锁前其他线程将会暂停等待。其他使用方法类似，这里不做过多解释了。 条件锁最常使用的环境是生产-消费模式，生产者和消费者各自在一个线程。生产者生产数据并将数据放入到队列中，在没有数据时会加锁执行生产。消费者消费数据并将数据移出队列，在有数据时会加锁，消费完成后如果没有数据，则解锁并设置锁条件为无数据。 Apple官方的代码12345678910111213141516171819//生产者id condLock = [[NSConditionLock alloc] initWithCondition: NO_DATA];while(true)&#123; [condLock lock]; /* Add data to the queue. */ [condLock unlockWithCondition: HAS_DATA];&#125;//消费者while (true)&#123; [condLock lockWhenCondition: HAS_DATA]; /* Remove data from the queue. */ [condLock unlockWithCondition:(isEmpty ? NO_DATA : HAS_DATA)]; // Process the data locally.&#125; NSCondition条件，虽然带锁的名字，但是其也遵循NSLocking协议。当NSCondition加锁后，其他线程调用wait方法进入等待状态，直到signal触发会唤醒某一个或者bradcast唤起所有。 API1234- (void)wait;- (BOOL)waitUntilDate:(NSDate *)limit;- (void)signal;- (void)broadcast; signal方法可以唤醒线程，broadcast可以唤醒所有等待线程。 NSRecursiveLock递归锁，递归锁的出现大概是因为NSLock无法处理统一线程中多次调用加锁或是递归调用引起的deadlock问题，递归锁虽然不会因为多次调用加锁而引起死锁，但是仍然要保证加锁与解锁成对出现。 示例12345- (void)recurveLock:(NSInteger) result &#123; [_lock lock]; if (result &gt; 0) &#123; [self recurveLock:result-1];&#125; [_lock unlock];&#125; NSDistributedLock分布锁，该锁的主要用途是多线程/进程之间需要限制对某些共享资源的访问，比如一个文件。分布锁没有实现NSLocking协议，所以没有lock方法。一个lock方法将会阻塞线程的执行，并要求系统以预定的速度轮询锁。它提供了一个tryLock方法，并让你决定是否轮询。访问结束后，可以通过调用unlock方法来释放它。 API12345678+ (nullable NSDistributedLock *)lockWithPath:(NSString *)path; - (instancetype)init NS_UNAVAILABLE;- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;- (BOOL)tryLock;- (void)unlock;- (void)breakLock; OSSpinLock自旋锁，可以理解为比NSLock更底层的锁，同样处理资源竞争的问题，性能高于NSLock和pthread_mutex。 API123bool OSSpinLockTry( volatile OSSpinLock *__lock );void OSSpinLockLock( volatile OSSpinLock *__lock );void OSSpinLockUnlock( volatile OSSpinLock *__lock ) 使用方式与NSLock类似，并无很大区别。 示例12345678__block OSSpinLock lock = OS_SPINLOCK_INIT;dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; OSSpinLockLock(&amp;lock); //do something OSSpinLockUnlock(&amp;oslock);&#125;); 不再安全的OSSpinLockOSSpinLock已经被废弃掉了，原因是低优先级的线程如果锁住了资源，高优先级的线程访问时会破坏掉锁的资源，具体看这里不再安全的 OSSpinLock鉴于OSSpinLock会有bug的问题，Apple在iOS10.0/MacOS 10.12中使用了新的方式实现了自旋锁os_unfair_lock_s，同时废弃掉了OSSpinLock。 os_unfair_lockos_unfair_lock是替代OSSpinLock的产物，在Xcode8之后可以看到OSSpinLock已经被废弃掉，并用os_unfair_lock代替了。 123456789101112131415161718192021#define OS_SPINLOCK_INIT 0typedef int32_t OSSpinLock OSSPINLOCK_DEPRECATED_REPLACE_WITH(os_unfair_lock);typedef volatile OSSpinLock *_os_nospin_lock_t;OSSPINLOCK_DEPRECATED_REPLACE_WITH(os_unfair_lock_lock)OS_NOSPIN_LOCK_AVAILABILITYvoid _os_nospin_lock_lock(_os_nospin_lock_t lock);#undef OSSpinLockLock#define OSSpinLockLock(lock) _os_nospin_lock_lock(lock)OSSPINLOCK_DEPRECATED_REPLACE_WITH(os_unfair_lock_trylock)OS_NOSPIN_LOCK_AVAILABILITYbool _os_nospin_lock_trylock(_os_nospin_lock_t lock);#undef OSSpinLockTry#define OSSpinLockTry(lock) _os_nospin_lock_trylock(lock)OSSPINLOCK_DEPRECATED_REPLACE_WITH(os_unfair_lock_unlock)OS_NOSPIN_LOCK_AVAILABILITYvoid _os_nospin_lock_unlock(_os_nospin_lock_t lock);#undef OSSpinLockUnlock#define OSSpinLockUnlock(lock) _os_nospin_lock_unlock(lock) 使用os_unfair_lock的方法于OSSpinLock的方式类似，示例如下： 1234os_unfair_lock lock = OS_UNFAIR_LOCK_INIT;os_unfair_lock_lock(&amp;lock);//do somethingos_unfair_lock_unlock(&amp;lock); 性能对比关于锁的性能评测，很多开发者已经给出了测试结果，基本上是os_unfair_lock &gt; OSSpinLockLock &gt; DispatchSemaphare &gt; pthread_mutex_t &gt; NSLock &gt; @synchronized pspdfkit作者给出的测试结果; 国人给出的测试结果：同步锁性能对比 mutex vs Binary semaphore很多人对锁和信号的概念有一些误区，他们不是同一码事。两者的使用有不同的目的。互斥锁的仅允许一个线程访问锁定的部分，而互斥信号量不同，允许多个进程／线程访问，但同时只能有一个。具体可以参考这里difference-between-binary-semaphore-and-mutex 延伸阅读关于 @synchronized，这儿比你想知道的还要多 By 杨萧玉 Threading Programming Guide/Synchronization]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[饿了么下拉刷新效果的实现(二)]]></title>
    <url>%2F2017%2F05%2F08%2FiOS-%E9%A5%BF%E4%BA%86%E4%B9%88%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言上一篇文章中我们使用CAEmitterLayer实现了饿了么下拉刷新的动画效果，不过效果并不是很理想，CAEmitterLayer并不能动态改变每个Cell的样式，所以这回我们换一种思想。 定制动画轨迹在刷新效果中，我们可以看到其实弹出的食物的轨迹是固定的，是一条抛物线。因此我们可以用CAKeyframeAnimation关键帧动画来实现，动画的轨迹可以用UIBezierPath来画。具体代码如下： 12345678910111213141516171819202122232425- (CAAnimation *)animationWithDirection:(EmitterDirection)leftOrRight &#123; CAKeyframeAnimation *animation = [CAKeyframeAnimation animationWithKeyPath:@"position"]; animation.duration = 1; UIBezierPath *path = [UIBezierPath bezierPath]; CGPoint start = CGPointMake(self.layer.bounds.size.width/2, self.layer.bounds.size.height/2); CGPoint control = CGPointMake(self.layer.bounds.size.width/2, -_background.bounds.size.height); CGPoint endpoint ; switch (leftOrRight) &#123; case EmitterDirectionLeft: endpoint = CGPointMake(0, self.frame.size.height); break; case EmitterDirectionRight: endpoint = CGPointMake(self.frame.size.width, self.frame.size.height); break; default: break; &#125; [path moveToPoint:start]; [path addQuadCurveToPoint:endpoint controlPoint:control]; animation.path = path.CGPath; animation.removedOnCompletion = NO; return animation;&#125; 该方法返回了一个可执行动画CAAnimation,需要传入轨迹的方向。 CALayer发射器动画路径我们已经定制过了，接下来就是创建食物的视图，然后通过定时器将它们发射出去就可以了。 创建定时器12345678- (CADisplayLink *)link &#123; if (_link == nil) &#123; _link = [CADisplayLink displayLinkWithTarget:self selector:@selector(animateFood)]; [_link addToRunLoop:[NSRunLoop mainRunLoop ] forMode:NSRunLoopCommonModes]; _link.frameInterval = 1; &#125; return _link;&#125; 创建图片layer数组12345678910111213141516171819202122- (CALayer *)createFoodLayerWithImage:(UIImage *)img &#123; CALayer *layer = [CALayer layer]; layer.contents = (__bridge id _Nullable)(img.CGImage); layer.frame = CGRectMake((self.layer.bounds.size.width-img.size.width)/2, self.layer.frame.size.height/2, img.size.width, img.size.height); return layer;&#125;- (NSMutableArray *)foodArray &#123; if (_foodArray == nil) &#123; _foodArray = [[NSMutableArray alloc] init]; NSString * preString = @"pull_to_refresh_element_g1_"; for (NSInteger i = 1; i&lt;=6; i++) &#123; NSString *imageName = [NSString stringWithFormat:@"%@%@",preString,@(i)]; UIImage *image = [UIImage imageNamed:imageName]; CALayer *layer = [self createFoodLayerWithImage:image]; [_foodArray addObject:layer]; &#125; &#125; return _foodArray;&#125; 发射食物123456789101112- (void)animateFood &#123; static int index = 0; index++; if (index%denominator != 0) &#123; return; &#125; CALayer *layer = [self foodArray][(index/denominator)%([self foodArray].count)]; [self.layer insertSublayer:layer below:self.boxShade]; CAAnimation *animation = [self animationWithDirection:(index/denominator)%2]; [ELAnimationEngine engineWithLayer:layer withAnimation:animation];&#125; 发射后CALayer的回收在动画完成后需要做的是将Layer从视图空间中移除掉，因为我们的数组中已经持有了Layer，因此不必担心从屏幕上移除后资源会被回收掉。对于CAAnimation，其动画效果的开始与结束可以通过其代理的回调方法来处理。创建ELAnimationEngine专门负责关联CAAnimation与CALayer。 ELAnimationEngine.h文件123456@import UIKit;@interface ELAnimationEngine : NSObject@property (nonatomic,weak)CAAnimation *animation;@property (nonatomic,weak)CALayer *layer;+ (void)engineWithLayer:(CALayer *)layer withAnimation:(CAAnimation *)animation;@end ELAnimationEngine.m文件12345678910111213141516171819202122232425262728293031323334#import &lt;objc/runtime.h&gt;static void *animationEngineKey = &amp;animationEngineKey;@interface CALayer (ELAnimationHooker)@property (nonatomic,strong)ELAnimationEngine *engine;@end@interface ELAnimationEngine()&lt;CAAnimationDelegate&gt;@end@implementation ELAnimationEngine+ (void)engineWithLayer:(CALayer *)layer withAnimation:(CAAnimation *)animation &#123; ELAnimationEngine *engine = [[ELAnimationEngine alloc] init]; engine.layer = layer; engine.animation = animation; animation.delegate = engine; [layer addAnimation:animation forKey:NSStringFromClass([self class])];&#125;- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag &#123; [self.layer removeFromSuperlayer];&#125;@end@implementation CALayer (ELAnimationHooker)- (void)setEngine:(ELAnimationEngine *)engine &#123; objc_setAssociatedObject(self, &amp;animationEngineKey, engine, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;- (ELAnimationEngine *)engine &#123; return objc_getAssociatedObject(self, &amp;animationEngineKey);&#125;@end logo的上下弹动效果以及把手摆动的动画123456789101112131415161718192021222324252627282930313233343536- (void)addBounceAnimationIfNeeded &#123; if ([self.background animationForKey:@"bounces"]) &#123; return; &#125; CATransform3D transform = CATransform3DMakeScale(1, 0.8, 1); CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@"transform"]; animation.toValue = [NSValue valueWithCATransform3D:transform]; animation.duration = 0.5; animation.removedOnCompletion = NO; animation.beginTime = CACurrentMediaTime(); animation.repeatCount = CGFLOAT_MAX; CGPoint position = self.leftHandle.position; position.y += 10; CABasicAnimation *pAnimationLeft = [CABasicAnimation animationWithKeyPath:@"position"]; pAnimationLeft.duration = 0.5; pAnimationLeft.removedOnCompletion = NO; pAnimationLeft.beginTime = CACurrentMediaTime(); pAnimationLeft.repeatCount = CGFLOAT_MAX; pAnimationLeft.toValue = [NSValue valueWithCGPoint:position]; [self.leftHandle addAnimation:pAnimationLeft forKey:nil]; CGPoint positionRight = self.rightHandle.position; positionRight.y += 10; CABasicAnimation *pAnimationRight = [CABasicAnimation animationWithKeyPath:@"position"]; pAnimationRight.duration = 0.5; pAnimationRight.removedOnCompletion = NO; pAnimationRight.beginTime = CACurrentMediaTime(); pAnimationRight.repeatCount = CGFLOAT_MAX; pAnimationRight.toValue = [NSValue valueWithCGPoint:positionRight]; [self.rightHandle addAnimation:pAnimationRight forKey:nil]; [self.background addAnimation:animation forKey:@"bounces"];&#125; 根据progress变更样式1234567891011121314151617181920- (void)setProgress:(CGFloat)progress &#123; _progress = progress; if (_progress == 0.0) &#123; _leftHandle.hidden = YES; _rightHandle.hidden = YES; &#125;else if(_progress &lt; 0.7) &#123; _leftHandle.hidden = NO; _rightHandle.hidden = NO; [self transformWithProgress:_progress layer:_rightHandle]; [self transformWithProgress:-_progress layer:_leftHandle]; &#125; if (_progress &gt; 0.8) &#123; [self addBounceAnimationIfNeeded]; [self link]; &#125;else &#123; [_link invalidate]; _link = nil; &#125;&#125; 写在最后最终实现效果本例中并未处理reset的效果，过程切换时并没有处理动画的移除，因为我们还是专注于动画效果本身，相信移除的方法并不会难倒我们吧。完整的代码在这里: ELAnimationEngine.h ELAnimationEngine.m ELAnimationView.h ELAnimationView.m]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用CAEmitter粒子发射器实现类似饿了么下拉刷新的效果]]></title>
    <url>%2F2017%2F05%2F02%2FiOS-%E4%BD%BF%E7%94%A8CAEmitter%E7%B2%92%E5%AD%90%E5%8F%91%E5%B0%84%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E9%A5%BF%E4%BA%86%E4%B9%88%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0%E7%9A%84%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[序本文是动画效果效果的一些实践，使用CAEmitterLayer实现类似于饿了么下拉刷新的效果。 构思饿了么的下拉刷新可以分为3部分，正常状态，预刷新状态和刷新状态，我们只需要处理这三种状态，然后将控件结合MJRefresh等开源的刷新库使用，便可实现饿了么下拉刷新的效果，当然MJRefresh如何使用不是本文的重点，可以去官网学习如何使用。 正常状态这种状态下我们需要处理的视图的创建，放在UIView的initWithFrame方法中，正常状态下会有一个logo和一个底部阴影，这两个视图使用layer去创建即可，并没有什么难度。 预加载状态当下拉的高度未达到刷新的状态时，logo的两侧会显示两个把手，在正常状态下，两个把手会隐藏，随着下拉的距离渐渐张开，到一定程度后不会再进行旋转了。 刷新状态刷新状态下，logo中会不断向外面”扔出”水果，把手上下摆动，同时箱子会发生形变行为。 准备下载饿了么的app，解压包，找到刷新的资源文件。实际的图片内容在NVMUIKit.bundle目录下，将相关图片拷贝到工程中。主要的资源文件只需要几个，背景logo、底部阴影、食物的图片，左右两个把手。 实现正常状态首先我们需要处理的是正常状态下的显示，该部分代码可以放在initWithFrame:(CGRect)frame中，主要进行控件的初始化工作。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142- (instancetype)initWithFrame:(CGRect)frame &#123;if (self = [super initWithFrame:frame]) &#123; self.layer.masksToBounds = YES; CALayer *leftHandle = [CALayer layer]; leftHandle.contents = (__bridge id _Nullable)([UIImage imageNamed:@"pull_to_refresh_box_left_handle"].CGImage); leftHandle.anchorPoint = CGPointMake(0, 0); self.leftHandle = leftHandle; [self.layer addSublayer:leftHandle]; CALayer *rightHandle = [CALayer layer]; rightHandle.contents = (__bridge id _Nullable)([UIImage imageNamed:@"pull_to_refresh_box_right_handle"].CGImage); self.rightHandle = rightHandle; [self.layer addSublayer:rightHandle]; CALayer *shader = [CALayer layer]; shader.contents = (__bridge id _Nullable)([UIImage imageNamed:@"pull_to_refresh_box_shade"].CGImage); _boxShade = shader; [self.layer addSublayer:shader]; CALayer *background = [CALayer layer]; background.contents = (__bridge id _Nullable)([UIImage imageNamed:@"pull_to_refresh_box"].CGImage); _background = background; CGFloat height = self.frame.size.height; CGFloat width = self.frame.size.width; CGPoint center = CGPointMake(width*0.5, height*0.5); CAEmitterLayer *emitter = [CAEmitterLayer layer]; emitter.emitterMode = kCAEmitterLayerOutline; [self.layer addSublayer:background]; _background.frame = CGRectMake(center.x - 31, center.y - 24, 62, 48); _boxShade.frame = CGRectMake(center.x - 35,center.y + 14, 70, 18); _leftHandle.position = CGPointMake(_background.frame.origin.x +2 , _background.frame.origin.y + 3); _leftHandle.bounds = CGRectMake(0, 0, 30, 5); _leftHandle.anchorPoint = CGPointMake(0, 0); _rightHandle.position = CGPointMake(_background.frame.origin.x + _background.bounds.size.width - 2 ,_background.frame.origin.y +3); _rightHandle.bounds = CGRectMake(0, 0, 30, 5); _rightHandle.anchorPoint = CGPointMake(1.0, 0);&#125;return self; } 依据下拉的距离处理把手的旋转处理把手的旋转需要知道当前的下拉进度，这里面我们只需要百分比，所以编写函数- (void)transformWithProgress:(CGFloat)progress layer:(CALayer *)layer来处理把手的旋转： 123- (void)transformWithProgress:(CGFloat)progress layer:(CALayer *)layer &#123; layer.transform = CATransform3DMakeRotation(progress * M_PI * 2, 0, 0, 1);&#125; 刷新进行时在下拉刷新时logo会不断的产生食物，并向外弹出，logo形变，把手上下摆动。食物的效果我们这里可以采用CAEmitterLayer处理，部分代码如下： 1234_emitterLayer = emitter;_emitterLayer.birthRate = 2.8f;_emitterLayer.emitterPosition = center;[self.layer addSublayer:_emitterLayer]; 创建EmitterCell的方法如下 1234567891011121314- (NSArray *)createEmitter &#123; CAEmitterCell *orange = [self createEmitterCellWithImage:[UIImage imageNamed:@"pull_to_refresh_element_g1_1"] direction:EmitterDirectionLeft]; CAEmitterCell *hanberger = [self createEmitterCellWithImage:[UIImage imageNamed:@"pull_to_refresh_element_g1_2"] direction:EmitterDirectionRight]; CAEmitterCell *unKnown = [self createEmitterCellWithImage:[UIImage imageNamed:@"pull_to_refresh_element_g1_3"] direction:EmitterDirectionLeft]; CAEmitterCell *pear = [self createEmitterCellWithImage:[UIImage imageNamed:@"pull_to_refresh_element_g1_5"] direction:EmitterDirectionRight]; return @[orange,hanberger,unKnown,pear];&#125;- (NSArray *)emitterCells &#123; if (_emitterCells == nil) &#123; _emitterCells = [self createEmitter]; &#125; return _emitterCells;&#125; 整合显示依据当前进度的百分比控制显示： 12345678910111213141516171819- (void)setProgress:(CGFloat)progress &#123; _progress = progress; if (_progress == 0.0) &#123; _leftHandle.hidden = YES; _rightHandle.hidden = YES; &#125;else if(_progress &lt; 0.7) &#123; _leftHandle.hidden = NO; _rightHandle.hidden = NO; [self transformWithProgress:_progress layer:_rightHandle]; [self transformWithProgress:-_progress layer:_leftHandle]; &#125; if(_progress &gt; 0.8) &#123; if ([self.emitterLayer.emitterCells count]&gt;0) &#123; return;&#125; self.emitterLayer.emitterCells = self.emitterCells; &#125; else &#123; self.emitterLayer.emitterCells = @[]; &#125;&#125; 属性及枚举定义12345678910111213141516typedef NS_ENUM(NSInteger,EmitterDirection)&#123; EmitterDirectionLeft, EmitterDirectionRight,&#125;;@interface ELAnimationView ()@property (nonatomic,weak) CALayer *boxShade;@property (nonatomic,weak) CALayer *background;@property (nonatomic,weak) CALayer *leftHandle;@property (nonatomic,weak) CALayer *rightHandle;@property (nonatomic,assign) CGFloat progress;@property (nonatomic,weak)CAEmitterLayer *emitterLayer;@property (nonatomic,copy)NSArray *emitterCells;@end 实践效果及结束语&lt;p&gt;本例仅仅是仿饿了么的下拉刷新的部分动画，未实现所有功能，因为在实践的过程中发现了如下几个问题：&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;code&gt;CAEmitterCell&lt;/code&gt;无法动态的改变其内部的contents，如果一旦改变，已经发射的粒子也会随之变动，并且饿了么的实际动画效果是一个一个食物弹出的，而非多个粒子一起弹出，还是略微有些差别。&lt;/li&gt; &lt;li&gt;无法处理logo的弹跳动作，这个效果留在下一篇博客中去实现。&lt;/li&gt; &lt;li&gt;未处理左右把手的摇摆动画。&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;不过即便如此，我们不是也学会如何使用粒子发射器了么～。&lt;/p&gt;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android学习笔记之可绘制对象资源]]></title>
    <url>%2F2017%2F04%2F28%2FAndroid-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8F%AF%E7%BB%98%E5%88%B6%E5%AF%B9%E8%B1%A1%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[序可绘制对象资源是指可在屏幕上绘制的图形，可以应用到具有android:drawable属性的xml资源文件的图形。具有多种不同类型的可绘制对象： 位图文件位图图形文件（.png、.jpg 或 .gif） 当保存的在drawable目录中的文件为上述几种类型时，Android会为它们创建Drawable资源，编译的资源数据类型为BitmapDrawable指针 资源引用：在Java中：R.drawable.filename在XML中：@[package:]drawable/filename 示例在xml中创建的ImageView，可以为其添加drawable资源文件 1234567&lt;ImageView android:id="@+id/dialog_image" android:layout_width="match_parent" android:layout_height="wrap_content" android:src="@mipmap/plus_logo" android:scaleType="fitCenter" /&gt; 在代码中获取位图文件资源的方法如下： 12Resources resources = getResources();resources.getDrawable(R.drawable.plus_logo); 为ImageView增加位图文件： 1imageView.setImageResource(R.drawable.plus_logo); XML位图xml位图文件是在XML中定义资源，指向位图文件，不过其可以为位图增加多种属性。 语法123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bitmap xmlns:android="http://schemas.android.com/apk/res/android" android:src="@[package:]drawable/drawable_resource" android:antialias=["true" | "false"] android:dither=["true" | "false"] android:filter=["true" | "false"] android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" | "fill_vertical" | "center_horizontal" | "fill_horizontal" | "center" | "fill" | "clip_vertical" | "clip_horizontal"] android:mipMap=["true" | "false"] android:tileMode=["disabled" | "clamp" | "repeat" | "mirror"] /&gt; 元素 bitmap 定义位图来源及其属性 属性 android:src 资源文件的位置(必填) android:antialias boolean类型 是否启用抗锯齿 android:dither boolean类型 当位图的像素配置与屏幕不同时（例如：ARGB 8888 位图和 RGB 565 屏幕），启用或停用位图抖动。 android:filterboolean类型。是否启用位图过滤。当位图收缩或拉伸以使其外观平滑时使用过滤。 android:gravity 定义位图的重力。重力指示当位图小于容器时，可绘制对象在其容器中放置的位置。有如下几个属性值top、bottom、left 、right、center_vertical、fill_vertical、center_horizontal、fill_horizontal、center、fill、clip_vertical 、clip_horizontal android:mipMap boolean类型，是否启用 mipmap 提示。 android:tileMode 平铺模式，有以下可选值： disabled 不平铺位图。这是默认值。 clamp 当着色器绘制范围超出其原边界时复制边缘颜色 repeat 水平和垂直重复着色器的图像。 mirror 水平和垂直重复着色器的图像，交替镜像图像以使相邻图像始终相接。 九宫格文件九宫格文件就是我们常说的.9文件，可以使用draw9patch生成，AS中也可以直接生成该文件。文件以.9.png结尾，编译生成的资源数据类型为NinePatchDrawable. XML九宫格语法12345&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;nine-patch xmlns:android="http://schemas.android.com/apk/res/android" android:src="@[package:]drawable/drawable_resource" android:dither=["true" | "false"] /&gt; 图层列表图层列表可以按照列表的顺序绘制资源，列表的最后一个对象绘制在最顶部，类似于iOS中的CAReplicatorLayer 语法1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item android:drawable="@[package:]drawable/drawable_resource" android:id="@[+][package:]id/resource_name" android:top="dimension" android:right="dimension" android:bottom="dimension" android:left="dimension" /&gt;&lt;/layer-list&gt; 定义要放在图层可绘制对象中由其属性定义的位置的可绘制对象。必须是 元素的子项。接受子bitmap元素。 状态列表状态列表常用于对于同一图形的不同状态显示不同的样式，比如Button，RadioButton等具有多种不同状态控件，可以利用状态列表来为每种状态设置可绘制的内容。编译的资源类型为StateListDrawable。 在每个状态变更期间，将从上到下遍历状态列表，并使用第一个与当前状态匹配的项目。此选择并非基于“最佳匹配”，而是选择符合状态最低条件的第一个项目 语法1234567891011121314151617&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android" android:constantSize=["true" | "false"] android:dither=["true" | "false"] android:variablePadding=["true" | "false"] &gt; &lt;item android:drawable="@[package:]drawable/drawable_resource" android:state_pressed=["true" | "false"] android:state_focused=["true" | "false"] android:state_hovered=["true" | "false"] android:state_selected=["true" | "false"] android:state_checkable=["true" | "false"] android:state_checked=["true" | "false"] android:state_enabled=["true" | "false"] android:state_activated=["true" | "false"] android:state_window_focused=["true" | "false"] /&gt;&lt;/selector&gt; 元素 selector必须为根元素，包含一个或多个item元素 android:variablePaddingboolean 类型。如果可绘制对象的内边距应根据选择的当前状态而变化，则值为true；如果内边距应保持不变（基于所有状态的最大内边距），则值为false。启用此功能要求您在状态变更时处理执行布局，这通常不受支持。默认值为false。 item该元素定义了不同状态下的可绘制对象的属性。 android:drawable android:state_pressedboolean类型，定义对象的状态是按下或默认状态。 android:state_focusedboolean类型 定义了对象是否在聚焦（可编辑）状态。 android:state_selectedboolean类型， 当焦点 (android:state_focused) 不充分（例如，列表视图有焦点但使用方向键选择其中的项目）时，使用所选状态。 android:state_checkableboolean类型。如果当对象可选中时应使用此项目(如RadioGroup)，则值为true；如果 当对象不可选中时应使用此项目，则值为false。 android:state_checkedboolean类型。如果在对象已选中时应使用此项目，则值为true； 如果在对象未选中时应使用此项目，则值为false。 android:state_enabledboolean类型。如果在对象启用（能够接收触摸/点击事件）时应使用此项目， 则值为“true”；如果在对象停用时应使用此项目，则值为false。 android:state_window_focusedboolean类型。如果当应用窗口有焦点（应用在前台）时应使用此项目，则值为true；如果当应用窗口没有焦点（例如，通知栏下拉或对话框出现）时应使用此项目，则值为false。 示例12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;selector xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item android:state_pressed="true"&gt; &lt;shape android:shape="rectangle"&gt; &lt;corners android:radius="2dp" /&gt; &lt;solid android:color="#44BF1A" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:state_enabled="true"&gt; &lt;shape android:shape="rectangle"&gt; &lt;corners android:radius="2dp" /&gt; &lt;solid android:color="#44BF1A" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item android:state_enabled="false"&gt; &lt;shape android:shape="rectangle"&gt; &lt;corners android:radius="2dp" /&gt; &lt;solid android:color="#337523" /&gt; &lt;/shape&gt; &lt;/item&gt; &lt;item&gt; &lt;shape android:shape="rectangle"&gt; &lt;corners android:radius="2dp" /&gt; &lt;solid android:color="#337523" /&gt; &lt;/shape&gt; &lt;/item&gt;&lt;/selector&gt; 级别列表管理大量备选可绘制对象的可绘制对象，每个可绘制对象都分配有最大的备选数量。使用setLevel()设置可绘制对象的级别值会加载级别列表中 android:maxLevel 值大于或等于传递到方法的值的可绘制对象资源。 语法12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item android:drawable="@drawable/drawable_resource" android:maxLevel="integer" android:minLevel="integer" /&gt;&lt;/level-list&gt; 元素 level-list这必须是根元素。包含一个或多个 元素。 item定义特定级别的可绘制对象 android:maxLevel整型。此项目允许的最高级别。 android:minLevel整型。此项目允许的最低级别。 示例123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;level-list xmlns:android="http://schemas.android.com/apk/res/android" &gt; &lt;item android:drawable="@drawable/status_off" android:maxLevel="0" /&gt; &lt;item android:drawable="@drawable/status_on" android:maxLevel="1" /&gt;&lt;/level-list&gt; 转换可绘制对象TransitionDrawable 是可在两种可绘制对象资源之间交错淡出的可绘制对象。 每个可绘制对象由单一transition 元素内的item元素表示。不支持超过两个项目。要向前转换，请调用 startTransition(timeIntval)。要向后转换，则调用 reverseTransition(timeIntval)。 使用比较简单，不详细介绍了。 插入可绘制对象在 XML 文件中定义的以指定距离插入其他可绘制对象的可绘制对象。当视图需要小于视图实际边界的背景时，此类可绘制对象很有用。编译时生成InsetDrawable对象。 语法12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;inset xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/drawable_resource" android:insetTop="dimension" android:insetRight="dimension" android:insetBottom="dimension" android:insetLeft="dimension" /&gt; 示例123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;inset xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/plus_logo" android:insetBottom="10dp" android:insetLeft="50dp" android:insetRight="50dp" android:insetTop="10dp"&gt;&lt;/inset&gt; 裁剪可绘制对象在 XML 文件中定义的对其他可绘制对象进行裁剪（根据其当前级别）的可绘制对象。根据级别以及用于控制其在整个容器中位置的重力，来控制子可绘制对象的裁剪宽度和高度。常用于进度条以及图片渐进式显示。 语法12345678&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;clip xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/drawable_resource" android:clipOrientation=["horizontal" | "vertical"] android:gravity=["top" | "bottom" | "left" | "right" | "center_vertical" | "fill_vertical" | "center_horizontal" | "fill_horizontal" | "center" | "fill" | "clip_vertical" | "clip_horizontal"] /&gt; 元素 clip 必须为根元素。 android:clipOrientation 裁剪方向，横向和纵向。 android:gravity 要裁减的位置 注：默认级别为 0，即完全裁剪，使图像不可见。当级别为 10,000 时，图像不会裁剪，而是完全可见。 缩放可绘制对象在 XML 文件中定义的更改其他可绘制对象大小（根据其当前级别）的可绘制对象。编译时生成ScaleDrawable对象。 语法123456789&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;scale xmlns:android="http://schemas.android.com/apk/res/android" android:drawable="@drawable/drawable_resource" android:scaleGravity=["top" | "bottom" | "left" | "right" | "center_vertical" | "fill_vertical" | "center_horizontal" | "fill_horizontal" | "center" | "fill" | "clip_vertical" | "clip_horizontal"] android:scaleHeight="percentage" android:scaleWidth="percentage" /&gt; 元素 scale 定义缩放可绘制对象，必须为根元素。 android:scaleGravity 指定缩放后的重力位置。 android:scaleHeight 百分比。缩放高度，表示为可绘制对象边界的百分比。值的格式为 XX%。例如：100%、12.5% 等。 android:scaleWidth 百分比。缩放宽度，表示为可绘制对象边界的百分比 形状可绘制对象常用于绘制边框，渐变色等。编译时生成GradientDrawable对象。 语法123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android" android:shape=["rectangle" | "oval" | "line" | "ring"] &gt; &lt;corners android:radius="integer" android:topLeftRadius="integer" android:topRightRadius="integer" android:bottomLeftRadius="integer" android:bottomRightRadius="integer" /&gt; &lt;gradient android:angle="integer" android:centerX="float" android:centerY="float" android:centerColor="integer" android:endColor="color" android:gradientRadius="integer" android:startColor="color" android:type=["linear" | "radial" | "sweep"] android:useLevel=["true" | "false"] /&gt; &lt;padding android:left="integer" android:top="integer" android:right="integer" android:bottom="integer" /&gt; &lt;size android:width="integer" android:height="integer" /&gt; &lt;solid android:color="color" /&gt; &lt;stroke android:width="integer" android:color="color" android:dashWidth="integer" android:dashGap="integer" /&gt;&lt;/shape&gt; 元素 shape形状可绘制对象,跟标签。 android:shape 定义形状的类型 rectangle 填充包含视图的矩形。这是默认形状。 oval 适应包含视图尺寸的椭圆形状。 line 跨越包含视图宽度的水平线。此形状需要 元素定义线宽。 ring 环形 android:innerRadius 尺寸。环内部（中间的孔）的半径，以尺寸值或尺寸资源表示。当shape类型为ring时有效。 android:innerRadiusRatio 环内部的半径，以环宽度的比率表示。例如，如果 android:innerRadiusRatio=”5”，则内半径等于环宽度除以 5。此值被 android:innerRadius 覆盖。默认值为 9。当shape类型为ring时有效。 android:thickness 环的厚度。当shape类型为ring时有效。 android:thicknessRatio 环的厚度，表示为环宽度的比率。例如，如果 android:thicknessRatio=”2”，则厚度等于环宽度除以 2。此值被 android:innerRadius 覆盖。默认值为 3。当shape类型为ring时有效。 corners 为形状产生圆角。仅当形状为矩形时适用。 角半径 android:radius,android:topLeftRadius,android:topRightRadius,android:bottomLeftRadius,android:bottomRightRadius 注：（最初）必须为每个角提供大于 1 的角半径，否则无法产生圆角。如果希望特定角不要倒圆角，解决方法是使用 android:radius 设置大于 1 的默认角半径，然后使用实际所需的值替换每个角，为不希望倒圆角的角提供零（“0dp”） gradient 形状的渐变颜色 android:angle 渐变的角度（度）。0 为从左到右，90 为从上到上。必须是 45 的倍数。默认为0，即水平方向。 android:centerX 渐变中心的相对 X 轴位置 (0 - 1.0)。 android:centerY 渐变中心的相对 Y 轴位置 (0 - 1.0)。 android:centerColor起始颜色与结束颜色之间的可选颜色，以十六进制值或颜色资源表示。 android:endColor 结束颜色，表示为十六进制值或颜色资源。 android:gradientRadius 渐变的半径。仅在 android:type=”radial” 时适用。 android:startColor 起始颜色，表示为十六进制值或颜色资源。 android:type 要应用的渐变图案的类型 linear 线性渐变。这是默认值。 radial 径向渐变。起始颜色为中心颜色。 sweep 流线型渐变。 padding 要应用到包含视图元素的内边距(这会填充视图内容的位置，而非形状)。 size 形状的大小 注：默认情况下，形状按照此处定义的尺寸按比例缩放至容器视图的大小。在 ImageView 中使用形状时，可通过将 android:scaleType 设置为 “center” 来限制缩放。 solid 填充色。指定在android:color中。 stroke 形状的笔划中线。 android:width线宽。 android:color颜色 android:dashGap 短划线的间距 android:dashWidth短划线的大小]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 6.0模拟器上运行ARM架构程序]]></title>
    <url>%2F2017%2F04%2F28%2FAndroid-%E6%A8%A1%E6%8B%9F%E5%99%A8%E4%B8%8A%E8%BF%90%E8%A1%8CARM%E6%9E%B6%E6%9E%84%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[原生的Genymotion模拟器只支持x86架构的包，对于使用了不支持x86架构的.so文件的app来说是无法正常运行的。如果需要运行此类app，需要arm解释器来解释x86的语法。 下面将介绍如何让genymotion支持arm架构安装genymotion：genymotion2.9。安装完成后需要登录账号激活，下载需要使用的模拟器环境（需要启动6.0以上的模拟器，低版本的可以去其他链接找translation）。下载arm解释器：百度网盘下载安装完成后启动genymotion模拟器，将下载的安装包拖入，然后一直点击确认即可。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 动画指南(二)]]></title>
    <url>%2F2017%2F02%2F09%2FiOS-%E5%8A%A8%E7%94%BB%E6%8C%87%E5%8D%97-2%2F</url>
    <content type="text"><![CDATA[Core Animation的结构体系Core Animation是直接作用与CALayer上的动画处理API，执行动画过程中并不会阻塞住主线程。你可以使用CoreAnimation实现简单的显式动画和隐式动画，隐式动画会使用默认的动画效果和动画时间。Core Animation的结构体系如下图所示： 由上图可以看出，Core Animation以CAAnimation作为基类，派生出了动画组CAAnimationGroup,属性动画CAPropertyAnimation以及转场动画CATrasition三个大类，实现了CAMediaTiming动画协议，以及CAAction协议。CAAnimation作为基类，并不能直接使用。 CAAnimation属性及方法12345678910+ (instancetype)animation; //创建一个动画Object+ (nullable id)defaultValueForKey:(NSString *)key; //用于获取Animation的存储值。- (BOOL)shouldArchiveValueForKey:(NSString *)key; //是否保存某个key对应的value，主要用于子类。@property(nullable, strong) CAMediaTimingFunction *timingFunction; //动画执行的模式@property(nullable, strong) id &lt;CAAnimationDelegate&gt; delegate; //代理，主要控制开始和结束后的处理。@property(getter=isRemovedOnCompletion) BOOL removedOnCompletion; //完成后是否自动移除动画，默认为NO。 CAMediaTiming12345678910111213141516171819202122232425262728293031CAMediaTiming 定义了动画中与时间相关的一些属性。//动画的起始时间@property CFTimeInterval beginTime;//动画时常@property CFTimeInterval duration;//动画的速度@property float speed;//时间偏移量，可以使用该属性配合speed来达到动画暂停的效果，默认为0.@property CFTimeInterval timeOffset;//重复次数，可以设置为无限重复@property float repeatCount;//重复时间@property CFTimeInterval repeatDuration;//自动反转回到原状态，默认为NO@property BOOL autoreverses;/* 决定当前对象在非active时间段的行为,要想fillMode有效，最好设置removedOnCompletion = NO. * kCAFillModeForwards 当动画结束后，Layer会一直保持着动画最后的状态 * kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个Layer，Layer便立即进入动画的初始状态并等待动画开始。 * kCAFillModeRemoved 这个是默认值，也就是说当动画开始前和动画结束后，动画对Layer都没有影响，动画结束后，Layer会恢复到之前的状态 * kCAFillModeBoth 这个其实就是上面两个的合成.动画加入后开始之前，Layer便处于动画初始状态，动画结束后Layer保持动画最后的状态 */@property(copy) NSString *fillMode; CAAnimationDelegateCAAnimationDelegate协议主要由两个方法组成 123- (void)animationDidStart:(CAAnimation *)anim; //动画开始- (void)animationDidStop:(CAAnimation *)anim finished:(BOOL)flag; //动画结束，flag为动画是否完成的标志。 CAMediaTimingFunctionCAMediaTimingFunction主要定义了动画的时序方式。 1234567891011121314/* 快速的创建一个通用的时序方式 * 系统默认提供了4种可供选择： * kCAMediaTimingFunctionLinear 线性效果 * kCAMediaTimingFunctionEaseIn 淡入效果 * kCAMediaTimingFunctionEaseOut 淡出效果 * kCAMediaTimingFunctionEaseInEaseOut 淡入淡出效果 * kCAMediaTimingFunctionDefault 默认效果 *／+ (instancetype)functionWithName:(NSString *)name;//自定义一种时序方式，定义两个(x,y)点+ (instancetype)functionWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y;- (instancetype)initWithControlPoints:(float)c1x :(float)c1y :(float)c2x :(float)c2y; CAPropertyAnimationCAPropertyAnimation是CAAnimation的一大子类，主要处理与Layer属性相关的动画。 123456789101112131415161718192021// 创建一个基于Layer属性的动画，path为Layer的一个属性。+ (instancetype)animationWithKeyPath:(nullable NSString *)path;@property(nullable, copy) NSString *keyPath;/* 这个属性确定动画执行的状态是否叠加在Layer的原状态上 * 默认设置为NO，如果我们执行两次位置移动的动画，会从同一位置执行两次 * 如果设置为YES，则会在第一次执行的基础上执行第二次动画 *／@property(getter=isAdditive) BOOL additive;/* * 这个属性对重复执行的动画有效果 * 默认为NO，重复执行的动画每次都是从起始状态开始 * 如果设置为yes，则为此执行都会在上一次执行的基础上执行 */@property(getter=isCumulative) BOOL cumulative;//transform形变动画对象，可以定义如何进行形变。(用处较少)@property(nullable, strong) CAValueFunction *valueFunction; CABasicAnimationCABasicAnimation继承自CAPropertyAnimation,并紧紧多出了三个属性： 123@property(nullable, strong) id fromValue;@property(nullable, strong) id toValue;@property(nullable, strong) id byValue; 这三个属性定义了动画的起始值，中间值以及结束值。 CAKeyframeAnimation 关键帧动画CAKeyframeAnimation继承自CAPropertyAnimation,可以为Layer提供一个关键帧动画。可以通过父类的animationWithKeyPath方法创建一个关键帧动画，该方法指定了需要动画的内容路径。然后我们可以为该动画设置动画时间及其行为。 API12345678910111213141516171819202122232425262728293031323334353637383940414243/* * values是一个关键帧数组，每一个值被称为一个关键帧，动画的内容将会依次展现该数组中的关键帧。 */@property(nullable, copy) NSArray *values;/* * 对于大多数动画类型而言，使用values指定动画间值是足够的。当指定了path的值后，value属性便会失效，path属性多用于坐标点(如position)的曲线移动。 */ @property(nullable) CGPathRef path; /* * keyTimes数组指定了动画时间内，每一个关键帧展示时的时间比，其值介于[0,1]之间。CoreAnimation会依据values和keyTimes生成连续的动画。 */ @property(nullable, copy) NSArray&lt;NSNumber *&gt; *keyTimes; /* * timingFunctions可以用来指定到达每一个关键帧的速度控制函数，可选操作。如果定义了n个关键帧，那么`timingFunctions`的个数需为n-1个。 */ @property(nullable, copy) NSArray&lt;CAMediaTimingFunction *&gt; *timingFunctions; /* * calculationMode是告诉CoreAnimation应该如何生成关键帧动画，有以下几种可选值 * kCAAnimationLinear 默认值，表示关键帧坐标点时，关键帧之间直接进行线性连接进行插值计算 * kCAAnimationDiscrete 不进行插值，所有关键帧离散显示，会有瞬间移动的效果。 * kCAAnimationPaced 使得动画均匀进行，此时keyTimes属性和timingFunctions属性失效。 * kCAAnimationCubic 对关键帧进行圆滑曲线计算。 * kCAAnimationCubicPaced 看名字就知道，是在kCAAnimationCubic基础上进行线性插值。 */ @property(copy) NSString *calculationMode; /* * 该属性决定了动画过程中Layer是否沿着路径的正切方向进行旋转。有两个可选值`kCAAnimationRotateAuto`和 * `kCAAnimationRotateAutoReverse`。设置为nil，则不进行旋转处理。 */ @property(nullable, copy) NSString *rotationMode; /* * 对于kCAAnimationCubic模式，这三个属性主要是控制Kochanek–Bartels 样条的样式，取值介于[-1,1] * 具体可以参考[维基百科](https://en.wikipedia.org/wiki/Kochanek–Bartels_spline), */ @property(nullable, copy) NSArray&lt;NSNumber *&gt; *tensionValues; @property(nullable, copy) NSArray&lt;NSNumber *&gt; *continuityValues; @property(nullable, copy) NSArray&lt;NSNumber *&gt; *biasValues; 动画示例 抖动动画 1234567891011- (void)shakeAnimation &#123; CAKeyframeAnimation * animation = [CAKeyframeAnimation animation]; animation.keyPath = @"transform.rotation"; animation.values = @[@(-5 / 180.0 * M_PI),@(5 /180.0 * M_PI),@(-5/ 180.0 * M_PI)]; animation.removedOnCompletion = NO; animation.fillMode = kCAFillModeForwards; animation.duration = 0.3; animation.repeatCount = MAXFLOAT; [self.Layer addAnimation:animation forKey:nil];&#125; CASpringAnimation 阻尼动画CASpringAnimation继承自CABasicAnimation,是iOS9之后新增加的API，可以方便的为Layer增加弹簧动画。 API12345678910111213141516171819202122/* * 弹簧末端的质量，默认为1，值必须大于0。该数值会影响弹簧的惯性，值越大，弹簧的振幅越大，而响应速度会相对较小。 */@property CGFloat mass;/* * 弹簧的刚度系数，值越大，形变后产生的力越大，速度越快。 */@property CGFloat stiffness;/* * 阻尼系数，影响弹簧弹动次数，如果值为0，则会产生无阻尼运动。取值介于[0,1],会有弹性效果，大于1会处于过阻尼状态，没有弹性动画。 */@property CGFloat damping;/* * 初速度，动画的初始速度。默认为0，负值意味着与运动方向相反，正值时意味着与运动方向保持一致。 */@property CGFloat initialVelocity;/* * 预估的运动时间，CoreAnimation将会依据SpringAnimation中的各个参数预估出弹簧动画的时间。 */ @property(readonly) CFTimeInterval settlingDuration; 示例动画123456789CASpringAnimation *animation = [CASpringAnimation animation];animation.mass = 10.0f;animation.initialVelocity = 10.0f;animation.stiffness = 0.3;animation.damping = 0.3;animation.fillMode = kCAFillModeForwards;animation.removedOnCompletion = NO;animation.toValue = [NSValue valueWithCGPoint:CGPointMake(300.0, 300.0)];[_button.Layer addAnimation:animation forKey:@"position"]; CATransitionCATransition可以用来处理Layer的转场动画，默认是渐入渐出的效果。 API12345678910111213141516171819202122/* * 转场的类型，有几种可选的类型。 * kCATransitionFade 淡入淡出 * kCATransitionMoveIn 旧视图覆盖新视图，配合subtype类型可以选择切入方向。 * kCATransitionPush 新视图将原有视图推出 * kCATransitionReveal 逐渐显示新内容 */@property(copy) NSString *type;/* * 可选子类型，用于指定type的入场方向。 * kCATransitionFromRight * kCATransitionFromLeft * kCATransitionFromTop * kCATransitionFromBottom */@property(nullable, copy) NSString *subtype;/* * 转场动画的开始执行的位置和结束的位置。两者均需介于[0,1],并且开始进度要大于结束进度。 */@property float startProgress;@property float endProgress; 示例123456CATransition *transition = [CATransition animation];transition.duration = 5.0f;transition.repeatCount = 100;transition.type = kCATransitionMoveIn;transition.subtype = kCATransitionFromLeft;[self.img.Layer addAnimation:transition forKey:nil]; kCATransitionMoveIn kCATransitionPush kCATransitionReveal 私有类型12345678910111213@"cameraIris"@"cameraIrisHollowOpen"@"cameraIrisHollowClose"@"cube"@"alignedCube"@"flip"@"alignedFlip"@"oglFlip"@"rotate"@"pageCurl"@"pageUnCurl"@"rippleEffect"@"suckEffect" 私有类型动画，来自stackoverflow 12345678/* * filter 属性默认为 nil ，一旦设置了此属性， type 和 subtype 就会被忽略。 该属性是将滤镜提供给transition，该属性 * 的对象需要实现inputImage 、 inputTargetImage 、 inputTime 、 outputImage ，当然还有一个可选的 * inputExtent描述transition作用的矩形区域。在这里先留个坑，后面会有文章详细介绍CIFilter的用法。滤镜的效果似乎 * 只支持Mac OS 对于iOS来说似乎并没有什么效果， */@property(nullable, strong) id filter; CAAnimationGroup动画组，CAAnimationGroup提供了一个animations属性，可以将多个动画整合到一起，将CAAnimationGroup作为动画属性添加到Layer上，使多个动画可以同时或按照一定顺序作用在Layer上。 Tips利用转场动画控制两个视图的移入与移出转场动画可以为Layer的显示增加动画。大多数情况下，transition用来控制一个Layer的出现和另一个Layer的消失，与基于属性的动画类型不同，transition动画会维护一个Layer的缓存层而导致无法实现某一个属性的动画。因此transition动画只是为了动画的转场而实现的。 示例123456789101112CATransition* transition = [CATransition animation];transition.startProgress = 0;transition.endProgress = 1.0;transition.type = kCATransitionPush;transition.subtype = kCATransitionFromRight;transition.duration = 1.0;[_img.Layer addAnimation:transition forKey:@"transition"];[_img2.Layer addAnimation:transition forKey:@"transition"];_img2.hidden = YES;_img.hidden = NO; 不同的Layer可以同时触发相同的tansition动画对象，而没必要另外对不同的Layer创建多个相同的transition。 控制动画的时间时机是动画重要的一部分,CoreAnimation和CALayer都通过CAMediaTiming协议实现了动画时间控制的相关方法。Layer实现了该协议主要是用来实现默认的隐式动画。当考虑到动画和时间控制的时候，需要理解Layer是如何进行时间控制的。每个Layer都会有一个”local time”来管理时间,大多数情况下，不同Layer的”local time”几乎相同。然而，一个Layer的”local time”可能会由其父视图层或者本身的时间控制参数被改变。例如改变一个Layer的speed属性会引起动画的持续时间(duration)发生改变，当然其子视图的动画时间也会发生改变。CALayer类提供了convertTime:fromLayer:和convertTime:toLayer:来帮助我们确定一个layer的”local time”。例如CFTimeInterval localLayerTime = [myLayer convertTime:CACurrentMediaTime() fromLayer:nil];该方法可以获取一个layer的”local time”。通过Layer的”local time”属性，我们可以设置跟时间控制相关的动画属性。 beginTimebeginTime属性用来控制动画的起始时间，可以使动画延时一段时间执行，通常用于动画组中多个动画的顺序执行。如果设置了该属性，需要将动画的fillMode设置为kCAFillModeBackwards,该属性将会保证动画在开始时动画的start value的正确。 timeOffsettimeOffset属性用来控制动画起始于timeOffset的时间点，使动画只执行全部动画的一部分。 暂停和唤醒动画事实上可以利用CAMediaTiming协议中的speed属性来控制动画的暂停与唤醒，当speed的值为0时，动画会暂停下来，唤醒只需要将speed的值设置为非零值便可以唤醒动画。 官方示例1234567891011121314- (void)pauseLayer:(CALayer*)layer &#123; CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime() fromLayer:nil]; layer.speed = 0.0; layer.timeOffset = pausedTime;&#125;- (void)resumeLayer:(CALayer*)layer &#123; CFTimeInterval pausedTime = [layer timeOffset]; layer.speed = 1.0; layer.timeOffset = 0.0; layer.beginTime = 0.0; CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime() fromLayer:nil] - pausedTime; layer.beginTime = timeSincePause;&#125; Transaction事务动画的事务是通过CATransaction类来管理的，当我们创建了一个动画，事实上并没有立刻发生变化，而是提交到事务由事务去处理将Layer的状态更新到新值。可以通过transaction创建一个显式动画： 1234[CATransaction begin];theLayer.zPosition=200.0;theLayer.opacity=0.0;[CATransaction commit]; 事务支持嵌套调用，可以为在不同层的事务中设置不同的动画属性。同时也可以设置完成时的回调函数：+ (void)setCompletionBlock:(nullable void (^)(void))block; 禁用动画属性1234[CATransaction begin];[CATransaction setValue:@(YES) forKey:kCATransactionDisableActions];// do something[CATransaction commit]; 在transaction中的代码如果设置了禁用动画属性，就不会执行任何动画效果，包括隐式动画。 为子视图增加3D效果这里的3D效果是通过修改transform3D属性达到的，在矩阵视图中，m34变量可以控制3D效果的立体感。至于为什么m34可以达到3D效果会在后面的文章中介绍。 Apple示例12345CATransform3D perspective = CATransform3DIdentity;perspective.m34 = -1.0/eyePosition;// Apply the transform to a parent layer.myParentLayer.sublayerTransform = perspective; 参考 显式动画与隐式动画 Core Animation Programming Guide]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 动画指南(一)]]></title>
    <url>%2F2016%2F12%2F28%2FiOS-%E5%8A%A8%E7%94%BB%E6%8C%87%E5%8D%97-1%2F</url>
    <content type="text"><![CDATA[概述在iOS开发中，经常会使用动画效果来使app变得更生动，增强体验效果。iOS的动画效果开发分为两种，基于QuartzCore框架的CoreAnimation和基于UIKit的UIView Animation。不过从本质将，UIView的animaton底层仍然基于CoreAnimation实现的，只不过方法更高级，掌握了CALayer层的动画，使用起UIView层的动画便会毫不费力。 CALayer在了解CoreAnimation之前，需要先了解下CALayer，CALayer是CoreAnimation的操作核心，类似于Views，管理者坐标，内容和其他视觉属性，但layers并不定义它们的样式。本质上CALayer是将其中的内容映射为位图，经由OpenGL底层Api提供给硬件进行操作。如下图所示：UIView是CALayer的delegate，每次当我们创建了一个View时会自动创建一个CALayer作为根图层，不可以重新创建。不过可以通过重写+ (Class)layerClass方法指定View在创建时的根视图的CALayer子类。虽然我们无法重新创建根视图，不过View的根视图在大多数情况下都是充当操作容器的，因为CALayer跟View类似，也是可以add/remove/insert子图层的。 基于layer的绘图模型在app中大多数layer并不进行实际绘制。相反，layer会捕捉你提供的contents并把它缓存至一个bitmap中，也被称作后帧缓存。当某个改变出发了动画，Core Animation会把layer的bitmap和状态信息交给图形硬件。因为layer操作的是一个bitmap，所以不同于UIView的绘制，View的drawing通常会由drawRect方法重绘。UIView的绘制通常比较昂贵，因为它在主线程上使用CPU。Core Animation避免了这种损耗，通过缓存bitmap到图形硬件来达到相同的效果。 基于layer的动画layer在视图上显示的内容和状态是分离开的。这种解耦使得Core Animation可以使layer动画式的改变原来状态。layer的一些属性都被标记为可动画的，具体参考下文。 CALayer的常用属性(animatable) backgroundColor 图层背景颜色 borderColor 边框颜色 bounds 与UIView中的bounds类似，支持隐式动画 position 位置，默认为0 zPosition z轴层级，可以设置该属性使layer浮在所有layer上层。layer的上浮会使layer显示，但是并不会影响view的事件响应。 anchorPoint anchorPoint 和中心点position重合的一个点，称为“锚点”，锚点的描述是相对于x、y位置比例而言的默认在图像中心点(0.5,0.5)的位置，后文具体讨论。 anchorPointZ Z轴的锚点 contents 图层内容，可以设置内容为图片 contentsRect 图层内容的位置 cornerRadius 圆角半径 doubleSided 图层背面是否显示，默认显示 transform 形状变换 hidden 隐藏属性 doubleSided 控制图层的背面是否需要绘制，默认为YES。 sublayerTransform 子layer形变 mask 蒙版 opacity 透明度 borderColor 边框颜色，默认黑色 borderWidth 边框线宽，默认为零 更多的属性请参考官方:Animatable Properties 注意：1.支持隐式动画属性是指属性变动默认隐含了CABasicAnimation动画的实现。2.CALayer很少使用frame属性是因为其本身不支持动画属性，通常使用bounds和position来代替。3.在使用CALayer做动画时，需要保证当前layer在可见状态，也就是显示在窗口中，否则，动画不会执行(绘制在不会显示的区域会耗费电量，所以猜测系统不会执行在可见区域以外的动画)。 Layer使用了两种类型的坐标系统，一种是基于point-based coordinate system，另一种是基于unit coordinate system，其实也就是相对坐标系和以自身为中心的坐标系。默认的坐标系在iOS上和OS X上并不相同，可以参考下图： 需要注意的是默认情况下position属性是在layer的中心，unit coordinate的坐标取值是0-1。 geomeryFlipped属性用来在必要的时候改变默认的y轴方向，使用这一属性可以纠正layer的方向。(iOS上好像么用) Anchor Point 对几何位置的影响layer的anchorPoint属性会影响layer的几何位置，主要表现为对位置 position和transform形变的影响。官方的例子如下：如果将anchorPoint从(0.5,0.5)移动至(0,0)，即便没有移动bounds，其position依然发生了改变。anchorPoint也会影响layer的transformations, Layer的3D变换每一个Layer都有两个变换矩阵可以操作。transform属性可以让你操作layer和其内部的子layer。sublayerTransform属性定义了额外的变换只会应用于layer的子layer中。形变任务通过矩阵乘法来获得新的坐标。算法如下图:幸运的是我们没有必要去修改这样的矩阵来实现形变，Core Animation已经为我们提供了一整套缩放，旋转的API。另外，也部分支持KVC模式让我们修改形变，如下: Field Key Path Value rotation.x NSNumber rotation.y NSNumber rotation NSNumber scale.x NSNumber scale.y NSNumber scale.z NSNumber scale NSNumber translation.x NSNumber translation.y NSNumber translation.z NSNumber 矩阵乘法的一些简单例子(来自官网): Layer的树反映了动画的不同状态，共分为3种。第一种状态是我们可以修改的，被称为model layer tree，第二种被称为presentation tree，这种状态的层树我们无法修改其状态，因为其代表了过程中的layer，不过我们可以获得当前层树的状态值，然后基于这个值创建新的动画。第三种被称为render tree，实际渲染动画，private。 Layer的种类不同的Layer会提供不同的功能。Core Animation提供了许多标准的layer类，来应对不同的场景。CALayer是这些layer类的根类，它定义了所有不同layer的共同功能。 以下是几种不同Layer 类和他们的适用范围： Class Usage CAEmitterLayer 粒子发射器效果 CAGradientLayer 颜色渐变层 CAMetalLayer 创建和绘制纹理(Metal API) CAEAGLLayer/CAOpenGLLayer 可以使用OpenGLES创建帧缓存和上下文的层 CAReplicatorLayer 镜像层,可以复制自己子层的layer,并且复制的出来的layer和原来的子layer拥有相同的动效 CAScrollLayer 可滚动的层，scrollview的效果 CAShapeLayer 用于绘制三次贝塞尔曲线。CAShaperLayer对绘制基于路径的形状非常有帮助。因为CAShaperLayer总是生成一个最新的路径。而如果将路径画在图层储备中，一旦图层被缩放，形状就变形了。 CATextLayer 用于渲染一个无格式或属性文本字符 CATiledLayer 部分载入大图(如PDF，地图)，支持缩放 CATransformLayer 用于渲染一个真3D的图层层级。而不是由其他图层类实现的2D图层层级。 CAEmitterLayerCAEmitterLayer可以作为粒子发射器实现类似火焰、雨滴下落、烟花等动画的效果。CAEmitterLayer使用CAEmitterCell作为粒子，可以设置发射的时间，速度加速度等参数。每个CAEmitterCell内部仍然可以嵌套CAEmitterCell在中途实现分裂效果。下面介绍CAEmitterLayer的相关属性。 emitterCells 发射粒子，可以设置多个 float brithRate 每秒的发射个数，默认1.0。每秒产生的真实粒子数为CAEmitterLayer的birthRate*子粒子的birthRate float lifetime 生命周期，默认值为1,可动画。 emiiterPosition emitterZPosition 辐射中心坐标 emitterSize 辐射范围，与emitterShape属性相关，依赖shape的值会被忽略。 emitterShape 辐射的形状，iOS中定义了一下几个值 kCAEmitterLayerPoint 点状，坐标为emitterPosition坐标。 kCAEmitterLayerLine 线状坐标为(emitterPosition.x - emitterSize.width/2, emitterPosition.y, emitterZPosition) to (emitterPosition.x + emitterSize.width/2, emitterPosition.y, emitterZPosition) kCAEmitterLayerRectangle 矩形可带圆角顶点坐标为[emitterPosition.x - emitterSize.width/2, emitterPosition.y - emitterSize.height/2, emitterZPosition], [emitterPosition.x + emitterSize.width/2, emitterPosition.y + emitterSize.height/2, emitterZPosition] kCAEmitterLayerCuboid 3D矩形可带圆角辐射顶点坐标为[emitterPosition.x - emitterSize.width/2, emitterPosition.y - emitterSize.height/2, emitterZPosition - emitterDepth/2], [emitterPosition.x + emitterSize.width/2, emitterPosition.y + emitterSize.height/2, emitterZPosition+emitterDepth/2] kCAEmitterLayerCircle 圆形辐射辐射中心为(emitterPosition.x, emitterPosition.y, emitterZPosition)，半径emitterSize.width。 kCAEmitterLayerSphere 球体球心坐标(emitterPosition.x, emitterPosition.y, emitterZPosition),半径emitterSize.width renderMode 渲染模式 emitterMode 辐射模式 velocity 初始速度，与Cell粒子速度的乘积为粒子实际速度。默认值为1 scale 尺寸 spin 转速 seed 随机数 CAEmitterCell作为发射的粒子，CAEmitterCell遵循CAMediaTiming协议，同时其具备作为辐射源继续辐射粒子的能力。 emitterCell;快速创建一个粒子 name 粒子的名称。 enabled 决定粒子是否被渲染。 birthRate 每秒子粒子发射次数，默认为0。 lifetime 存活时间 lifetimeRange 时间差范围[lifetime-lifetimeRange]~[lifetime+lifetimeRange]为Cell真实的存在时间 emissionLatitude emissionLongitudelatitude是与z轴的夹角，longitude是与xy平面x轴的夹角。 emissionRange 发射角 velocity 初始速度 velocityRange 初始速度范围 xAcceleration x轴加速度 yAcceleration y轴加速度 zAcceleration z轴加速度 scale 尺寸 scaleRange 尺寸范围 scaleSpeed 大小改变速度 spin 旋转速度(与Layer的spin共同作用) spinRange 旋转速度范围 color 颜色 redRange, greenRange, blueRange, alphaRange;颜色、透明度差值范围 redSpeed, greenSpeed, blueSpeed, alphaSpeed;颜色、透明度变化速度 contentsRect，contentsScale 同CALayer minificationFilter,magnificationFilter 缩放以及拉伸时的描绘方式minificationFilter用于缩小，magnificationFilter用于放大，共有三种值选择 kCAFilterLinear 默认值，缩放平滑，但容易产生模糊效果 kCAFilterNearest kCAFilterTrilinear 速度快不会产生模糊，但会降低质量并像素化图像 minificationFilterBias 减小大小因子的等级，当minificationFilter设置为kCAFilterNearest时有效 CAGradientLayer渐变图层，可以用来做颜色的渐变 colors 渐变色CGColorRef对象的数组 locations 每个渐变色的终止坐标count可以与colors的count相同，可动画，数组中的元素需要以递增的方式排列，元素值为[0,1]之间。如@[@(0),@(0.5),@(1)] startPoint 渐变的起始坐标,可动画 endPoint 渐变的终止坐标，可动画黑白渐变色的代码示例： 12345678CAGradientLayer *gradientLayer = [CAGradientLayer layer];gradientLayer.frame = self.containerView.bounds;[self.view.layer addSublayer:gradientLayer];gradientLayer.colors = @[(__bridge id)[UIColor colorWithWhite:0.1 alpha:1.0f].CGColor, (__bridge id)[UIColor colorWithWhite:0.7 alpha:1.0f].CGColor];gradientLayer.locations = @[@0.0, @1];gradientLayer.startPoint = CGPointMake(0.0, 0);gradientLayer.endPoint = CGPointMake(0, 1.0f); CAEAGLLayer如果你打算使用OpenGL来渲染界面，那么可以设置view的layer为CAEAGLLayer. CAReplicatorLayerCAReplicatorLayer会将自己的sublayers进行复制，并进行形变和颜色变化。 instanceCount 需要创建副本的个数，默认为1。 instanceDelay 每份拷贝创建的延时时间，可动画。 instanceTransform 形变第n个layer会依据第n-1个layer做形变。可动画。 instanceColor 颜色，可动画，默认为白色透明。 instanceRedOffset，instanceGreenOffset，instanceBlueOffset，instanceAlphaOffset。色值、透明度的偏移量，依据第n-1个layer的值，可动画。 ⚠️:CAReplicatorLayer实现hitTest的方式只对z轴子层的第一个layer有作用，以后可能会改变。 以下是官方使用示例(OC版)： 123456789101112131415CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];CALayer *redSquare = [CALayer layer];redSquare.backgroundColor = [UIColor whiteColor].CGColor;redSquare.frame = CGRectMake(0, 0, 100, 100);replicatorLayer.instanceCount = 5;replicatorLayer.instanceTransform = CATransform3DMakeTranslation(110, 0, 0);CGFloat offsetStep = -1 / 5.0f;replicatorLayer.instanceBlueOffset = offsetStep;replicatorLayer.instanceGreenOffset = offsetStep;[replicatorLayer addSublayer:redSquare]; CAReplicatorLayer * outerReplicatorLayer = [CAReplicatorLayer layer];[outerReplicatorLayer addSublayer:replicatorLayer];outerReplicatorLayer.instanceCount = 5;outerReplicatorLayer.instanceTransform = CATransform3DMakeTranslation(0, 110, 0);outerReplicatorLayer.instanceRedOffset = offsetStep; 效果如下图所示：觉得不过瘾？试试这篇博客CAReplicatorLayer的酷炫动画 CAScrollLayerCAScrollLayer类似于scrollview，可以仅仅展示一部分内容，可以滚动。对于滚动区域的部分有其子layer的布局决定。可以指定一个原点来指定要显示的内容。 123-(void)scrollToPoint:(CGPoint)p; //滚动到指定点-(void)scrollToRect:(CGRect)r; //滚动到指定区域@property(copy) NSString *scrollMode;// 滚动模式 共有4中，不滚动，横向，纵向，双向。 CAShapeLayerCAShapeLayer可以在其坐标空间内绘制出立体贝塞尔曲线。其形状由其本身的contents和其第一个子layer混合而成。图形绘制时是默认抗锯齿的，然而一些特定的图像操作如CoreImage的滤镜会使局部区域光栅化。 path; 路径定义了渲染的形状。即便图形超出了layer的bounds，仍然不会被截断。除了有mask规则的时候。 fillColor;填充颜色 fillRull;填充规则 strokeColor;划线颜色 strokeStart;划线的起始点,默认为0,范围[0,1] strokeEnd;划线的终止点,默认为1,范围[0,1] lineWidth;线宽 miterLimit;最大斜接长度 lineCape;线帽的样式 lineJoin;折点或衔接点连接样式 lineDashPhase;线型模板的起始位置 lineDashPattern;线性模版，NSNumber的数组，索引从1开始记，奇数位数值表示实线长度，偶数位数值表示空白长度 CATextLayerCATextLayer实现在Layer层渲染及排版文字。它以图层的形式包含了UILabel几乎所有的绘制特性，并且额外提供了一些新的特性。 @property(copy) id string; 需要渲染的文字可以为AttributeString。 @property CFTypeRef font; 字体属性，默认黑体，当string属性为AttributedString时无效。 @property CGFloat fontSize; 字体大小，默认36号 @property CGColorRef foregroundColor; 字体颜色，可动画 @property(getter=isWrapped) BOOL wrapped; 是否需要适应层的边界 @property(copy) NSString *truncationMode; 边界截取方式,共有4种:kCATruncationNone, kCATruncationStart, kCATruncationEnd, kCATruncationMiddle。 @property(copy) NSString *alignmentMode; 行对齐方式,共5种. @property BOOL allowsFontSubpixelQuantization; 是否允许context在渲染文字时开启量化 使用示例： 12345678910111213textLayer.frame = self.labelView.bounds;[self.labelView.layer addSublayer:textLayer];textLayer.foregroundColor = [UIColor blackColor].CGColor;textLayer.alignmentMode = kCAAlignmentJustified;textLayer.wrapped = YES;UIFont *font = [UIFont systemFontOfSize:15];CFStringRef fontName = (__bridge CFStringRef)font.fontName;CGFontRef fontRef = CGFontCreateWithFontName(fontName);textLayer.font = fontRef;textLayer.fontSize = font.pointSize;CGFontRelease(fontRef);NSString *text = @"This is an example for CATextLayer";textLayer.string = text; CATextLayer一般与Core Text配合使用效果更佳，如果你想了解更多关于CATextLayer的使用，可以参考YYText框架。 CATiledLayerCATiledLayer可以异步地提供层的部分片内容。当需要绘制的内容过大或者过于耗时，会阻塞住主线程，这时候就需要使用CATiledLayer来解决。需要注意的是不可以直接操作CATiledLayer的contents，而是需要设置其代理，在- drawRect方法中绘制，否则CATiledLayer只会成为一个普通的Layer了。 (CFTimeInterval) fadeDuration; 入场方式默认为淡入淡出的动画，该属性可以设置淡入淡出的时间，默认为0.25s @property size_t levelsOfDetail; 图层维护的LOD数目(细节量)，默认值为1，每进一级会对前一级分辨率的一半进行缓存，图层的levelsOfDetail最大值，也就是最底层细节，对应至少一个像素点。 @property size_t levelsOfDetailBias; 指的是该图层缓存的放大LOD数目，默认为0，即不会额外缓存放大层次，每进一级会对前一级两倍分辨率进行缓存。 CATileLayer的示例可以参考文尾给出的更多参考链接。 CATransformLayer关于CATransformLayer的使用这里不做过多介绍了，在实际使用中，3D图形图像的处理感觉还是OpenGL来的方便。 参考文章以及延伸阅读 Core Animation Programming Guide 官方文档 晖少的博客 大牛写的博客 raywenderlich上的博文 列举了10个例子]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac常用命令集锦]]></title>
    <url>%2F2016%2F12%2F13%2FiOS-Mac%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[引言本文将简要介绍一些Linux下的常用命令以及一些mac下常用的命令行工具 find命令用于快速查找搜索文件并可以对搜索到的文件进行进一步操作 用文件名查找文件find &lt;filePath&gt; -name &quot;&lt;FileName&gt;&quot; 忽略大小写find &lt;filePath&gt; -iname &quot;&lt;FileName&gt;http://musyuuseiclub.com/tag/2037/page/3/&quot;https://www.pornhub.com/view_video.php?viewkey=ph57af8ec7972c3 搜索文件时指定搜索搜索目录层级深度find &lt;filePath&gt; -maxdepth &lt;maxdepth&gt; -mindepth &lt;mindepth&gt; -name &lt;FileName&gt; 搜索文件并对文件执行指定操作find &lt;filePath&gt; -name &lt;FileName&gt; -exec &lt;handler&gt; {} \;//注意{}和;之间的空格例:find . -name &quot;*.m&quot; -exec ls {} \; 搜索并查看当前目录下的.m文件 搜索指定类型的文件find &lt;path&gt; -type &lt;fileType&gt;(d:目录,l:链接文件,f:普通文件,b:块设备文件,p:管道文件) -print 将匹配的文件打印到标准输出 与xargs联合使用解决因参数列表过长的问题例:find ./ -name &quot;*.m&quot; |xargs echo 查找所有.m文件并打印路径 grep命令强大的文本搜索工具，可以使用正则匹配满足条件的文本并按照指定格式输出 显示所有匹配搜索内容的行grep &#39;&lt;content&gt;&#39; &lt;FileName1&gt; &lt;FileName2&gt;.... 正则匹配内容grep &#39;[a-z]+&#39; &lt;FileName&gt;匹配所有以字母开头的行 只列出匹配到内容的文件名grep -l &#39;&lt;content&gt;&#39;关于如何使用正则表达式，可以参考这篇文章: 正则表达式30分钟入门 cURL命令cURL是一个利用URL语法进行文件传输的命令行工具,支持有多种协议：FTP,FTPS,HTTP,HTTPS,POP3,IMAP,RTSP等。官方网址 下载单个文件,默认将输出打印到标准输出流中curl http://www.netscape.com/ 保存到指定文件中.curl -o &lt;fileName&gt; http://www.netscape.com/ 使用URL中默认的文件名保存到本地，如果远程文件也没有名字，将会失败。curl -O http://www.netscape.com/index.html 抓去多个文件保存到本地curl -O www.haxx.se/index.html -O curl.haxx.se/download.html 通过ipv6 获取主页信息curl &quot;http://[2001:1890:1112:1::20]/&quot; FTP下载curl ftp://ftp.funet.fi/README //无用户名密码curl ftp://name:passwd@machine.domain:port/full/path/to/file//使用用户名和密码下载ftp文件 ftp文件上传curl -T &lt;fileName&gt; -u user:passwd ftp://ftp.upload.com/myfile HTTP&amp;FTP获取请求头curl -I(--include) http:curl.haxx.se或者curl --dump-header response.txt curl.haxx.se将请求的结果存储在txt文件中.包含repsonse的头信息 POST请求使用cURL命令发送post请求很简单.只需要加入 -d 参数，例如:curl -d &quot;name=value1&amp;phone=value2&quot;默认情况下 -d参数会使用application/x-www-form-urlencoded作为mime-type。-F参数接收 “name=contents”这样的参数，如果内容是一个文件，你可以使用&lt;@filename&gt;作为内容，你也可以指定type=作为头信息内容:curl -F &quot;coolfiles=@fil1.gif;type=image/gif,fil2.txt,fil3.html&quot; http://www.post.com/postit.cgi可以将post的内容分开来写:curl -F &quot;file=@&lt;fileName&gt;&quot; -F &quot;name=reddick&quot; -F &quot;photoDescription=this is a test description&quot; Referrer允许指定一个address到一个实际页面，用来欺骗服务器或者cgicurl -e &lt;referrer&gt; http://www.baidu.com UA(User Agent)curl -A &#39;Mozilla/5.0 (iPhone; CPU iPhone OS 9_1 like Mac OS X) AppleWebKit/601.1.46 (KHTML, like Gecko) Version/9.0 Mobile/13B143 Safari/601.1&#39; https://www.baidu.com//获取手机版百度的html页面 Cookie比如服务器的header中包含”Set-Cookie: sessionid=boo123; path=”/foo”如果一个页面希望在请求时获取cookie中的数据可以使用curl -b &quot;name=name&quot; url来携带cookie信息我们可以先请求一个页面获取cookie等信息，然后将它们保存到本地，再次请求其他页面时携带上一次请求的信息,比如curl --dump-header &lt;fileName&gt; &lt;url&gt;或者curl -c cookie.txt &lt;url&gt;然后从文件中读取cookie访问其他页面curl -b &lt;fileName&gt; &lt;url&gt;-L参数可以跟随重定向其他使用方式请参考官方文档 额外的头信息curl -H &quot;ip:192.168.1.1&quot; www.example.com wget命令wget是Linux上的一个文件下载工具，与cURL提供类似的下载服务，不过支持递归下载。例：wget download_url-c 断点下载-b 后台下载-spider 测试下载链接是否可用 ps命令ps命令用来显示瞬间进程的动态，可以跟grep命令配合使用-a 显示现行终端机下的所有进程-x 显示没有控制终端的进程，同时显示各个命令的具体路径-u uid or username 选择有效的用户id或者是用户名 scp命令scp命令主要用来传输文件，基于ssh，可以从服务器快速下载或上传文件。scp &lt;srcfile&gt; &lt;destfile&gt;可以使用如下参数：-4 强行使用ipv4地址-6 强行使用ipv6地址-v 用来显示进度-C 使用压缩选项-r 递归模式 cat命令cat命令可以快速查看文件内容。cat &lt;filename&gt;//查看文件内容 -n 由 1 开始对所有输出的行数编号-b 和 -n 相似，只不过对于空白行不编号-s 当遇到有连续两行以上的空白行，就代换为一行的空白行 dittoditto命令跟cp命令类似，一样提供复制文件／文件夹的功能，不过ditto在进行复制文件的时候会保持原有文件的属性和权限。个人常用于打包脚本时拷贝ipa资源或者framework中。 genstringsgenstrings命令用来从.C/.m文件中处理字符串的本地化。genstring会检测资源文件中包含的NSLocalizedString(&quot;key&quot;,&quot;comment&quot;)或者CFCopyLocalizedString(&quot;key&quot;,comment)，并将它们的字符串表放入到一个文件名为’Localizable.string’的文件中。 filefile命令用来查看文件类型例如可以使用file命令查看某静态库文件所包含的arch 1234567 #&gt; file hello hello: Mach-O universal binary with 5 architectures: [arm_v7: current ar archive] [arm_v7s] [i386] [x86_64] [arm64]hello (for architecture armv7): current ar archivehello (for architecture armv7s): current ar archivehello (for architecture i386): current ar archivehello (for architecture x86_64): current ar archivehello (for architecture arm64): current ar archive lipolipo命令主要用来处理静态库的arch结构,可以通过lipo命令将多个arch结构整合为一个通用的库文件，也可以从一个指定的库文件中移除某些结构 合并多个arch结构打造通用库lipo -create &lt;file1.a&gt; &lt;file2.a&gt; -output universalfile.a 通过lipo -create命令，指定输入文件与输出文件。 arch文件瘦身lipo universalfile.a -thin armv7 -output armv7file.a 移除指定archlipo universalfile.a -remove armv7 -output file.a arar命令可以用来创建、修改单一arch结构的库，也可以从库中提出单个模块。 查看静态库中的目标文件(.o文件)ar -t &lt;filename&gt; 追加文件到静态库文件尾部ar -qs &lt;filename.a&gt; &lt;filename.o&gt; 提取静态库中的目标文件ar -x &lt;filename.a&gt; &lt;filename.o&gt;]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>terminal</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈AFNetwoking中的内存管理]]></title>
    <url>%2F2016%2F12%2F12%2FiOS-arc-in-AFNetworking%2F</url>
    <content type="text"><![CDATA[AFNetworking作为一款开源iOS网络请求框架，收到了广大iOS Developers的喜爱，它可以轻松的实现各种网络请求，处理上传下载以及网络异常。本文主要探讨AFNetworking中的内存管理问题，不对如何使用AFNetworking做探讨。在AFNetwoking3.0后，AFNetworking基于NSURLSession进行封装而非NSURLConnection，因此最低的支持版本为7.0.在官方的例子中我们可以看到这样的例子： 1234567NSURL *URL = [NSURL URLWithString:@"http://example.com/resources/123.json"];AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];[manager GET:URL.absoluteString parameters:nil progress:nil success:^(NSURLSessionTask *task, id responseObject) &#123; NSLog(@"JSON: %@", responseObject);&#125; failure:^(NSURLSessionTask *operation, NSError *error) &#123;NSLog(@"Error: %@", error);&#125;]; 可以看到主要的网络请求是在AFHTTPSessionManager类中处理的。AFHTTPSessionManager继承自AFURLSessionManager,在AFHTTPSessionManager中会调用[super initWithSessionConfiguration:configuration]方法创建一些必要的类，以下是AFURLSessionManager中的初始化代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546- (instancetype)initWithSessionConfiguration:(NSURLSessionConfiguration *)configuration &#123; self = [super init]; if (!self) &#123; return nil; &#125; if (!configuration) &#123; configuration = [NSURLSessionConfiguration defaultSessionConfiguration]; &#125; self.sessionConfiguration = configuration; self.operationQueue = [[NSOperationQueue alloc] init]; self.operationQueue.maxConcurrentOperationCount = 1; self.session = [NSURLSession sessionWithConfiguration:self.sessionConfiguration delegate:self delegateQueue:self.operationQueue]; self.responseSerializer = [AFJSONResponseSerializer serializer]; self.securityPolicy = [AFSecurityPolicy defaultPolicy]; #if !TARGET_OS_WATCH self.reachabilityManager = [AFNetworkReachabilityManager sharedManager]; #endif self.mutableTaskDelegatesKeyedByTaskIdentifier = [[NSMutableDictionary alloc] init]; self.lock = [[NSLock alloc] init]; self.lock.name = AFURLSessionManagerLockName; [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123; for (NSURLSessionDataTask *task in dataTasks) &#123; [self addDelegateForDataTask:task uploadProgress:nil downloadProgress:nil completionHandler:nil]; &#125; for (NSURLSessionUploadTask *uploadTask in uploadTasks) &#123; [self addDelegateForUploadTask:uploadTask progress:nil completionHandler:nil]; &#125; for (NSURLSessionDownloadTask *downloadTask in downloadTasks) &#123; [self addDelegateForDownloadTask:downloadTask progress:nil destination:nil completionHandler:nil]; &#125; &#125;]; return self; &#125; 在manager创建之初，会创建NSURLSessionConfiguration，NSURLSession，以及线程队列以及线程锁等。manager会为每一个task创建一个AFURLSessionManagerTaskDelegate类，并将delegate存储在自己的mutableTaskDelegatesKeyedByTaskIdentifier字典中，其中task的identifier作为字典的键名。delegate会处理session中的部分回调，delegate使用弱引用持有AFURLSessionManager，在sessiontask完成时会通过session的代理方式将得到的结果返回给AFURLSessionManager类，AFURLSessionManager通过寻找字典中的identifier找到对应的AFURLSessionManagerTaskDelegate，由于delegate中包裹了manager请求时的回调block，网络请求的结果会通过delegate的所持有的代码块返回。然而由于NSURLSession的Delegate是strong类型的，而manager也会强持有自己的session，因此，二者会因为相互持有而得不到释放，该问题可以在instrument 的leak中查看到，两者的相互持有产生了孤岛效应。 在网上看到很多人将AFNetwoking的manager封装成类方法，这种写法是不正确的，因为这样会造成内存泄漏的问题，虽然很小，但是不可否认的是确实出现了内存泄漏，如果在代码块中也持有了大量的内存，会使app的内存无法被释放掉的问题。在AFNetwoking的issue中，作者建议将AFNetwoking封装成单例使用，但是这种方式增加了取消网络请求的难度，需要记住上一次请求的url，然后执行取消操作。 如果你的网络请求会多次调用- manager方法，那么正确的做法是在网络请求完成(请求成功或者失败)后在一个合适的时机manually释放掉manager，AFSessionManager提供了一个手动关闭session的方法： 1234567/** Invalidates the managed session, optionally canceling pending tasks. @param cancelPendingTasks Whether or not to cancel pending tasks. */- (void)invalidateSessionCancelingTasks:(BOOL)cancelPendingTasks; 例如，对于只请求一次的代码，可以这样写： 12345678910111213141516__weak typeof(*&amp;self) wself = self;NSURL *URL = [NSURL URLWithString:@"http://example.com/resources/123.json"]; __block AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];[manager GET:URL.absoluteString parameters:nil progress:nil success:^(NSURLSessionTask *task, id responseObject) &#123; __strong typeof(*&amp;wself) sself = wself; [sself dosomething]; NSLog(@"JSON: %@", responseObject); [manager invalidateSessionCancelingTasks:YES]; manager = nil;&#125; failure:^(NSURLSessionTask *operation, NSError *error) &#123; __strong typeof(*&amp;wself) sself = wself; [sself dosomething]; NSLog(@"Error: %@", error); [manager invalidateSessionCancelingTasks:YES]; manager = nil;&#125;]; 如果一个manager会请求多个url请求，那么可以封装到UIViewController类及其子类中，这样在dealloc中手动的释放掉manager便可以了。 以上便是个人对于AFNetwoking内存管理的总结，如果你有什么更好的建议或者意见.]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS命令行打包app(二)]]></title>
    <url>%2F2016%2F08%2F08%2FiOS-archive-app-with-script-2%2F</url>
    <content type="text"><![CDATA[引之前我们曾介绍过使用xcodebuild打包app，本篇将介绍另外一个命令行打包工具以及静态代码扫描工具。 xctool一个可代替Apple的xcodebuild的打包工具，使用起来更简单，更友好。xctool可以并行运行测试用例，格式化输出测试结果，其打印的结果更可读，方便查找问题。xctool由facebook出品官方地址。可以通过brew的方式安装xctool 1`brew install xctool` 测试1xctool -workspace &lt;YourProject.xcworkspace&gt; -scheme &lt;YourScheme&gt; test 如果需要测试指定的target添加 -only &lt;target&gt;即可如果测试制定的测试类添加 -only &lt;target&gt;:&lt;testClass&gt;即可测试某个类中的某个方法：添加 -only &lt;target&gt;:&lt;testClass&gt;/testSomeMethod运行测试运行所有测试，你可以像如下这样使用： 1xctool -workspace Meeting.xcworkspace -scheme meeting run-tests 编译1xctool -workspace &lt;YourProject.xcworkspace&gt; -scheme &lt;YourScheme&gt; build 如果你使用的project工程： 1xctool -project &lt;YourProject.xcworkspace&gt; -scheme &lt;YourScheme&gt; build 所有的公共选项如-configuration,-sdk,-arch都是可以使用的(除了target，因为使用了scheme)你可以将报告的结果输出到指定的文本中。 .configuration配置文件如果每次打包都要写一堆很长很长的命令，我们会觉得很反感，懂得偷懒的程序员会选择使用脚本打包，xctool为我们提供了一个.xctool-args的隐藏文件来编写打包时所需要参数：官方的例子如下： 1234567[ "-workspace", "YourWorkspace.xcworkspace", "-scheme", "YourScheme", "-configuration", "Debug", "-sdk", "iphonesimulator", "-arch", "i386"] 这种配置类型的文件可以减少每次输入的内容，不过，如果想打包app的话，还是做成脚本比较方便些。以下是个人的一个打包app的脚本文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#!/bin/bash#计时SECONDS=0#假设脚本放置在与项目相同的路径下project_path=$(pwd)#取当前时间字符串添加到文件结尾now=$(date +"%Y_%m_%d_%H_%M_%S")#指定项目的scheme名称scheme="Meeting"#指定要打包的配置名configuration="release"#指定打包所使用的provisioning profile名称provisioning_profile='5c3e24aa-1df1-4ab1-ae0b-36ca921d184d'#指定项目地址workspace_path="$project_path/Meeting.xcworkspace"#指定工程配置文件路径project_infoplist_path=$project_path/Meeting/Info.plist#获取版本号bundleShortVersion=$(/usr/libexec/PlistBuddy -c "print CFBundleShortVersionString" $&#123;project_infoplist_path&#125;)#获取buildbundleVersion=$(/usr/libexec/PlistBuddy -c "print CFBundleVersion" $&#123;project_infoplist_path&#125;)#指定输出路径output_path="/Users/reddick/Desktop/"#指定输出归档文件地址archive_path="$output_path/Meeting_$&#123;bundleVersion&#125;_$&#123;now&#125;.xcarchive"#指定输出ipa地址ipa_path="$output_path/Meeting_$&#123;bundleVersion&#125;_$&#123;now&#125;.ipa"#输出设定的变量值echo "===workspace path: $&#123;workspace_path&#125;==="echo "===archive path: $&#123;archive_path&#125;==="echo "===ipa path: $&#123;ipa_path&#125;==="echo "===profile: $&#123;provisioning_profile&#125;==="echo "==bundleVersion :$&#123;bundleVersion&#125;==="#切换分支至appStore版git checkout appStore#先清空前一次buildxctool clean -workspace $&#123;workspace_path&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configuration&#125;#根据指定的项目、scheme、configuration与输出路径打包出archive文件xctool build -workspace $&#123;workspace_path&#125; -scheme $&#123;scheme&#125; -configuration $&#123;configuration&#125; archive -archivePath $&#123;archive_path&#125;#使用指定的provisioning profile导出ipaxcodebuild -exportArchive -archivePath $&#123;archive_path&#125; -exportPath $&#123;ipa_path&#125; -exportFormat ipa -exportProvisioningProfile "$&#123;provisioning_profile&#125;"#输出总用时echo "===Finished. Total time: $&#123;SECONDS&#125;s===" 参考1.xctool官网 2.xctool 编写脚本]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[App 图形性能优化(一)]]></title>
    <url>%2F2016%2F08%2F03%2FiOS-xing-neng-you-hua%2F</url>
    <content type="text"><![CDATA[转载自WWDC心得：Advanced Graphics and Animations for iOS Apps Advanced Graphics and Animations for iOS Apps(session 419)这篇文章主要是学习完Advanced Graphics and Animations for iOS Apps这个session后的总结和相应细节的延伸和细化。主要内容为图形性能与测试工具这两个章节。 Core Animation Pipeline第一部分主要讲解了Core Animation的工作流程和渲染过程。 CoreAnimation的渲染流程可以用下图来概括: 在GPU的渲染过程中,我们能看到顶点着色器与像素着色器参与到图像的处理。 在objc.io中有一篇文章进一步地阐明了顶点着色器与像素着色器 (GPU 加速下的图像处理) UIBlurEffectView第二部分主要讲解了iOS8新引入的UIBlurEffectView,结合第一部分来阐述UIBlurEffectView是如何工作的,以及它们的性能。 事实上,个人觉得有一点很有趣。就是UIBlurEffectView为了优化图像处理效率,并不是用普通的模糊算法。虽然Session中没提到模糊算法,我在这里简单地介绍一下简单的模糊算法。 最简单模糊的过程即是用中心像素与其周围像素的颜色算术平均值来代表模糊后的颜色值。我们可以在下面两幅图看到中心像素值的变化。 原始图像 中心像素模糊化 那么苹果是怎么做的呢？最有趣的一点是它并不是对原始图像直接模糊,而是先将图像缩放之后再进行模糊。这样的优点就是模糊算法需要处理的像素点就减少了,处理的效率会更快。 看到这里的时候我是笑了的,哈哈,觉得很机智。适当的把思维跳出来,”偷点懒”,有时真的会取得很不错的效果。学习,学习。 其次就是水平模糊与竖直模糊后再合成,添加颜色。 最后需要关注和有趣的一点是:苹果为我们提供了三个UIBlurEffect styles,分别为Extra light, Light, Dark.但是三者的耗费的资源各为不同。 Extra light耗费最多资源, Light其次, Dark最少。 图形性能关于图形性能在之前关注的不够多,主要是用前人总结好的比较教条式的优化方式。这次借这个Session的学习,继续往外扩展阅读学习,好好梳理和学习遗漏点,底层细节,原理与性能优化的工具。 关于CALayer的shouldRasterize（光栅化）开启shouldRasterize后,CALayer会被光栅化为bitmap,layer的阴影等效果也会被保存到bitmap中。当我们开启光栅化后,需要注意三点问题。 如果我们更新已光栅化的layer,会造成大量的offscreen渲染。因此CALayer的光栅化选项的开启与否需要我们仔细衡量使用场景。只能用在图像内容不变的前提下的： 用于避免静态内容的复杂特效的重绘,例如前面讲到的UIBlurEffect 用于避免多个View嵌套的复杂View的重绘。而对于经常变动的内容,这个时候不要开启,否则会造成性能的浪费。 例如我们日程经常打交道的TableViewCell,因为TableViewCell的重绘是很频繁的（因为Cell的复用）,如果Cell的内容不断变化,则Cell需要不断重绘,如果此时设置了cell.layer可光栅化。则会造成大量的offscreen渲染,降低图形性能。 当然,合理利用的话,是能够得到不少性能的提高的,因为使用shouldRasterize后layer会缓存为Bitmap位图,对一些添加了shawdow等效果的耗费资源较多的静态内容进行缓存,能够得到性能的提升。 不要过度使用,系统限制了缓存的大小为2.5X Screen Size.如果过度使用,超出缓存之后,同样会造成大量的offscreen渲染。 被光栅化的图片如果超过100ms没有被使用,则会被移除.因此我们应该只对连续不断使用的图片进行缓存。对于不常使用的图片缓存是没有意义,且耗费资源的。 关于offscreen rendering注意到上面提到的offscreen rendering。我们需要注意shouldRasterize的地方就是会造成offscreen rendering的地方,那么为什么需要避免呢？ WWDC 2011 Understanding UIKit Rendering指出一般导致图形性能的问题大部分都出在了offscreen rendering,因此如果我们发现列表滚动不流畅,动画卡顿等问题,就可以想想和找出我们哪部分代码导致了大量的offscreen 渲染。 首先,什么是offscreen rendering? offscreen rendring指的是在图像在绘制到当前屏幕前,需要先进行一次渲染,之后才绘制到当前屏幕。 那么为什么offscreen渲染会耗费大量资源呢？ 原因是显卡需要另外alloc一块内存来进行渲染,渲染完毕后在绘制到当前屏幕,而且对于显卡来说,onscreen到offscreen的上下文环境切换是非常昂贵的(涉及到OpenGL的pipelines和barrier等), 备注： 这里提到的offscreen rendering主要讲的是通过GPU执行的offscreen,事实上还有的offscreen rendering是通过CPU来执行的（例如使用Core Graphics, drawRect）。其它类似cornerRadios, masks, shadows等触发的offscreen是基于GPU的。 许多人有误区,认为offscreen rendering就是software rendering,只是纯粹地靠CPU运算。实际上并不是的,offscreen rendering是个比较复杂,涉及许多方面的内容。 我们在开发应用,提高性能通常要注意的是避免offscreen rendering。不需要纠结和拘泥于它的定义. 有兴趣可以继续阅读Andy Matuschak, 前UIKit team成员关于offscreen rendering的评论总之,我们通常需要避免大量的offscreen rendering. 会造成 offscreen rendering的原因有： Any layer with a mask (layer.mask) Any layer with layer.masksToBounds being true Any layer with layer.allowsGroupOpacity set to YES and layer.opacity is less than 1.0 Any layer with a drop shadow (layer.shadow*). Any layer with layer.shouldRasterize being true Any layer with layer.cornerRadius, layer.edgeAntialiasingMask, layer.allowsEdgeAntialiasing 因此,对于一些需要优化图像性能的场景,我们可以检查我们是否触发了offscreen rendering。 并用更高效的实现手段来替换。 例如: 阴影绘制: 使用ShadowPath来替代shadowOffset等属性的设置。 一个如图的简单tableView: 两种不同方式来绘制阴影： 不使用shadowPath 12345CALayer *imageViewLayer = cell.imageView.layer;imageViewLayer.shadowColor = [UIColor blackColor].CGColor;imageViewLayer.shadowOpacity = 1.0;imageViewLayer.shadowRadius = 2.0;imageViewLayer.shadowOffset = CGSizeMake(1.0, 1.0); 使用shadowPath 1imageViewLayer.shadowPath = CGPathCreateWithRect(imageRect, NULL); 我们可以在下图看到两种方式巨大的性能差别。 个人推测的shadowPath高效的原因是使用shadowPath避免了offscreen渲染,因为仅需要直接绘制路径即可,不需要提前读取图像去渲染。 裁剪图片为圆: 使用CornerRadius： 123CALayer *imageViewLayer = cell.imageView.layer;imageViewLayer.cornerRadius = imageHeight / 2.0;imageViewLayer.masksToBounds = YES; 利用一张中间为透明圆形的图片来进行遮盖,虽然会引起blending,但性能仍然高于offerScreen。 根据苹果测试,第二种方式比第一种方式更高效. 关于blending 前面提到了用透明圆形的图片来进行遮盖,会引起blending。blending也会耗费性能。：） 笑。如果阅读这篇文章的读者看到这里,是不是觉得已经无眼看下去了。哈哈,我自己学习总结到这里也是感受到了长路慢慢,但是我们仍然还是要不断上下求索的。 ：） 好了 接下来让我们来认识一下Blending. 什么是Blending？在iOS的图形处理中,blending主要指的是混合像素颜色的计算。最直观的例子就是,我们把两个图层叠加在一起,如果第一个图层的透明的,则最终像素的颜色计算需要将第二个图层也考虑进来。这一过程即为Blending。 会导致blending的原因: layer(UIView)的Alpha &lt; 1 UIImgaeView的image含有Alpha channel(即使UIImageView的alpha是1,但只要image含透明通道,则仍会导致Blending) 为什么Blending会导致性能的损失？ 原因是很直观的,如果一个图层是不透明的,则系统直接显示该图层的颜色即可。而如果图层是透明的,则会引入更多的计算,因为需要把下面的图层也包括进来,进行混合后颜色的计算。 在了解完Blending之后,我们就知道为什么很多优化准则都需要我们尽量使用不透明图层了。接下来就是在开发中留意和进行优化了。 测试工具在出现图像性能问题,滑动,动画不够流畅之后,我们首先要做的就是定位出问题的所在。而这个过程并不是只靠经验和穷举法探索,我们应该用有脉络,有顺序的科学的手段进行探索。 首先,我们要有一个定位问题的模式。我们可以按照这样的顺序来逐步定位,发现问题。 定位帧率,为了给用户流畅的感受,我们需要保持帧率在60帧左右。当遇到问题后,我们首先检查一下帧率是否保持在60帧。 定位瓶颈,究竟是CPU还是GPU。我们希望占用率越少越好,一是为了流畅性,二也节省了电力。 检查有没有做无必要的CPU渲染,例如有些地方我们重写了drawRect,而其实是我们不需要也不应该的。我们希望GPU负责更多的工作。 检查有没有过多的offscreen渲染,这会耗费GPU的资源,像前面已经分析的到的。offscreen 渲染会导致GPU需要不断地onScreen和offscreen进行上下文切换。我们希望有更少的offscreen渲染。 检查我们有无过多的Blending,GPU渲染一个不透明的图层更省资源。 检查图片的格式是否为常用格式,大小是否正常。如果一个图片格式不被GPU所支持,则只能通过CPU来渲染。一般我们在iOS开发中都应该用PNG格式,之前阅读过的一些资料也有指出苹果特意为PNG格式做了渲染和压缩算法上的优化。 检查是否有耗费资源多的View或效果。我们需要合理有节制的使用。像之前提到的UIBlurEffect就是一个例子。 最后,我们需要检查在我们View层级中是否有不正确的地方。例如有时我们不断的添加或移除View,有时就会在不经意间导致bug的发生。像我之前就遇到过不断添加View的一个低级错误。我们希望在View层级中只包含了我们想要的东西。 OK,当我们有了一套模式之后,就可以使用苹果为我们提供的优秀测试工具来进行测试了。 对于图形性能问题的地位。一般我们有下列测试工具： Instruments里的： Core Animation instrument OpenGL ES Driver instrument模拟器中的: Color debug options View debugging 还有Xcode的： View debugging 然后我们来根据上面定位问题的模式来选择相应测试工具: 定位帧率 定位瓶颈 检查有无必要的CPU渲染 以上三点我们可以使用CoreAnimation instrument来测试。 CoreAnimation instrument包含了两个模块。第一幅图展示了检测帧率。第二幅图展示了检测CPU调用。我们能够通过它们来进行上述三个问题的检测。注意到第二幅图左下角,那是CPU 的call stack.我们就是在这里检测我们有没有做无必要的drawRect,有没有在主线程做太多事务导致阻塞了UI更新。 关于GPU的瓶颈问题,我们可以通过OpenGL ES Driver instrument来获得更详细的信息。例如GPU的占用率。可以看到下图左下角有显示Device utilization。 检查有无过多offscreen渲染 检查有无过多Blending 检查有无不正确图片格式,图片是否被放缩,像素是否对齐。 检查有无使用复杂的图形效果。 以上这四点我们同样使用CoreAnimation instrument来测试。 我们通过勾选这些选项来触发Color Debug。下面逐个对这些选项进行分析。 Color Blended layers如图,勾选这个选项后,blended layer 就会被显示为红色,而不透明的layer则是绿色。我们希望越少红色区域越好。 Color Hits Green and Misses Red这个选项主要是检测我们有无滥用或正确使用layer的shouldRasterize属性.成功被缓存的layer会标注为绿色,没有成功缓存的会标注为红色。 在测试的过程中,第一次加载时,开启光栅化的layer会显示为红色,这是很正常的,因为还没有缓存成功。但是如果在接下来的测试,例如我们来回滚动TableView时,我们仍然发现有许多红色区域,那就需要谨慎对待了。因为像我们前面讨论过的,这会引起offscreen rendering。检查一下是否有滥用该属性,因为系统规定的缓存大小是屏幕大小的2.5倍,如果使用过度,超出了缓存大小,会引起offscreen rendering。检测layer是否内容不断更新,内容的更新会导致缓存失效和大量的offscreen rendering. Color copied images这个选项主要检查我们有无使用不正确图片格式,若是GPU不支持的色彩格式的图片则会标记为青色,则只能由CPU来进行处理。我们不希望在滚动视图的时候,CPU实时来进行处理,因为有可能会阻塞主线程。 Color misaligned images这个选项检查了图片是否被放缩,像素是否对齐。被放缩的图片会被标记为黄色,像素不对齐则会标注为紫色。 Color offscreen-rendered yellow这个选项将需要offscreen渲染的的layer标记为黄色。 以上图为例子,NavigationBar和ToolBar被标记为黄色。因为它们需要模糊背后的内容,这需要offscreen渲染。但是这是我们需要的。而图片也是被标记为黄色,那是因为阴影的缘故。我前面已经提到了这一点,如果此时我们用shadowPath来替代的话,就能够避免offscreen渲染带来的巨大开销。 Color OpenGL fast path blue这个选项勾选后,由OpenGL compositor进行绘制的图层会标记为蓝色。这是一个好的结果。 Flash updated regions会标记屏幕上被快速更新的部分为黄色,我们希望只是更新的部分被标记完黄色。好啦,终于完整介绍完这些调试选项了,我们总结一下。 我们需要重点注意的是: Color Blended layers Color Hits Green and Misses Red Color offscreen-rendered yellow这三个选项。因为这三个部分对性能的影响最大。 总结关于图形性能还有许多细节和底层可以深入,不过经过这一次总结与学习,基本把握了iOS图形性能的优化细节和工具。希望也能够对你有一点帮助。 在学习和探索的过程中,个人感受最深的是两点。 一类事情背后都会有一定的原理,弄清楚了原理就能更好地把握这一类事务。 在之前的iOS开发中,对图形界面的优化主要处于用前人总结的教条来优化。而经过这次学习之后,明白这些教条背后的原理,像最影响性能的offscreen rendering和blending。更能有针对性的优化和分析。 检测问题不应该是盲目的,有一定的模式和工具会更清晰。 像对图形性能的问题定位,我们不应该一上来就开始找问题,看代码。而是应该逐步定位。而是像前面总结的一样,定位帧率,摸清瓶颈,逐个问题击破。再配合合适的工具进行测试和定位,一定能够提升效率和准确]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用AVFoundation框架开发自定义相机]]></title>
    <url>%2F2016%2F08%2F01%2FiOS-custom-camera-with-AVFoundation%2F</url>
    <content type="text"><![CDATA[几个概念对焦将离相机一定范围内物体渲染清晰，太近太远会模糊这种情况叫做失焦。AVFoundation中提供了自动对焦，手动对焦等不同的模式供选择。 ISO感光度ISO也叫胶卷速度，衡量图像传感器对光的敏感程度。亮的时候需要的ISO就越小，暗的时候相反ISO就高噪点会多。 闪光灯/手电筒这个就不细解释了。 Session会话，在AVFoundation中开启一个AVCaptureSession会话，用来连接输入和输出设备。 Input &amp;&amp; Output输入和输出设备，需要将有效的输入输出设备添加到会话中。 相关类 AVCaptureDevice：控制硬件特性，比如镜头位置，曝光，闪光灯,焦距等 AVCaptureDeviceInput：设备数据 AVCaptureOutput：抽象类包括了三种静态图片捕捉类 AVCaptureStillImageOutput：用于捕捉静态图片 AVCaptureMetadataOutput：启用检测人脸和二维码 AVCaptureVideoOutput：实时预览图提供原始帧 AVCaptureSession：管理输入输出之间数据流，以及在出现问题时生成运行时错误。 AVCaptureVideoPreviewLayer：CALayer的子类，用于自动显示相机产生的实时图像。 自定义相机授权在iOS7之后，在使用相机前需要判断相机是否拥有使用权，相机的使用权声明在AVCaptureDevice (AVCaptureDeviceAuthorization)分类中。示例： 12345678AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; switch (status) &#123; case AVAuthorizationStatusNotDetermined: [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:nil]; break; default: break; &#125; 建立Session123456_camSession = [[AVCaptureSession alloc]init];[_camSession setSessionPreset:AVCaptureSessionPresetInputPriority];//在开启Session之前，需要添加Input和Output设备。//[_camSession startRunning]; 添加输入设备1234567891011//默认后置摄像头 _currentDevice = [[self class] cameraAtPosition:self.isPreCam?AVCaptureDevicePositionFront:AVCaptureDevicePositionBack]; NSError *error = nil; _input = [[AVCaptureDeviceInput alloc]initWithDevice:self.currentDevice error:&amp;error]; if (error) &#123; NSLog(@"may be device is already used or it is not available"); &#125; if ([self.camSession canAddInput:self.input]) &#123; [self.camSession addInput:self.input]; &#125; 获取摄像头的方法： 123456789+ (AVCaptureDevice *)cameraAtPosition:(AVCaptureDevicePosition)position&#123; NSArray *cameras = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; for (AVCaptureDevice *device in cameras)&#123; if (device.position == position)&#123; return device; &#125; &#125; return [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];&#125; 添加输出设备(采集静态图片)1234_imgOutput = [[AVCaptureStillImageOutput alloc]init]; _imgOutput.outputSettings = @&#123;AVVideoCodecKey:AVVideoCodecJPEG&#125;;if ([self.camSession canAddOutput:self.imgOutput]) &#123; [self.camSession addOutput:self.imgOutput]; } 开始捕获数据将Session放到预览中（AVCaptureVideoPreviewLayer） 12self.avPreview = [[AVCaptureVideoPreviewLayer alloc]initWithSession:self.camSession]; self.avPreview.videoGravity = AVLayerVideoGravityResizeAspectFill; 捕获数据时，需要将PreviewLayer添加到view的layer上展示。 1234567891011121314151617181920212223242526- (BOOL)startCapture:(NSError __autoreleasing **)error &#123; NSError *err = nil; AVAuthorizationStatus status = [AVCaptureDevice authorizationStatusForMediaType:AVMediaTypeVideo]; switch (status) &#123; //TODO errorMsg case AVAuthorizationStatusDenied: &#123; err = [NSError errorWithDomain:@"com.error.auth" code:1 userInfo:nil]; if (error) &#123; *error = err; &#125; return NO; &#125; break; default: break; &#125; NSAssert(self.captureView, @"you should assoiate a caputrureView to show output"); if (![self.camSession isRunning]) &#123; self.avPreview.frame = self.captureView.bounds; [self.captureView.layer addSublayer:self.avPreview]; [self.camSession startRunning]; &#125;else &#123; NSLog(@"session has already running"); &#125; return YES;&#125; 开启闪光灯在操作Session和AVDevice的设置时，如果Session已经开始运行了，那么需要锁住当前设备配置，然后开始变更，最后再关闭设置锁 123456789101112131415161718- (BOOL)changeFlashMode:(AVCaptureFlashMode)mode &#123; if ([self.currentDevice isFlashModeSupported:mode]) &#123; if ([self.camSession isRunning]) &#123; NSError *error = nil; BOOL lock = [self.currentDevice lockForConfiguration:&amp;error]; if (!lock) &#123; return NO; &#125; [self.currentDevice setFlashMode:mode]; [self.currentDevice unlockForConfiguration]; return YES; &#125;else [self.currentDevice setFlashMode:mode]; return YES; &#125;else &#123; return NO; &#125;&#125; 切换摄像头1234567891011121314151617181920212223- (void)changeCameraPosition &#123; self.isPreCam = !self.isPreCam; BOOL alreadyRun = NO; if ([_camSession isRunning]) &#123; alreadyRun = YES; [_camSession stopRunning]; &#125; [self.camSession beginConfiguration]; [self.camSession removeInput:self.input]; self.currentDevice = [[self class] cameraAtPosition:self.isPreCam?AVCaptureDevicePositionFront:AVCaptureDevicePositionBack]; self.input = [AVCaptureDeviceInput deviceInputWithDevice:self.currentDevice error:nil]; [self.camSession addInput:self.input]; self.videoConnection = [self.imgOutput connectionWithMediaType:AVMediaTypeVideo]; [self.camSession commitConfiguration]; [self changeVideoCropFactor:1.0f]; if (alreadyRun) &#123; //TODO 增加翻转动画 [_camSession startRunning]; &#125;&#125; 触摸改变对焦需要在View上添加对焦手势，action方法如下： 1234567891011- (void)changeFocusPoint:(UITapGestureRecognizer *)tap &#123; if (!self.currentDevice.isFocusPointOfInterestSupported) &#123; return; &#125; CGPoint point = [tap locationInView:self.captureView]; CGPoint interestPoint = [self.avPreview pointForCaptureDevicePointOfInterest:point]; [self.currentDevice lockForConfiguration:nil]; [self.currentDevice setFocusPointOfInterest:interestPoint]; [self.currentDevice setFocusMode:AVCaptureFocusModeContinuousAutoFocus]; [self.currentDevice unlockForConfiguration];&#125; 捏合缩放需要在View上添加UIPinchGestureRecognizer手势，action方法如下： 1234567891011121314151617181920212223242526272829- (void)scaleChanged:(UIPinchGestureRecognizer *)pin &#123; CGFloat maxScale = [self.videoConnection videoMaxScaleAndCropFactor]; CGFloat currentScale = _lastScale; switch (pin.state) &#123; case UIGestureRecognizerStateBegan: _lastScale = [self.videoConnection videoScaleAndCropFactor]; break; case UIGestureRecognizerStateChanged: case UIGestureRecognizerStateEnded: &#123; currentScale *= pin.scale; currentScale = MIN(maxScale, currentScale); currentScale = MAX(currentScale, 1.0f); [self changeVideoCropFactor:currentScale]; &#125; break; default: break; &#125;&#125;- (void)changeVideoCropFactor:(CGFloat)scale &#123; [CATransaction begin]; [CATransaction setAnimationDuration:.01]; [self.avPreview setAffineTransform:CGAffineTransformMakeScale(scale,scale)]; [CATransaction commit]; self.videoConnection.videoScaleAndCropFactor = scale;&#125; 照相这里仅采用比较简单的处理，并未增加任何滤镜。 12345678910111213141516- (void)takePhoto &#123; if (self.videoConnection) &#123; [self.imgOutput captureStillImageAsynchronouslyFromConnection:self.videoConnection completionHandler:^(CMSampleBufferRef imageDataSampleBuffer, NSError *error) &#123; if (!error) &#123; NSData *imgData = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer]; if (self.cameraDelegate &amp;&amp; [self.cameraDelegate respondsToSelector:@selector(camera:didCaptureImage:)]) &#123; [self.cameraDelegate camera:self didCaptureImage:[UIImage imageWithData:imgData]]; &#125; &#125;else &#123; NSLog(@"capture image failed"); &#125; &#125;]; &#125;else &#123; NSLog(@"can not get a avilible videoConnection"); &#125;&#125; 停止会话12345- (void)stopCapture &#123; if ([_camSession isRunning]) &#123; [_camSession stopRunning]; &#125;&#125; 结语以上便简单的自定义了一个相机，可以单独封装一个Camera类，增加一些事件和方法，供外界调用。 参考 objc.io camera-and-photos 自定义相机]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解XMPP中的节]]></title>
    <url>%2F2016%2F07%2F31%2FiOS-build-your-chart-app-with-xmpp-framework-7%2F</url>
    <content type="text"><![CDATA[节选自XMPP基本概念–节 理解XMPP中的节XMPP中可分为三种节:IQ,Presence,Message。 节的共同属性from表示节（stanza）的发送方，在发送节（stanza）时，一般来说不推荐设定，服务器会自动设定正确的值，如果你设定了不正确的值，服务器将会拒收你的节（stanza）信息。 如果在客户端到服务器端的通信中接收的节（stanza）中没有本属性，会被默认解释为信息是由服务器发出的。 如果在服务器到服务器的通信中接收的节（stanza）中没有本属性，则会被解释为一个error. to表示节（stanza）的接收方。如果在客户端到服务器端的通信中没有设置本属性，服务器会默认解释为信息是发给自己的。 type指定节（stanza）的类型.每种节（stanza）都会有几种可能的设定值。所有的节（stanza）都会有一个error类型，，表明这个节（stanza）是一个error回应，对这样的节（stanza）信息不需要进行回应。 id表示一个特定的请求。在IQ节中，这个属性是必须要指定的，但是在其他两个节（stanza）中是一个可选属性。 Presense节Presence节（stanza）用来控制和表示实体的在线状态，可以展示从离线到在线甚至于离开，不能打扰等复杂状态，另外，还能被用来建立和结束在线状态的订阅。 Message节正如名字一样，message节（stanza）用于用户之间传递消息。这消息可以是单纯的聊天信息，也可以某种格式化的信息。 message节点信息是传递之后就被忘记的。当消息被送出之后，发送者是不管这个消息是 否已经送出或者什么时候被接收到。通过扩展协议，可以改变这样一种状况。 IQ节IQ（stanza）主要是用于Info/Query模式的消息请求，他和Http协议比较相似。可以发出get以及set请求，就如同http中的GET以及POST. iq节点需要有回应，有get,set两种请求以及result,error两种回应。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>XMPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于XMPP实现简单的聊天功能(五)]]></title>
    <url>%2F2016%2F07%2F29%2FiOS-build-your-chart-app-with-xmpp-framework-6%2F</url>
    <content type="text"><![CDATA[概述本文主要介绍基于XMPP的多人聊天的实现。XMPP在其XEP-0045扩展中定义了一个用于多用户文本会议（群聊）的协议，类似于聊天室、QQ群等。 XMPP中的一些概念 affiliation岗位:XMPP定义的岗位有：所有者（owner）、管理者（admin）、成员（member）、排斥者（outcast）。 role:表达了用户和房间的临时联系，它只存在与一次访问期间。XMPP定义的角色有：主持人（moderator）、与会者（paticipant）、游客（visitor） 发现群组XMPP提供了一个用于发现当前多人聊天Room的方式，客户端发起一个IQ节请求，其格式类似如下： Entity Queries Chat Service for Rooms123456&lt;iq from='hag66@shakespeare.lit/pda' id='zb8q41f4' to='chat.shakespeare.lit' type='get'&gt; &lt;query xmlns='http://jabber.org/protocol/disco#items'/&gt;&lt;/iq&gt; XMPPFramework提供了一个发现已存在房间的方法用于发现已有房间 1- (BOOL)discoverRoomsForServiceNamed:(NSString *)serviceName; 通过代理回调方法，我们可以获取到当前已存在的房间。 12345678910111213141516171819202122232425/** * 发现了房间 * * @param sender * @param services XML &lt;item jid='chat.shakespeare.lit' name='Chatroom Service'/&gt; */- (void)xmppMUC:(XMPPMUC *)sender didDiscoverRooms:(NSArray *)rooms forServiceNamed:(NSString *)serviceName &#123; if ([serviceName isEqualToString:iChatGroupServiceName]) &#123; NSMutableArray *newRooms = [[NSMutableArray alloc]init]; for (NSXMLElement *room in rooms) &#123; NSString *jidStr = [[room attributeForName:@"jid"] stringValue]; XMPPJID *jid = [XMPPJID jidWithString:jidStr]; NSString *name = [[room attributeForName:@"name"] stringValue]; ICHGroupBuddy *groupBuddy = [[ICHGroupBuddy alloc]init]; groupBuddy.groupId = jid.user; groupBuddy.groupName = name; [newRooms addObject:groupBuddy]; &#125; [_muldelegate didFetchGroups:[newRooms copy]]; &#125;&#125; 我们可以在XMPPMUCDelegate的回调中处理邀请事件，拒绝加入事件等。 接收到群组邀请123456789101112131415161718/** * 接收到邀请 * * @param sender * @param roomJID * @param message */- (void)xmppMUC:(XMPPMUC *)sender roomJID:(XMPPJID *)roomJID didReceiveInvitation:(XMPPMessage *)message &#123; DDLogVerbose(@"%s",__func__); XMPPRoom *room = [[XMPPRoom alloc]initWithRoomStorage:self.groupStore jid:roomJID]; [room addDelegate:self delegateQueue:dispatch_get_main_queue()]; [room activate:self.chatStream]; [room joinRoomUsingNickname:self.chatStream.myJID.user history:nil]; [_muldelegate didReciveGroupInvitation:roomJID.user];&#125; 申请群组被拒绝12345678910/** * 申请被拒绝 * * @param sender * @param roomJID * @param message */- (void)xmppMUC:(XMPPMUC *)sender roomJID:(XMPPJID *)roomJID didReceiveInvitationDecline:(XMPPMessage *)message &#123; [_muldelegate rejectedByGroup:roomJID.user];&#125; 房间XMPPFramework使用XMPPRoom来代表一个房间，创建时需要提供一个CoreDataStorage,然后将其添加到Stream中。XMPP的room跟QQ的群还是有些区别的，当我们关闭了Stream后，便退出了群，想再次获取到群组中的消息时就需要再一次加入到群组中，所以如果想记录User加入了那些群组，还需要额外的做XMPP的扩展。 加入房间12345678910111213141516171819202122232425/** * Sends a presence element to the join room. * * If the room already exists, then the xmppRoomDidJoin: delegate method will be invoked upon * notifiaction from the server that we successfully joined the room. * * If the room did not already exist, and the authenticated user is allowed to create the room, * then the server will automatically create the room, * and the xmppRoomDidCreate: delegate method will be invoked (followed by xmppRoomDidJoin:). * You'll then need to configure the room before others can join. * * @param desiredNickname (required) * The nickname to use within the room. * If the room is anonymous, this is the only identifier other occupants of the room will see. * * @param history (optional) * A history element specifying how much discussion history to request from the server. * E.g. &lt;history maxstanzas='100'/&gt; * For more information, please see XEP-0045, Section 7.1.16 - Managing Discussion History. * You may also want to query your storage module to see how old the most recent stored message for this room is. * * @see fetchConfigurationForm * @see configureRoomUsingOptions:**/- (void)joinRoomUsingNickname:(NSString *)desiredNickname history:(NSXMLElement *)history; 如果Room不存在，那么就会创建一个新的房间，如果存在，会加入到房间中。nickname可以指定为自己JID。 关于XMPPRoom的所有事件都可以通过XMPPRoomDelegate中的回调方法获得： 1234567891011121314151617181920//创建房间成功- (void)xmppRoomDidCreate:(XMPPRoom *)sender;//获取到了Room的配置信息，需要事先发起 [ROOM fetchConfigurationForm]方法- (void)xmppRoom:(XMPPRoom *)sender didFetchConfigurationForm:(NSXMLElement *)configForm;//加入房间- (void)xmppRoomDidJoin:(XMPPRoom *)sender;//离开房间- (void)xmppRoomDidLeave:(XMPPRoom *)sender;//房间被销毁- (void)xmppRoomDidDestroy:(XMPPRoom *)sender;//获取到了房间中的消息- (void)xmppRoom:(XMPPRoom *)sender didReceiveMessage:(XMPPMessage *)message fromOccupant:(XMPPJID *)occupantJID;//获取到了成员列表- (void)xmppRoom:(XMPPRoom *)sender didFetchMembersList:(NSArray *)items; XMPPRoom并没有做持久化相关的方法，所以加入了哪些房间以及离开了哪些房间需要我们自己去做处理。同时，如果在离线时被踢出了房间是无法离开房间的消息的，因为离开房间发送的是一个Presence节点，如果不在线，是收不到该请求的。如果仅仅是创建一个在线聊天室，那么XMPPFramework提供的方法已经足够使用了，UI层的展示方法与单聊的类似，Message的from需要处理下消息是谁发来的，同时做下头像的处理。 TODO 管理者如何邀请成员。 配置已经存在的房间的属性。 获取房间的属性信息。 参考资料 XEP-0045 wiki XEP-0045中文]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>XMPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XMPP服务器优化]]></title>
    <url>%2F2016%2F07%2F27%2FiOS-build-your-chart-app-with-xmpp-framework-5%2F</url>
    <content type="text"><![CDATA[文章转载自优化openfire服务器提升xmpp 效率的15个方法 禁用原生xmpp搜索，使组织架构、人员数据本地化保存，并使客户端数据同步服务器，降低原生xmpp搜索的iq消耗，因为搜索是im应用的频繁操作； 禁用roster花名册、禁用presence包通讯，企业im中的好友概念非常没必要，使用发布订阅的方式替代状态服务，见http://www.cnblogs.com/starcrm/p/5029231.html。并重写状态更新的广播：PresenceUpdateHandler中的broadcastUpdate方法。 如果想保留好友机制，建议把好友信息本地化保存，不要每次都从服务器拉取了。 禁用MUC的Password-Verification特性，它将造成客户端开窗前的大量iq交互。改造Roles、 Affiliations、Disco 、Querying等交互，但muc消息通讯机制可以沿用。 头像分离出vcard，在有头像情况下实在是太占流量了，而且openfire的缓存基本都被vcard、roster占了。头像放云里，或者搞头像服务，并且做客户端同步。 避免为每一种请求开发一个新iq，设计一个通用的处理iq，统一包装并解析json，简化业务处理。 TLS连接使用更快的算法（用ECDHE RSA-2048代替RSA-4096，而不是DHE、RC4） 如果使用SCRAM-SHA-1算法，服务器将哈希密码处理 (每次都发同样的salt) ，可以对 SaltedPassword 进行缓存, 将节省处理时间。 自动更新管理需要改进，因为openfire设计的客户端下载升级是通过自身的服务器进行，当大量客户端同时下载时一定挂。 尝试用redis存储缓存，让of专注于一件事：消息处理。 离线信息存储分库，或者用redis存。 不要用windows版的of，最大java内存难以大于1300MB，另外linux可更多的tcp连接。在linux下执行ulimit -n 100000设置为10万。 保证你重写AuthProvider的验证返回一定要快，你会发现登录时间至少提升1-2秒。 将登录验证的9个round trip，减少到3个round trip，这里很详细 读读官方的优化方案：openfire_optimization 另外，增加消息回执机制，解决of4.0以前的本身机制造成的丢消息风险.]]></content>
      <tags>
        <tag>XMPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于XMPP实现简单的聊天功能(四)]]></title>
    <url>%2F2016%2F07%2F25%2FiOS-build-your-chart-app-with-xmpp-framework-4%2F</url>
    <content type="text"><![CDATA[概述XMPP提供了RFC 2779 定义的基本的即时消息和出席信息功能。XMPP的核心功能定义在XMPP CORE文档中（RFC3920），为各种类型的准实时消息应用提供了一个构造基础。 消息的类型消息的类型可以分为以下几类： chat 消息是在一对一聊天会话的语境被发送. 一个兼容的客户端应该(SHOULD)在一个允许两个实体进行一对一聊天的界面中显示消息,包括适当的会话历史. error 发生了一个和上次发送者发送的消息有关的错误。 groupchat 群聊 headline 一个消息可能是由一个递送或广播内容的自动化服务生成的(新闻, 体育, 市场信息, RSS feeds, 等等.). 这个消息是不需要回复的, 一个兼容客户端应该(SHOULD) 在一个适当的和单独消息,聊天会话,或群聊会话不同的界面显示这个消息(例如, 不给接收者提供回复能力). normal 这个消息是一个在一对一会话或群聊会话之外的单独消息, 并且它希望接收者能够回复. 子元素Message消息主要包括三种子元素： 元素包含了人类可读的 XML 字符数据指明这个消息的主题. 元素包含人类可读的XML字符数据表达消息的文本内容;这个子元素通常会有但是是可选的(OPTIONAL).body元素通常是我们消息的主体内容部分。 线索，类似于Email中那种回复记录。 接收消息在XMPPStream中提供了接收Message节点的方法： 1- (void)xmppStream:(XMPPStream *)sender didReceiveMessage:(XMPPMessage *)message; XMPPMessage是XMPPElement子类，其结构是XML格式的节点信息。大概结构如下： 1234567&lt;message to='romeo@example.net' from='juliet@example.com/balcony' type='chat' xml:lang='en'&gt; &lt;body&gt;Wherefore art thou, Romeo?&lt;/body&gt;&lt;/message&gt; XMPPFramework提供了几种判断是否为聊天消息的方法： 1234- (BOOL)isChatMessage;- (BOOL)isChatMessageWithBody;- (BOOL)isErrorMessage;- (BOOL)isMessageWithBody; 通常情况下我们的消息内容保存在body中，所以在获取聊天消息内容时，只需要取出[message body]中的内容即可。 发送消息XMPPFramework提供了一系列创建消息实体的方法： 123456789+ (XMPPMessage *)messageFromElement:(NSXMLElement *)element;+ (XMPPMessage *)message;+ (XMPPMessage *)messageWithType:(NSString *)type;+ (XMPPMessage *)messageWithType:(NSString *)type to:(XMPPJID *)to;+ (XMPPMessage *)messageWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid;+ (XMPPMessage *)messageWithType:(NSString *)type to:(XMPPJID *)jid elementID:(NSString *)eid child:(NSXMLElement *)childElement;+ (XMPPMessage *)messageWithType:(NSString *)type elementID:(NSString *)eid;+ (XMPPMessage *)messageWithType:(NSString *)type elementID:(NSString *)eid child:(NSXMLElement *)childElement;+ (XMPPMessage *)messageWithType:(NSString *)type child:(NSXMLElement *)childElement; 具体的示例代码如下： 12345678910111213/** * 发送文本消息 * */- (void)sendTextMessage:(NSString *)text to:(NSString *)chatter complete:(void (^)(NSError *error,BOOL isSuccess))complete &#123; ICHMessageOperation *op = [ICHMessageOperation messageOperationWithBody:text to:chatter completeBlock:^(XMPPMessage *message, NSError *error, BOOL isSuccess) &#123; if (complete) &#123; complete(error,isSuccess); &#125; &#125;]; [self.messageOp addOperation:op];&#125; ICHMessageOperation.m的代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107@interface ICHMessageOperation ()@property (nonatomic,copy)XMPPMessage *sendMessage;@property (nonatomic,copy)void (^sendComplete)(XMPPMessage * message,NSError *error ,BOOL isSend);@property (nonatomic,assign,readwrite,getter=isFinished)BOOL finished;@property (nonatomic,assign,readwrite,getter=isExecuting)BOOL executing;@end@implementation ICHMessageOperation@synthesize executing =_executing;@synthesize finished = _finished;- (void)main &#123; if(!self.isCancelled) &#123; [self willChangeValueForKey:@"isExecuting"]; _executing = YES; [self didChangeValueForKey:@"isExecuting"]; [[self currentStream] sendElement:self.sendMessage]; &#125;else &#123; [self finish]; &#125;&#125;- (void)start &#123; [self main];&#125;- (void)xmppStream:(XMPPStream *)sender didSendMessage:(XMPPMessage *)message &#123; if (!self.isCancelled &amp;&amp; [[message elementID] isEqualToString:[self.sendMessage elementID]]) &#123; DDLogVerbose(@"发送消息成功"); if (self.sendComplete) &#123; dispatch_main_safe(self.sendComplete(message,nil,YES)) &#125; [self removeDelegate]; [self finish]; &#125;else &#123; [self finish]; &#125;&#125;- (void)cancel &#123; [super cancel];&#125;- (void)xmppStream:(XMPPStream *)sender didFailToSendMessage:(XMPPMessage *)message error:(NSError *)error &#123; if (!self.isCancelled) &#123; DDLogError(@"发送消息失败"); if (self.sendComplete) &#123; dispatch_main_safe(self.sendComplete(message,error,NO)); &#125; [self removeDelegate]; [self finish]; &#125;else &#123; [self finish]; &#125;&#125;- (XMPPStream *)currentStream &#123; return [(ICHManager *)[[ICHClient sharedClient] chatManager] chatStream];&#125;- (void)removeDelegate &#123; [[self currentStream] removeDelegate:self];&#125;- (void)dealloc &#123; [self removeDelegate]; self.sendComplete = nil; self.sendMessage = nil;&#125;+ (instancetype)messageOperationWithBody:(NSString *)text to:(NSString *)chatter completeBlock:(void (^)(XMPPMessage *message,NSError *error ,BOOL isSuccess))complete &#123; ICHMessageOperation *op = [[self alloc]init]; XMPPJID *chatterJid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@%@",chatter,iChatServerName]]; XMPPMessage *msg = [XMPPMessage messageWithType:@"chat" to:chatterJid]; [msg addAttributeWithName:@"id" stringValue:[NSString stringWithFormat:@"%@",@([[NSDate date] timeIntervalSince1970])]]; [msg addBody:text]; op.sendMessage = msg; op.sendComplete = complete; [[op currentStream] addDelegate:op delegateQueue:dispatch_get_main_queue()]; return op;&#125;- (BOOL)isAsynchronous &#123; return YES;&#125;- (BOOL)isConcurrent &#123; return YES;&#125;- (void)finish&#123; self.sendMessage = nil; [self willChangeValueForKey:@"isExecuting"]; [self willChangeValueForKey:@"isFinished"]; _executing = NO; _finished = YES; [self didChangeValueForKey:@"isExecuting"]; [self didChangeValueForKey:@"isFinished"];&#125;@end 消息聊天的处理在处理了如何收发消息之后，接下来需要将聊天的内容展示出来，这里推荐一个聊天界面的iOS框架：JSQMessagesViewController GitHub地址关于如何使用JSQMessageViewController这里不做详细介绍了，可以参考官方的一些内容。使用JSQMessageViewController只需要继承JSQMessagesViewController，然后override一些方法，部分逻辑处理代码如下： 点击发送按钮的事件处理： 12345678910111213141516171819202122232425- (void)didPressSendButton:(UIButton *)button withMessageText:(NSString *)text senderId:(NSString *)senderId senderDisplayName:(NSString *)senderDisplayName date:(NSDate *)date &#123; ICHMessageModel *message = [[ICHMessageModel alloc] initWithSenderId:senderId senderDisplayName:senderDisplayName date:date text:text]; __weak typeof (*&amp;self) wself = self; [[ICHClient sharedClient].chatManager sendTextMessage:text to:_chatterId complete:^(NSError *error, BOOL isSuccess) &#123; __strong typeof (*&amp;wself) sself =wself; if (isSuccess) &#123; [JSQSystemSoundPlayer jsq_playMessageSentSound]; [sself-&gt;_dataArray addObject:message]; [sself finishSendingMessageAnimated:YES]; &#125;else &#123; DDLogError(@"send message failed:%@",error); &#125; &#125;];&#125; Cell的样式处理： 123456789101112131415161718192021222324- (UICollectionViewCell *)collectionView:(UICollectionView *)collectionView cellForItemAtIndexPath:(NSIndexPath *)indexPath &#123; /** * Override point for customizing cells */ JSQMessagesCollectionViewCell *cell = (JSQMessagesCollectionViewCell *)[super collectionView:collectionView cellForItemAtIndexPath:indexPath]; ICHMessageModel *msg = [_dataArray objectAtIndex:indexPath.item]; if (!msg.isMediaMessage) &#123; if ([msg.senderId isEqualToString:self.senderId]) &#123; cell.textView.textColor = [UIColor whiteColor]; &#125; else &#123; cell.textView.textColor = [UIColor darkGrayColor]; &#125; cell.textView.linkTextAttributes = @&#123; NSForegroundColorAttributeName : cell.textView.textColor, NSUnderlineStyleAttributeName : @(NSUnderlineStyleSingle | NSUnderlinePatternSolid) &#125;; &#125; cell.delegate = self; return cell;&#125; 聊天Cell背景的处理： 12345678- (id&lt;JSQMessageBubbleImageDataSource&gt;)collectionView:(JSQMessagesCollectionView *)collectionView messageBubbleImageDataForItemAtIndexPath:(NSIndexPath *)indexPath &#123; ICHMessageModel *model = _dataArray[indexPath.row]; if ([model.senderId isEqualToString: self.senderId]) &#123; return _bubbleModel.senderBubble; &#125;else &#123; return _bubbleModel.recieverBubble; &#125;&#125; 日期显示的处理： 1234567891011121314151617181920212223242526272829303132- (NSAttributedString *)collectionView:(JSQMessagesCollectionView *)collectionView attributedTextForCellTopLabelAtIndexPath:(NSIndexPath *)indexPath &#123; ICHMessageModel *currentModel = _dataArray[indexPath.row]; if (indexPath.row ==0) &#123; return [[NSAttributedString alloc]initWithString:[TimeHelper stringWithDate:currentModel.date] attributes:@&#123;NSForegroundColorAttributeName:RGBA(115, 115, 115, 1)&#125;]; &#125;else &#123; ICHMessageModel *preModel = _dataArray[indexPath.row - 1]; if (timeBetweenMessages(preModel, currentModel) &gt; defaultMessageDuration) &#123; return [[NSAttributedString alloc]initWithString:[TimeHelper stringWithDate:currentModel.date] attributes:@&#123;NSForegroundColorAttributeName:RGBA(115, 115, 115, 1)&#125;]; &#125; &#125; return nil;&#125;NSTimeInterval timeBetweenMessages(ICHMessageModel *pre,ICHMessageModel *suf) &#123; return CFDateGetTimeIntervalSinceDate((CFDateRef)suf.date,(CFDateRef)pre.date);&#125;- (CGFloat)collectionView:(JSQMessagesCollectionView *)collectionView layout:(JSQMessagesCollectionViewFlowLayout *)collectionViewLayout heightForCellTopLabelAtIndexPath:(NSIndexPath *)indexPath &#123; ICHMessageModel *currentModel = _dataArray[indexPath.row]; if (indexPath.row ==0) &#123; return 20.0f; &#125;else &#123; ICHMessageModel *preModel = _dataArray[indexPath.row - 1]; if (timeBetweenMessages(preModel, currentModel) &gt; defaultMessageDuration) &#123; return 20.0f; &#125; &#125; return 0.0f;&#125; 接收到消息的处理： 12345678- (void)didRecieveMessage:(ICHMessageModel *)message &#123; if ([message.senderId isEqualToString:_chatterId] || [message.senderId isEqualToString:currentUser]) &#123; [_dataArray addObject:message]; [JSQSystemSoundPlayer jsq_playMessageReceivedSound]; [self finishReceivingMessage]; &#125;&#125; 发送自定义消息：XMPP支持发送自定义的消息如音视频，图片等，这种消息的处理需要我们的客户端做自定义的处理，比如发送图片，我们可以在body体中表明信息的类型，然后在message中添加自定义的子节点：创建一个自定义图片类型的子节点如下： 123456789XMPPJID *chatterJid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@%@",chatter,iChatServerName]];XMPPMessage *msg = [XMPPMessage messageWithType:@"chat" to:chatterJid];[msg addAttributeWithName:@"id" stringValue:[NSString stringWithFormat:@"%@",@([[NSDate date] timeIntervalSince1970])]];[msg addBody:@"image"];NSData *data = UIImageJPEGRepresentation(image,0.3);NSString *base64 = [data base64EncodedStringWithOptions:NSDataBase64Encoding64CharacterLineLength];[msg addChild:[XMPPElement elementWithName:@"attachment" stringValue:base64]];[self.chatStream sendElement:msg]; 我们将需要发送的图片进行了base64编码，并添加到了message的节点，那么在接收消息时可以这样判断： 12345678910111213141516171819202122ICHMessageModel *msgModel;if ([message elementForName:@"attachment"]) &#123; switch ([self messageTypeWithString:message.body]) &#123; case ICHMessageModelTypePhoto: &#123; NSString *base64 = [[message elementForName:@"attachment"] stringValue]; NSData *data = [[NSData alloc]initWithBase64EncodedString:base64 options:NSDataBase64DecodingIgnoreUnknownCharacters]; UIImage *image = [UIImage imageWithData:data]; JSQPhotoMediaItem *item = [[JSQPhotoMediaItem alloc]initWithImage:image]; item.appliesMediaViewMaskAsOutgoing = NO; msgModel = [[ICHMessageModel alloc]initWithSenderId:message.from.user senderDisplayName:message.from.user date:[NSDate date] media:item]; msgModel.msg = message; &#125; break; default: break; &#125;&#125;else &#123; msgModel = [ICHMessageModel messageWithSenderId:message.from.user displayName:message.from.user text:message.body]; msgModel.msg = message;&#125;return msgModel; 效果如下: 剩下的文件，语音，视频，定位的消息体都可以参考类似的实现方式，另外关于将body中添加”image”标示的方式可以另外添加一个MessageType节点以表明消息的类型：比如0,这样可以简化在客户端处理相应的逻辑内容。此外：在发送内容比较多的大的数据时（比如高清图片，视频文件等），测试时要保证对方的账号在线，否则后台将会对数据的内容进行缓存，由于openfire服务器对离线消息的默认缓存大小为0.1MB,所以发送的内容包过大时，会返回503错误。其实XMPP服务器最好不要做一些文件，图片内容的缓存，而应该另外建立一个文件服务器提供存储服务，在消息中保留图片和文件资源的url链接地址而不是实际内容，这样可以优化XMPP的性能，同时客户端可以更好的处理文件的下载与存储的逻辑。 富文本消息XEP－0071：XHTML-IM协议是一个扩展的富文本协议，该协议仍然是一个草案协议，不过可以在自定义的消息中使用，可以创建类似于微信分享中的分享文档样式，其写法类似于HTML，使用起来很方便。简单的消息样式如下： 12345678&lt;message&gt; &lt;body&gt;hi!&lt;/body&gt; &lt;html xmlns='http://jabber.org/protocol/xhtml-im'&gt; &lt;body xmlns='http://www.w3.org/1999/xhtml'&gt; &lt;p style='font-weight:bold'&gt;hi!&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;&lt;/message&gt; HTML完全可以当作一个WebView来展示！所以订阅号和一些链接的H5消息完全可以采用这种形式。 参考文章 RFC3921 wiki XMPP rfc3921 董柏然的博客 XEP-0071]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>XMPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于XMPP实现简单的聊天功能(三)]]></title>
    <url>%2F2016%2F07%2F23%2FiOS-build-your-chart-app-with-xmpp-framework-3%2F</url>
    <content type="text"><![CDATA[上下线 发送在线状态好友的在线状态是通过XMPPPresence类来实现的，通常的做法是在登录成功后向服务器发送在线状态请求，或是在拉取所有联系人后发送自己的在线状态。示例代码如下： 123456- (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender &#123; DLog(@"结束接收好友列表"); [self.chatStream sendElement:[XMPPPresence presence]]; [_muldelegate didEndFetchingUsers];&#125; 当socket断开连接时，应该发送下线请求： 1234XMPPPresence *presence = [XMPPPresence presenceWithType:@"unavailable"];[self.chatStream sendElement:presence];[self.chatStream disconnect]; 接收好友状态信息描述：获取好友状态是通过- (void)xmppStream:(XMPPStream *)sender didReceivePresence:(XMPPPresence *)presence回调方法得到的。你可以在这里获取联系人的状态描述信息。你可以获取到发送状态变化的联系人的名称及状态:[presence from]获取发送状态的JID，以及发送的状态：[presence type]。当然你也可以自定义扩展presence的状态，比如离开，请勿打扰等。[presense show]方法可以获取具体的状态。 好友列表XMPP获取好友是通过XMPPRoster类来实现的（又称花名册），在初始化Stream时将roster注册到流中，并设置为自动获取数据，通过回调方法来接收结果，也可以手动的在登录成功后获取数据。XMPPRoster通过CoreData框架来存储数据的，所以在使用Roster前，你可能需要了解下如何使用CoreData是如何工作的。 初始化Roster1234//花名册XMPPRosterCoreDataStorage *store = [[XMPPRosterCoreDataStorage alloc] initWithDatabaseFilename:@"ICHRoster.sqlite" storeOptions:nil];self.roster = [[XMPPRoster alloc]initWithRosterStorage:store dispatchQueue:_ichatQueue];self.roster.autoFetchRoster = NO; 初始化Roster需要建立一个Storage，Roster的storage可以保存在内存中，也可以做数据的持久化存储。这里选择了进行数据持久化存储缓存数据。storeOptions可以有两种选项：NSMigratePersistentStoresAutomaticallyOption : @(YES)和 NSInferMappingModelAutomaticallyOption : @(YES) 具体的用法可以参考Coredata的使用。Roster可以选择自动获取数据： 123456/** * Whether or not to automatically fetch the roster from the server. * * The default value is YES.**/@property (assign) BOOL autoFetchRoster; 获取好友列表通过将Roster添加到流中激活Roster： 12345678- (void)fetchUsersFromServer &#123; if ([self.roster isPopulating]) &#123; return; &#125; [self.roster addDelegate:self delegateQueue:_ichatQueue]; [self.roster activate:self.chatStream]; [self.roster fetchRoster];&#125; 通过以下代理回调来完成获取好友列表： 12345678910111213141516171819202122232425262728293031323334353637/** * Sent when the initial roster is received.**/- (void)xmppRosterDidBeginPopulating:(XMPPRoster *)sender withVersion:(NSString *)version;/** * Sent when the initial roster has been populated into storage.**/- (void)xmppRosterDidEndPopulating:(XMPPRoster *)sender;/** * Sent when the roster receives a roster item. * * Example: * * &lt;item jid='romeo@example.net' name='Romeo' subscription='both'&gt; * &lt;group&gt;Friends&lt;/group&gt; * &lt;/item&gt;**/- (void)xmppRoster:(XMPPRoster *)sender didReceiveRosterItem:(NSXMLElement *)item;``` 如果你的好友列表数据是自定义存储的，那么你可能需要在回调方法里存储自定义的数据，而如果使用Roster自带的Storage进行数据存储，不需要做数据存储的处理。在UI层可以通过`NSFetchedResultsController`来监听数据的变化。#### 添加删除好友XMPPRoster提供了完整的处理好友相关的事件,所有的使用方法可以在XMPPRoster.h中找到##### 添加好友``` objc-(void)addFriendSubscribe:(NSString *)name &#123; XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@%@",name,iChatServerName]]; [self.roster addUser:jid withNickname:nil]; [self.roster subscribePresenceToUser:jid];&#125; 删除好友1234- (void)removeFriends:(NSString *)name &#123;XMPPJID *jid = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@%@",name,iChatServerName]];[self.roster removeUser:jid];&#125; 接受好友的请求当另一个人向你发起了好友请求时会接收到如下的回调方法： 1- (void)xmppRoster:(XMPPRoster *)sender didReceivePresenceSubscriptionRequest:(XMPPPresence *)presence; 通过presence的from方法，我们可以获取到是谁发起的好友请求。接受与拒绝好友请求的方法可以在XMPPRoster类中找到： 接受好友请求以及是否添加到自己的好友列表中 1234567/** * Accepts the presence subscription request the given user. * * If you also choose, you can add the user to your roster. * Doing so is similar to the traditional IM model.**/- (void)acceptPresenceSubscriptionRequestFrom:(XMPPJID *)jid andAddToRoster:(BOOL)flag; 拒绝好友请求 1234567/** * Rejects the presence subscription request from the given user. * * If you are already subscribed to the given user's presence, * rejecting they subscription request will not affect your subscription to their presence.**/- (void)rejectPresenceSubscriptionRequestFrom:(XMPPJID *)jid; 另外添加好友的同时一般同时会关注对方的上下线信息，所以常常会在发送好友请求时顺带着发起订阅好友状态信息的请求： 1- (void)subscribePresenceToUser:(XMPPJID *)jid; 移除好友也是一样的。 UI层展示这里给出一个UI层的示例代码： .h 1234#import "ICHRefreshTableController.h"@interface RootController : ICHRefreshTableController@end .m123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static NSString *cellid = @”ICHFriendCellId”;@import CoreData;@interface RootController ()&lt;ICHDelegate,NSFetchedResultsControllerDelegate&gt;&#123; &#125;@property (nonatomic,strong)NSFetchedResultsController *fetchControl;@end@implementation RootController- (void)viewDidLoad &#123; [super viewDidLoad]; self.title = @"好友列表"; self.refreshEnable = YES; [self.tableview registerClass:[ICHFriendCell class] forCellReuseIdentifier:cellid]; [[ICHClient sharedClient].chatManager addDelegate:self onQueue:dispatch_get_main_queue()]; [[ICHClient sharedClient].chatManager fetchUsersFromServer];&#125;- (NSFetchedResultsController *)fetchControl &#123; if (_fetchControl == nil) &#123; NSFetchRequest *request = [[NSFetchRequest alloc]initWithEntityName:@"XMPPUserCoreDataStorageObject"]; NSSortDescriptor *isOnline = [NSSortDescriptor sortDescriptorWithKey:@"sectionNum" ascending:YES]; NSSortDescriptor *name = [NSSortDescriptor sortDescriptorWithKey:@"displayName" ascending:YES]; [request setSortDescriptors:@[isOnline,name]]; _fetchControl = [[NSFetchedResultsController alloc]initWithFetchRequest:request managedObjectContext:[ICHClient sharedClient].mainThreadContext sectionNameKeyPath:@"sectionName" cacheName:nil]; _fetchControl.delegate = self; &#125; return _fetchControl;&#125;- (void)didEndFetchingUsers &#123; NSError *error = nil; BOOL result = [self.fetchControl performFetch:&amp;error]; if (!result) &#123; DDLogWarn(@"fetch user failed ,errorMsg:%@",error); return; &#125; [self.tableview reloadData];&#125;- (void)controller:(NSFetchedResultsController *)controller didChangeObject:(id)anObject atIndexPath:(NSIndexPath *)indexPath forChangeType:(NSFetchedResultsChangeType)type newIndexPath:(NSIndexPath *)newIndexPath &#123; [self.tableview reloadData];&#125;#pragma mark --TableViewDelegate- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; return [_fetchControl.sections[section] numberOfObjects];&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&#123; ICHFriendCell *cell = [tableView dequeueReusableCellWithIdentifier:cellid]; ICHUserEntity *entity =[[ICHUserEntity alloc] initWithObj: [_fetchControl objectAtIndexPath:indexPath]]; [cell setModel:entity]; return cell;&#125;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath&#123; [tableView deselectRowAtIndexPath:indexPath animated:YES]; XMPPUserCoreDataStorageObject *obj = [_fetchControl objectAtIndexPath:indexPath]; ICHChatViewController *chat = [[ICHChatViewController alloc]initWithChatter:obj.jid.user isGroup:NO]; [self.navigationController pushViewController:chat animated:YES];&#125;- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView &#123; return [_fetchControl.sections count];&#125;- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; return 70.0f;&#125; 因为时间的关系，对于监听回调的处理并不是很好，主要是reloadData方法会刷新整张tableview，所以在性能上比较差， 关于NSFetchedResultsController的使用可以参考这篇博客。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>XMPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于XMPP实现简单的聊天功能(二)]]></title>
    <url>%2F2016%2F07%2F21%2FiOS-build-your-chart-app-with-xmpp-framework-2%2F</url>
    <content type="text"><![CDATA[连接XMPPFramework使用Asyncsocket作为socket通讯的框架，连接时需要建立一个XMPPStream，通过代理的方式处理连接的是否成功。建立连接的代码如下： 123456789//@property (nonatomic,strong)XMPPStream *chatStream;声明_chatStream = [[XMPPStream alloc]init];_chatStream.hostName = iChatHost;_chatStream.hostPort = iChatPort;_chatStream.enableBackgroundingOnSocket = YES;_chatStream.keepAliveInterval = 100.0f;_ichatQueue = dispatch_queue_create("com.ichat.reddick", NULL);[self.chatStream addDelegate:self delegateQueue:_ichatQueue]; 代理的方法声明在XMPPStream.h中： 123- (void)xmppStreamWillConnect:(XMPPStream *)sender;- (void)xmppStream:(XMPPStream *)sender socketDidConnect:(GCDAsyncSocket *)socket;- (void)xmppStreamDidConnect:(XMPPStream *)sender; 登录通常情况下在连接服务器OK之后便可以发起登陆请求，XMPP协议允许匿名的方式登录，需要在后台服务器(OpenfireWeb界面)的服务器设置-&gt;登录和注册设置中设置。在连接服务器之后，调用- (BOOL)authenticateWithPassword:(NSString *)password error:(NSError **)errPtr方法可以发起用户认证。 登录成功和失败的回调方法如下： 12- (void)xmppStreamDidAuthenticate:(XMPPStream *)sender;- (void)xmppStream:(XMPPStream *)sender didNotAuthenticate:(NSXMLElement *)error 下面给出一个完整的登录示例：ICHManager.h 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174@protocol ICHDelegate; @interface ICHManager : NSObject&lt;ICHLoginProtocol,ICHProtocol&gt;&#123; dispatch_queue_t _ichatQueue; GCDMulticastDelegate &lt;ICHDelegate&gt;*_muldelegate;&#125;@property (nonatomic,strong)XMPPStream *chatStream;@end``` ICHManager.m``` objc@interface ICHManager ()&lt;ICHLoginHelperDelegate,ICHConnectHelperDelegate&gt;&#123; NSMutableDictionary *_loginInfo; BOOL _isLoggedIn; NSString *_userName; NSString *_password; ICHLoginHelper *_loginHelper; ICHConnectedHelper *_connectHelper; ICHRegisterHelper *_register;&#125;@end@implementation ICHManager- (instancetype)init &#123; if (self = [super init]) &#123; _isLoggedIn = NO; _loginInfo = [[NSMutableDictionary alloc]init]; _chatStream = [[XMPPStream alloc]init]; _chatStream.hostName = iChatHost; _chatStream.hostPort = iChatPort; _chatStream.enableBackgroundingOnSocket = YES; _chatStream.keepAliveInterval = 100.0f; _muldelegate = (GCDMulticastDelegate &lt;ICHDelegate&gt;*)[[GCDMulticastDelegate alloc]init]; _ichatQueue = dispatch_queue_create("com.ichat.reddick", NULL); _messageOp = [[NSOperationQueue alloc]init]; _messageOp.maxConcurrentOperationCount = 10; _connectHelper = [[ICHConnectedHelper alloc]init]; _connectHelper.connectDelegate = self; [self.chatStream addDelegate:_connectHelper delegateQueue:_ichatQueue]; [self.chatStream addDelegate:self delegateQueue:_ichatQueue]; &#125; return self;&#125;- (void)addDelegate:(id)delegate onQueue:(dispatch_queue_t)queue &#123; [_muldelegate addDelegate:delegate delegateQueue:queue];&#125;- (void)removeDelegate:(id)delegate onQueue:(dispatch_queue_t)queue &#123; [_muldelegate removeDelegate:delegate delegateQueue:queue];&#125;#pragma mark --Property- (BOOL)isConnected &#123; return self.chatStream.isConnected;&#125;- (BOOL)isLoggedIn &#123; return _isLoggedIn;&#125;- (NSDictionary *)loginInfo &#123; return [_loginInfo copy];&#125;#pragma mark --- (void)asyncLoginWithUsername:(NSString *)username password:(NSString *)password completion:(void (^)(NSDictionary *, NSError *))completion onQueue:(dispatch_queue_t)aQueue &#123; [self removeHelper]; _loginHelper = [[ICHLoginHelper alloc]initWithUsername:username password:password]; [self _setUsername:username password:password]; _loginHelper.loginDelegate = self; _loginHelper.stream = _chatStream; [self.chatStream addDelegate:_loginHelper delegateQueue:_ichatQueue]; __weak typeof (NSMutableDictionary *) wloginInfo = _loginInfo; if (completion) &#123; [_loginHelper setCompletion:^(NSDictionary *res, NSError *error) &#123; if (!error) &#123; _isLoggedIn = YES; [wloginInfo setDictionary:res]; &#125; dispatch_main_safe(completion(res,error)); &#125;]; &#125; if (self.chatStream.isConnected || self.chatStream.isConnecting) &#123; [_loginHelper startLogin]; &#125;else &#123; NSError *error = nil; [self.chatStream connectWithTimeout:10.0f error:&amp;error]; if (error) &#123; dispatch_async(_ichatQueue, ^&#123; [_muldelegate didLoginFailed:error]; &#125;); &#125; &#125;&#125;- (void)ayncLoginWithUsername:(NSString *)username password:(NSString *)password &#123; [self asyncLoginWithUsername:username password:password completion:nil onQueue:dispatch_get_main_queue()];&#125;- (NSDictionary *)loginWithUsername:(NSString *)username password:(NSString *)password error:(NSError *__autoreleasing *)pError &#123; __block NSDictionary *result = nil; dispatch_semaphore_t sema = dispatch_semaphore_create(0); [self asyncLoginWithUsername:username password:password completion:^(NSDictionary *loginInfo, NSError *error) &#123; if (pError) &#123; *pError = error; &#125; result = loginInfo; dispatch_semaphore_signal(sema); &#125; onQueue:_ichatQueue]; long res = dispatch_semaphore_wait(sema, dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_SEC *10)); if(res &amp;&amp; pError) &#123; *pError = [NSError errorWithDomain:@"com.login.timeout" code:1 userInfo:@&#123;&#125;]; &#125; return result;&#125;#pragma mark -- private- (void)_setUsername:(NSString *)username password:(NSString *)password &#123; _userName = [username copy]; _password = [password copy]; self.chatStream.myJID = [XMPPJID jidWithString:[NSString stringWithFormat:@"%@%@",username,iChatServerName]];&#125;#pragma mark -- ConnectHelperDelegate- (void)helperWillConnectToServer:(ICHConnectedHelper *)sender &#123; [_muldelegate willConnectToServer];&#125;- (void)helperDidConnectToServer:(ICHConnectedHelper *)sender &#123; [_muldelegate didConnectToServer];&#125;#pragma mark -- RDLoginHelperDelegate- (void)loginHelperWillAuthenticate:(id)sender &#123; [_muldelegate willStartLogin];&#125;- (void)loginHelperDidAuthenticate:(id)sender &#123; XMPPvCardCoreDataStorage * xmppvCardStorage = [[XMPPvCardCoreDataStorage alloc]initWithInMemoryStore]; self.vCard = [[XMPPvCardTempModule alloc]initWithvCardStorage:xmppvCardStorage dispatchQueue:_ichatQueue]; [self.vCard addDelegate:self delegateQueue:_ichatQueue]; [self.vCard activate:self.chatStream]; [_muldelegate didLoginSuccess:@&#123;@"username":[_userName copy],@"password":[_password copy]&#125;];&#125;- (void)loginHelperFailAuthenticate:(id)sender error:(NSError *)errorMsg &#123; [_muldelegate didLoginFailed:errorMsg];&#125; ICHProtocol 1234@protocol ICHProtocol &lt;NSObject&gt;- (void)addDelegate:(id)delegate onQueue:(dispatch_queue_t)queue;- (void)removeDelegate:(id)delegate onQueue:(dispatch_queue_t)queue;@end ICHLoginProtocol协议 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@protocol ICHLoginProtocol &lt;NSObject&gt;/*! 当前登录的用户信息 */@property (nonatomic, strong, readonly) NSDictionary *loginInfo;/*! 当前是否已有登录的用户 */@property (nonatomic, readonly) BOOL isLoggedIn;/*! 是否连上聊天服务器 */@property (nonatomic, readonly) BOOL isConnected;/*! @method @brief 使用用户名密码登录聊天服务器 默认10s超时 @discussion 如果登陆失败, 返回nil @param username 用户名 @param password 密码 @param pError 错误信息 @result 登录后返回的用户信息 */- (NSDictionary *)loginWithUsername:(NSString *)username password:(NSString *)password error:(NSError **)pError;- (void)ayncLoginWithUsername:(NSString *)username password:(NSString *)password;/*! @method @brief 异步方法, 使用用户名密码登录聊天服务器 @discussion @param username 用户名 @param password 密码 @param completion 回调 @param aQueue 回调时的线程 @result */- (void)asyncLoginWithUsername:(NSString *)username password:(NSString *)password completion:(void (^)(NSDictionary *loginInfo, NSError *error))completion onQueue:(dispatch_queue_t)aQueue;@end 在登录控制器中我们只需要调用如下同步或者异步的登录方法即可 123456789101112[[ICHClient sharedClient].chatManager asyncLoginWithUsername:username password:password completion:^(NSDictionary *loginInfo, NSError *error) &#123; if (!error) &#123; if (self.loginCompleteBlock) &#123; self.loginCompleteBlock(); &#125; &#125; &#125; onQueue:dispatch_get_main_queue()]; 注册通过XMPPStream的- (BOOL)registerWithPassword:(NSString *)password error:(NSError **)errPtr;方法可以发起注册请求，通常情况下也是在xmppStreamDidConnect之后发起注册请求，所以在发起注册请求之前需要判断XMPPStream是否已经连接，如果已经连接了，便可以直接发起注册请求，如果未连接，需要将注册事件发起在连接成功之后。示例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041@interface ICHRegisterHelper ()&lt;XMPPStreamDelegate&gt;@property (nonatomic,copy)NSString *username;@property (nonatomic,copy)NSString *password;@end@implementation ICHRegisterHelper+ (instancetype)helperWithusername:(NSString *)username password:(NSString *)password &#123; ICHRegisterHelper *helper = [[ICHRegisterHelper alloc]init]; helper.username = username; helper.password = password; return helper;&#125;- (void)registerWithusername:(NSString *)username password:(NSString *)password &#123; NSError *error = nil; [_stream registerWithPassword:_password error:&amp;error]; if (error) &#123; DDLogWarn(@"registerfailed :%@",error); &#125;&#125;- (void)xmppStreamDidConnect:(XMPPStream *)sender &#123; NSError *error = nil; [_stream registerWithPassword:_password error:&amp;error]; if (error) &#123; DDLogWarn(@"registerfailed :%@",error); &#125;&#125;- (void)xmppStreamDidRegister:(XMPPStream *)sender &#123; DDLogWarn(@"%s",__func__); [_delegate helperDidRegistered:@&#123;@"username":_username,@"password":_password&#125;];&#125;- (void)xmppStream:(XMPPStream *)sender didNotRegister:(DDXMLElement *)error &#123; //TODO 解析错误 DDLogError(@"%@",error); NSError *registerfailed = [NSError errorWithDomain:@"registerfailed" code:0 userInfo:@&#123;&#125;]; [_delegate helperDidFailedRegister:registerfailed];&#125;@end ICHManager.h 1234567891011121314151617181920212223242526272829303132- (void)registerWithUsername:(NSString *)username password:(NSString *)password &#123;if(_isLoggedIn) &#123; DDLogError(@"已登录的用户无法进行注册操作,已取消"); return;&#125;[self removeHelper];_register = [ICHRegisterHelper helperWithusername:username password:password];[self _setUsername:username password:password];_register.delegate = self;_register.stream = _chatStream;[self.chatStream addDelegate:_register delegateQueue:_ichatQueue];if (self.chatStream.isConnecting|| self.chatStream.isConnected) &#123; [_register registerWithusername:username password:password];&#125;else &#123; NSError *error = nil; [self.chatStream connectWithTimeout:1.0f error:&amp;error]; if (error) &#123; dispatch_async(_ichatQueue, ^&#123; [_muldelegate didRegiserFailed:error]; &#125;); &#125; &#125;&#125;#pragma mark ICHRegisterHelperDelegate- (void)helperDidRegistered:(NSDictionary *)info &#123; [_muldelegate didRegisterSuccess];&#125;- (void)helperDidFailedRegister:(NSError *)error &#123; [_muldelegate didRegiserFailed:error];&#125;]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>XMPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于XMPP实现简单的聊天功能(一)]]></title>
    <url>%2F2016%2F07%2F18%2FiOS-build-your-chart-app-with-xmpp-framework-1%2F</url>
    <content type="text"><![CDATA[前言接下来的一段时间里，将简单介绍如何使用XMPPFramework开发自己的聊天客户端。XMPPFramework是一个OS X/iOS平台的开源项目，使用Objective-C实现了XMPP协议，同时还提供了用于读写XML的工具，大大简化了基于XMPP的通信应用的开发。本文主要是环境配置，包括服务器端的搭建以及iOS端的集成。 准备工作 mysqlmysql作为数据库为Openfire提供存储支持，你可以在这里下载到最新版的Mysqllink，如果你熟悉brew，也可以使用命令brew install mysql来安装mysql。登录mysql mysql -u root -p 下载与安装OpenfireOpenfire采用Java开发，开源的实时协作（RTC）服务器基于XMPP（Jabber）协议。Openfire安装和使用都非常简单，并利用Web进行管理。单台服务器可支持上万并发用户。目前的最新版是4.0.2下载最新openfire for mac版安装步骤这里不详细说明了具体可以参考这篇文章mac上搭建openfire服务器 XMPPFramework下载framework:github地址，导入XMPP框架最简单的方式当然是通过pod了：pod &#39;XMPPFramework&#39;,也可以通过手动的方式导入XMPPFramework:git clone https://github.com/robbiehanson/XMPPFramework.git,将XMPPFramework目录下的Authentication，Categories，Core，Extensions，Utilities，XMPPFramework.h文件拷贝到项目中结构如下 123456789101112131415XMPPFramework├── Authentication ├── Categories├── Core├── Extensions├── Utilities├── Vendor└── XMPPFramework.hAuthentication 授权，身份验证Categories 分类Core 核心Extensions 扩展Utilities 工具Vendor 一些依赖的库 在Extensions主要包括coreData的数据存储，重连机制，好友管理，以及系统输入活动监控等。 XMPPFramework.h中包含我们所有需要使用的头文件，如果我们想使用那些功能，只需要将诸事打开便可。需要link的库： 12345CFNetwork.frameworkSecurity.frameworklibxml2.tdblibresolv.tdblibin.a 修改Build Settings中的Header Search Paths添加 /usr/include/libxml2Other Linker Flags添加 -lxml2 XMPP协议的简单介绍 XEP-0009: Jabber-RPC XEP-0012: 最后活动时间 XEP-0077: 注册 XEP-0020: 登录 XEP-0083: 好友列表 XEP-0049: 获取好友列表 XEP-0145: 备注好友信息 XEP-0013/XEP-0160: 离线消息 XEP-0008: 好友头像 RFC-3921: 用户状态 XEP-0085: 聊天状态通知 XEP-0045: 群组聊天 更多的Framework支持协议可以参考官方文档 XMPP协议官方文档：XMPP]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>XMPP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈iOS中的内存管理]]></title>
    <url>%2F2016%2F07%2F04%2FiOS-nei-cun-guan-li%2F</url>
    <content type="text"><![CDATA[概述在Objective－C中，内存管理是一个很重要的概念，要想提升app在使用的中的高效性并写出没有bug的代码，就需要掌握内存管理的种种细节。Objective-c中提供了两种内存管理机制MRC（MannulReference Counting）和ARC(Automatic Reference Counting)，分别提供对内存的手动和自动管理，来满足不同的需求。 MRC时代下的内存管理在MRC的内存管理模式下，与之相关的是对象的引用计数原理以及retain，release和autorelease等概念。 理解引用技术原理所谓引用计数，其实就是对每个对象的一个计数器增加或减少以控制其生存周期。一个对象的引用计数值表明了多少个事物需要此对象。当A对象持有B对象时，B对象的计数值至少为1，如果对象没有被任何对象所持有，那么就会被系统回收。并且可以用NSAutoreleasePool对象，对加入自动释放池（autorelease调用）的变量进行管理，当drain时回收内存。 retain与releaseretain和release方法操作的是引用记数，当引用记数为零时，便自动释放内存。 autorelease将该对象的内存管理放到autoreleasepool中，在autoreleasepool被drain掉时，回收其内存。 dealloc对象的生命周期结束时，就会被系统所回收，这时就会调用dealloc方法了，在每个对象的生命周期中，该方法均执行一次，在该方法中我们需要处理一些释放资源、引用，取消监听等工作。 手动内存管理的方式如下图所示： 手动内存管理必须要遵循的规则手动管理内存有时候并不容易，因为对象的引用有时候是错综复杂的，对象之间可能互相交叉引用，因此需要遵循一条黄金法则：谁创建的，谁负责释放。在Objective-C中以下方法会创建一个对象： 1234- alloc- new - copy- mutableCopy 所以当创建对象后，其内存管理需要开发者自己去控制释放。而对于其他方式创建出来的对象，如NSString的方法+ (instancetype)stringWithFormat:(NSString *)format该方法虽然返回一个新的字符串，但是其内存管理方式是autorelease的，也就是不需要我们去控制释放掉。特别的，对于NSString类型的变量，虽然我们需要对其进行内存管理控制，但是常量的string的retainCount却是－1(Max)。 ARC时代下的内存管理iOS5之后，内存管理方式开始由MRC转向ARC，在引入了ARC之后，内存管理就变得简单多了，因为大部分的内存管理工作已经交由编译器来处理了，开发者只需要关注业务逻辑的处理。 ARC的简化工作在ARC模式下，编译器会自动帮我们处理对象的retain，release，autorelease和dealloc，所以调用这些方法时会产生编译错误，ARC在调用这些方法时并不是通过消息派发机制调用的这些函数，而是使用了C语言的函数，如objc_retain(),因此在ARC下，简单的对象创建与释放并不需要我们关心其内存管理和释放，而对于dealloc方法，我们不能直接去调用该方法，而且，在覆写该函数时，不可以调用[super dealloc]方法。 ARC无法控制的内存管理虽然说ARC大大简化了我们操作内存管理的方式，但是ARC也不是万能的，ARC只能管理Foundation库中的对象，对于CFoundation库中的对象如NSArray的底层实现版本CFArray，其内存管理仍然需要我们去手动控制，另外，一些使用结构体变量和使用C语言函数创建的变量（如malloc）仍然需要我们去手动控制其内存管理(free())。 由MRC转向ARC属性参数的变化在MRC中@property的声明方式有以下几种: 1234567retaincopynonactomicassignactomic__unsafe_unretained... 以@property(nonactomic,retain)NSMutableArray *users为例，实现其setter方法： 12345678- (void)setUsers:(NSMutableArray *)users &#123; if(_users! = users) &#123; [users retain] [_users release]; _users= users; &#125; return _users;&#125; 对于ARC，其兼容MRC下的retain等属性操作，同时新增加了strong,weak等新属性参数，其中strong类似于retain操作，weak对应于assign和__unsafe_unretained,非对象类可以使用assign，对象类可以使用weak。__unsafe_unretained在使用时并不会自动释放掉所持有的对象，而weak选项则会在对象没有强引用后将对象置为nil。 autoreleasepool老式的autoreleasepool会使用以下格式： 123NSAutoreleasePool *pool =[[NSAutoreleasePool alloc]init];//dosomething[pool drain]; 然而这种方式已经不被编译器所支持了，现在编译器的书写方式为 123@autoreleasepool &#123; //dosomething &#125; 在ARC环境下编译MRC文件在ARC中使用手动内存管理的文件是无法通过编译器编译的，需要在Build phases中Compile Sources选项下将需要增加Compiler Flags：-fno-objc-arc 自动释放池在上面提到的自动释放池，实际上是另一种内存管理机制－－自动引用计数管理，不过这只是一种半自动的机制，有些操作还是需要我们手动设置的。在块中调用过autorelease方法的对象都会自动调用一次release方法。这样一来就起到了自动释放的作用，同时对象的销毁过程也得到了延迟（统一调用release方法）。对于自动内存释放简单总结一下： autorelease方法不会改变对象的引用计数器，只是将这个对象放到自动释放池中；自动释放池实质是当自动释放池销毁后调用对象的release方法，不一定就能销毁对象。由于自动释放池最后统一销毁对象，因此如果一个操作比较占用内存（对象比较多或者对象占用资源比较多），最好不要放到自动释放池或者考虑放到多个自动释放池；在大量操作对象时可以使用自动释放池来降低由于大量创建对象而造成的峰值。例如下面的代码： 12345for (NSInteger i=0; i&lt; 1000; i++) &#123; Users *user = [[Users alloc]init]; user.index = i; //user dothing &#125; 在示例中for循环创建了1000个user对象，在for循环结束时这些对象才会得到释放，这样会造成内存瞬间峰值过高的问题，所以我们可以使用autoreleasepool在每次for循环结束时将对象及时释放掉，这样可以减小内存的峰值压力，可以改写为如下代码： 1234567for (NSInteger i=0; i&lt; 1000; i++) &#123; @autoreleasepool &#123; Users *user = [[Users alloc]init]; user.index = i; //user dothing &#125; &#125; 关于autoreleasepool的更多细节，可以参考孙源的这篇博客：黑幕背后的Autorelease 避免retainCycle在iOS常常会有这样的情况，A对象强引用了B对象，B对象强引用了C对象，C又强引用了A对象，三个对象存在相互引用的关系，从而形成了一个环，这种引用关系会导致内存泄漏问题。 如下图所示 因为环中每个对象的引用计数都不会降为0，这种情况被认定为’孤岛’。通常的解决方案是使用外界干扰条件破坏掉环上的某一节，从而打破孤岛条件使得资源得以释放，或者是使用弱引用的方式来避免换的产生，第二种方式在block代码块产生的cycle中被经常使用。 Foundation 和 Core Foundation 对象相互转换iOS中Objective－C对象和CoreFoundation中的对象可以实现无缝转换，这种免费的转换被称为Toll-Free Bridging。你可以使用Foundation框架的函数来操作对象，也可以使用Core Foundation的方法操作对象。Toll-free Bridging的类列表提供在这里：Toll-Free Bridging。我们可以看到，NSString和CFStringRef，NSArray和CFArrayRef都是toll－free bridge的。在MRC下内存管理没什么问题（本来就是手动管理，当然不会有问题），不过在ARC下就不同了，上文提到过，ARC下是无法管理Core Foundation的对象的，所以我们在进行转换时需要告诉编译器应该如何对对象进行引用计数管理。这时候，我们需要使用bridge, bridge_retained, __bridge_transfer 修饰符来告诉编译器该如何去做。 __bridge最常用的修饰符，这意味着告诉编译器不做任何内存管理的事情，编译器仍然负责管理好在 Objc 一端的引用计数的事情，开发者也继续负责管理好在 CF 一端的事情。 __bridge_retained使用_bridge_retained修饰符的对象实际上是将ARC对象转为CF对象时进行一次retain操作，那么即便ARC环境中的对象release掉了，由于在bridge的时候进行过一次retain，CF对象的retainCount仍然不会降为0，所以需要开发者在使用完成后进行CFRelease操作。 __bridge_transfer将CF对象的所有权交由ARC去处理，开发者不再对CF对象进行释放操作。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解NSCopying协议]]></title>
    <url>%2F2016%2F06%2F29%2FiOS-understand-NSCopying-protocol%2F</url>
    <content type="text"><![CDATA[理解NSCopying在使用对象时，我们常常会使用copy方法将一个对象进行拷贝，如果想使自己的类支持拷贝操作，需要实现NSCopying协议。NSCopying协议只有一个协议方法： 12345@protocol NSCopying- (id)copyWithZone:(nullable NSZone *)zone;@end 若想使某个类支持拷贝功能，只需声明遵从NSCopying协议，copy方法由NSObject实现，但是真正需要我们实现的方法是- (id)copyWithZone:(nullable NSZone *)zone;。例如我们想拷贝一个如下对象： 1234@interface IChatBaseEntity : NSObject&lt;NSCopying&gt;@property (nonatomic,copy)NSString *uid;@property (nonatomic,copy)NSString *category;@end 那么在implementation中的方法如下： 12345678@implementation IChatBaseEntity- (id)copyWithZone:(NSZone *)zone &#123; IChatBaseEntity *entity = [[[self class]allocWithZone:zone] init]; entity.uid = _uid; entity.category = _category; return entity;&#125;@end 理解NSMutableCopyingNSMutableCoying也仅定义了一个方法： 12345@protocol NSMutableCopying- (id)mutableCopyWithZone:(nullable NSZone *)zone;@end mutablecopy方法与copy类似，只不过多了个可变的概念，如果你的类也分为不可变类和可变类，那么可以使用该方法。比如在上面的例子中我们增加了一个属性：@property (nonatomic,copy)NSArray *relations;当执行拷贝时仅仅拷贝uid属性和category属性，而执行深拷贝时拷贝uid，category和relations三个属性。 NSString的拷贝在上述的实例中我们在property中使用了copy属性，这意味着在使用时我们每次调用set方法时都会执行拷贝操作，这样我们可以保证数据的安全性。但是为什么要这样做，难道用strong不行么？我们先看下面的这个例子： 1234567891011NSString *str = @"imutableString"; NSMutableString *mstr = [[NSMutableString alloc]initWithString:@"mutableString"]; IChattBaseEntity *entity1 = [[IChattBaseEntity alloc]init]; entity1.uid = str; IChattBaseEntity *entity2 = [[IChattBaseEntity alloc]init]; entity2.uid = mstr; [str stringByAppendingString:@"1"]; [mstr appendString:@"1"]; NSLog(@"%@",entity1.uid); NSLog(@"%@",entity2.uid); 打印的结果如下： 12imutableStringmutableString1 在这里可以看到，我们并没有修改直接修改entity的uid的值，而是直接操作了字符串，但是entity的值却发生了变化，这并不是我们期望的，所以在属性中一般将NSString声明为copy属性，就是怕在一些未知的情况下发生了改变。对于NSMutableString和NSString类型，其copy方法总是返回一个不可变的字符串，而对于mutableCopy方法，总是返回一个可变的对象。 容器类的拷贝所谓的容器类（collection）,即集合类，像NSArray,NSSet，NSDictionay这种可以装载和处理其他对象的类。在Foundation中，所有的容器类在默认情况下都是执行浅拷贝，即无论是copy方法还是mutablecopy方法，即便是容器本身变成可变的还是不可变的，其内部装载的对象并没有执行拷贝操作，也就是说拷贝后的容器内的对象仍然指向拷贝前容器内的对象，并没有创建新的拷贝对象。而想要执行深拷贝（将容器内部的对象也执行一次拷贝操作）需要使用执行深拷贝的方法，例如NSArray中提供了一个深拷贝的方法：- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array copyItems:(BOOL)flag;。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS应用程序打包流程]]></title>
    <url>%2F2016%2F06%2F27%2FiOS-archive-app-and-patch-to-appstore%2F</url>
    <content type="text"><![CDATA[作为一名iOS开发工程师，打包ipa是开发中常用的一环，然而由于很多初次接触证书的初学者来说，打包的流程并不是很熟悉，以至于常常在项目中打包常常出现各种问题。 几个基本概念 开发者证书的类型apple的开发者证书大体分为两类：企业开发者证书和个人开发者证书。价格分别为$299，$99,企业开发者证书不可以上架appstore，不过可以在应用市场上发布企业级app，个人开发者证书可以上架appstore，不过不可以在自己的网站上发布通用的app。其中个人开发者证书又分为两种，个人(person)开发者和组织开发者(organization)。个人开发者可以升级为组织开发者，不过需要申请邓氏码，在apple的官网上可以找到申请的链接，大概10天左右的时间会下来。企业的开发者证书同样也需要申请邓氏码，在申请下来后需要再等2周才可以激活in-house的使用。 Certificates这里的Certificates指的是Certificates, Identifiers &amp; Profiles中的Certificates，当我们申请下来苹果的开发者后，会出现在account分栏下，点击即可进入查看Certificates。Certificates分为两类，测试证书(development)和生产证书(Production)。测试证书主要用做小范围测试用，测试证书主要包括用做打包ipa的证书和测试用的推送证书。生产证书的种类略多，不过常用的也是跟测试证书一样，一个打包的生产证书和一个生产环境的推送证书。 IdentifiersIdentifiers是一个身份标示，在Xcode中其实就是Bundle Identifier，这个标示着我们app的唯一性。所以在创建时，一般以反转的域名作为包名。创建appid时，我们可以在这里包含测试和生产使用的推送证书，以及应用内支付和一些其他的设置。 Devices这个就比较简单了，就是我们的设备，通过添加uuid可以把设备添加进来，在测试包含设备时可以包含进来。 Provisioning Profiles描述文件，其实就是将证书，配置信息以及包含的设备整合起来生成一个可以Xcode可读的配置文件。该配置文件在项目的Build Settings -&gt;Code Signing Identity中可以选择，在打包时，需要将程式的Bundle Id, team,以及该Profile保持一致，否则就会出现签名错误的问题。在创建描述文件时，apple会依据帐号类型的不同，提供不同类型的distribution描述文件，企业级开发证书会如下图所示:其中In House是生成无安装限制的企业描述文件，主要用于企业级app分发，Ad Hoc证书是生成的带有测试设备的测试证书，用于测试程式分发。个人开发证书如下： 打包的常见方式 通过archive打包 将configuration的run设置为release configuration，通过build生成.app文件，再将文件拖入到iTunes中生成ipa文件。 通过脚本打包。 将根开发证书共享给其他人在app开发中，可能会有多个iOS开发工程师共同开发的情形，这时候需要将开发证书共享给其他人，以方便其他人使用该证书进行真机测试以及打包。具有证书管理权的开发者应将其在certificate中创建的证书下载到本地，并安装至钥匙串，然后将具有权限的证书导出为p12证书，并设置密码分发给其他人。注意不要将证书的私钥导出，那样做毫无意义。。在需要导出的证书上右键选择导出证书，选择导出为个人信息交换证书。 如果你不知道自己打的包到底是什么configuration，那么可以去蒲公英分发测试上上传下应用这样就可以看到你打包的app是否是正确的了。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之理解对象的等同性]]></title>
    <url>%2F2016%2F06%2F23%2FiOS-understand-equal-in-object%2F</url>
    <content type="text"><![CDATA[两个对象是否相等是开发中经常遇到的问题，如果使用==判断两个对象是否指向同一个地址并不一定能满足有所有需求，两个对象相等的判定可能是其”uniqueId”是一致的。所以应该使用NSObject协议中声明的isEqual方法。 一般来说,即便创建了两个所有属性值都相同的对象，使用isEqual方法判定两个对象也依然不是等同的，因为isEqual的默认实现是当且仅当两个对象的指针值完全相等。若想自定义两个对象是否等同，需要制定一些规则，在何种方式下两个对象是等同的。 NSObject定义了两个用于判断对象是否相等的方法： 12- (BOOL)isEqual:(id)object;- (NSUInteger)hash; 如果isEqual判定两个对象相等，那么其hash值也必须返回同一个值。hash的默认实现方法类似于这样： 123- (NSUInteger)hash &#123; return (NSUInteger)self; &#125; 比如一个类是这样定义的： 123456789@interface UserEntity : NSObject &#123; char *_data; int _uid; NSMutableDictionary *_ext;&#125;@property (nonatomic,copy)NSString *userName;@property (nonatomic,copy)NSString *passWord;@end 那么其isEqual方法可以这样实现： 123456- (BOOL)isEqual:(UserEntity *)object &#123; return ([object isKindOfClass: [UserEntity class]] &amp;&amp; [object.userName isEqual:self.userName] &amp;&amp; [object.passWord isEqual:self.userName] &amp;&amp; object-&gt;_uid == self-&gt;_uid);&#125; 在hash方法中可以这样实现： 123- (NSUInteger)hash &#123; return [_userName hash]^[_passWord hash]^_uid;&#125; 需要注意的是，该hash算法可能会产生一定的碰撞，也就是说不保证一定会生成一个唯一的哈希码，这里我们可以参考这篇文章的实现：implementing-equality-and-hashing 123456 #define NSUINT_BIT (CHAR_BIT * sizeof(NSUInteger)) #define NSUINTROTATE(val, howmuch) ((((NSUInteger)val) &lt;&lt; howmuch) | (((NSUInteger)val) &gt;&gt; (NSUINT_BIT - howmuch)))- (NSUInteger)hash &#123; return NSUINTROTATE([_userName hash], NSUINT_BIT / 2) ^ [_passWord hash]^_uid;&#125; 另外还需要注意的是，如果我们使用了继承子类和父类做比较，那么UserEntity类的isEqual方法可能需要判断两个对象是否是父子关系，而不是仅仅判断是否是同一个类。 在一些容器类中，会使用isEqual方法判断两个对象是否相等，比如NSArray的- (NSUInteger)indexOfObject:(ObjectType)anObject;,NSMutableSet类的- addObject方法。如果在使用时可变容器时，我们修改了已经存在于容器中的元素的值导致了该元素与其他元素的hash值相同，那么将会造成一些无法预知的隐性错误。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之运行时(二)]]></title>
    <url>%2F2016%2F06%2F19%2FiOS-runtime-tutorial-2%2F</url>
    <content type="text"><![CDATA[理解objc_msgSend在对象中调用方法是Objective-C中经常使用的功能，在iOS中术语叫做消息传递机制。例如[someObj doSomeThing];,其中someObj叫做消息的“接收者”，doSomeThing叫做选择子(@selector:)，在传递消息时可以携带一些参数，可以有返回值。编译器在看到该消息时，会将其转化为一条标准的C语言函数调用，即objc_msgSend，其原型如下： 1objc_msgSend(someObj,@selector(doSomeThing)); objc_msgSend函数会依据接收者与选择子的类型来进行调度方法。 首先运行时系统会在接收者所属类的方法列表里搜寻与该方法相匹配的方法，即struct objc_method_list **methodLists方法列表中匹配的方法，如果有该函数的实现，那么就直接调用该方法(IMP对应的指针地址)。 如果找不到与之相匹配的会沿着该类的集成体系，继续向父类寻找该消息，直至到根类。 如果该消息仍然匹配不到任何匹配的方法，那么这时候运行时系统会将该消息进行消息转发(message forward)操作。 如果仍然无法处理该消息，则会调用该类的- (void)doesNotRecognizeSelector:(SEL)aSelector;,NSObject在该方法的默认实现是抛出异常，所以如果我们向对象发送一个无法解析的消息时，会引起程序的崩溃。 理解消息转发机制在无法找到消息对应的选择子后，会启动消息转发机制。消息转发分为两个阶段： 首先，运行时系统会先询问该方法是否可以动态解析：即动态的为类或实例添加方法。在上一节中我们已经提到了如何为类或实例添加方法。在此阶段，对象先调用所属类的+ (BOOL)resolveInstanceMethod:(SEL)selector方法，所以我们可以在这里动态的为函数添加实现方法。 如果在转发消息的第一步仍然不能处理该消息，接收者还有第二次处理selector的机会，这是，对象会调用- (id)forwardingTargetForSelector:(SEL)aSelector;方法，返回的id为消息的其他备援对象。通过这种机制，我们可以模拟实现多播代理技术,如果对该特性感兴趣，可以参考我之前写过的博客:iOS多播代理 如果消息到这里时仍然未能处理，那么系统将会启动完整的转发机制，此步骤会调用- (void)forwardInvocation:(NSInvocation *)anInvocation方法,runtime会将target，action，以及参数全部封装在一个Invocation中，执行消息转发，我们可以在该函数中将消息转发给其他对象，如: 1234567- (void)forwardInvocation:(NSInvocation *)anInvocation &#123; if ([B respondsToSelector:[anInvocation selector]) &#123; [anInvocation B]; &#125; else &#123; [super forwardInvocation:anInvocation]; &#125;&#125; 在重写了该函数之后还需要处理- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector方法： 12345678- (NSMethodSignature*)methodSignatureForSelector:(SEL)selector &#123; NSMethodSignature* signature = [super methodSignatureForSelector:selector]; if (!signature) &#123; signature = [B methodSignatureForSelector:selector]; &#125; return signature;&#125; 运行时转发流程下面是一个运行时完整的转发流程图。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>运行时技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebViewJavascriptBridge使用指南]]></title>
    <url>%2F2016%2F06%2F15%2FiOS-bridge-between-iOS-and-javascript-with-webviewjavascriptbridge%2F</url>
    <content type="text"><![CDATA[对于原生的app开发，常常需要在app中增加一些活动界面或者是广告消息等界面，这些界面常常需要动态更新，所以很多时候我们都会选择使用Webview去处理这种活动页面，而在这些界面中，难免会遇到一些js与native数据需要交互的场景。选择Cordova作为这种简单js与native交互的框架有些太繁重了，如果你的业务量并不大，native与js在webview间的数据交互并不是很多，那么可以采用WebViewJavascriptBridge框架作为iOS端的混合开发框架。 安装 Cocoapods安装是不二的选择:pod &#39;WebViewJavascriptBridge&#39;, &#39;~&gt; 5.0&#39; native端。 导入头文件：#import &lt;WKWebViewJavascriptBridge.h&gt; 开启日志：[WebViewJavascriptBridge/WKWebViewJavascriptBridge enableLogging]; 添加代理：webviewJavaScriptBridge支持UIWebview和WKWebview两种Webview，前者的使用版本更老些，不过内存泄漏比较严重，后者仅支持iOS8以上。对于UIWebview： 1self.bridge = [WebViewJavascriptBridge bridgeForWebView:webView]; 对于WKWebview： 1self.bridge = [WKWebViewJavascriptBridge bridgeForWebView:webView]; 监听webview的回调：WebViewJavascriptBridge会劫持webview的delegate，所以在注册了代理之后，我们不能在设置webview的delegate为self了，如果你想在Webview加载完成或者开始加载网页的时候做一些其它的处理（比如加载框，统计等等），那么你需要将设置bridge的代理为self就可以了： 1[self.bridge setWebViewDelegate:self]; 这样监听到的回调就会按照这样的顺序去处理 ：js-&gt;native-&gt;bridge-&gt;代理回调。 JS唤起Native方法：Native端： 12[self.bridge registerHandler:@"&lt;functionName&gt;" handler:^(NSDictionary* data, WVJBResponseCallback responseCallback) &#123;&#125;]; “functionName”为js端调用的方法名称，传入的参数在data中，responseCallback作为返回的回调函数。responseCallback的定义如下:typedef void (^WVJBResponseCallback)(id responseData) JS端：JS 端需要插入如下函数： 123456789101112 function setupWebViewJavascriptBridge(callback) &#123; if (window.WebViewJavascriptBridge) &#123; return callback(WebViewJavascriptBridge); &#125; if (window.WVJBCallbacks) &#123; return window.WVJBCallbacks.push(callback); &#125; window.WVJBCallbacks = [callback]; var WVJBIframe = document.createElement('iframe'); WVJBIframe.style.display = 'none'; WVJBIframe.src = 'wvjbscheme://__BRIDGE_LOADED__'; document.documentElement.appendChild(WVJBIframe); setTimeout(function() &#123; document.documentElement.removeChild(WVJBIframe) &#125;, 0)&#125; 调用方法如下： 1234567function clickAction() &#123; setupWebViewJavascriptBridge(function(bridge) &#123; bridge.callHandler('&lt;functionName&gt;', &#123;'key':'value'&#125;, function responseCallback(responseData) &#123; console.log("JS received response:", responseData) &#125;) &#125;)&#125; 在JS端和Native端的functionName要对应上，在JS端我们可以传入需要传入的参数（Dictionary）。在setupWebViewJavascriptBridge方法中可以发现，Bridge在Webview中插入一个隐藏的iframe，其scheme头为wvjbscheme(这样做是为了在native端作为标识符便于识别),在native端会唤起webview的delegate回调方法，进入bridge的逻辑判断中。 Native调用JS端的方法： 与JS端调用Native端类似，只不过是方法名字变了下： Native 端 12[self.bridge callHandler:@"&lt;Name&gt;" responseCallback:^(id responseData) &#123;&#125;]; javascript端 123bridge.registerHandler('&lt;Name&gt;', function(data, responseCallback) &#123; responseCallback(data)&#125;) 需要注意的是，所有bridge的回调函数都是在主线程上，所以在接收到handler时，不应在block中执行耗时的操作。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开源框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之运行时(一)]]></title>
    <url>%2F2016%2F06%2F13%2FiOS-runtime-tutorial%2F</url>
    <content type="text"><![CDATA[什么是runtime在学习runtime之前，我们首先要理解什么是runtime。简单的说，Objective-C runtime是一个实现Objective-C语言的C库。Objective-C是C的超集，对象可以用C语言中的结构体表示，而方法（methods）可以用C函数实现。这些结构体和函数被runtime函数封装后，可以在程序运行时创建、检查、修改类，对象和它们的方法。除了封装，运行时机制还负责在运行时环境下的消息传递和转发。可以说，运行时是Objective-C的基础，使其有了面向对象的能力。 Objective-C Runtime目前有两个版本：Modern runtime和Legacy runtime。Modern Runtime 覆盖了64位的Mac OS X Apps，还有iOS Apps，Legacy Runtime是早期用来给32位 Mac OS X Apps 用的。所以目前使用的基本都是Modern runtime版本，即__OBJC2__。 类与对象类在Objective-C中类和对象其实都是结构体指针，只不过这些结构体内的一些东西并不是透明的，在objc/objc.h中是如下定义Class的: 1typedef struct objc_class *Class; 在objc/runtime.h中结构体声明如下： 12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY;#if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;#endif&#125; OBJC2_UNAVAILABLE;/* Use `Class` instead of `struct objc_class *` */ super_class 类结构体中有一个同类型的指针，其指向自己的父类，这样就可以将类的继承关系建立起来了。NSObject或NSProxy的super_class为NULL。 const char *name 常字符串指针，代表了类名信息。 long instance_size 类实例变量的大小，在创建实例时可以获取需要开辟的空间大小。 struct objc_ivar_list *ivars 该类的成员变量链表。 struct objc_method_list **methodLists 方法定义的链表。 struct objc_cache *cache 方法缓存。在Objective-C中由于采用了消息传递机制，在运行速度上比不上静态绑定的函数调用操作，所以使用方法缓存机制对调用频繁的方法加以缓存。后面再详细介绍。 struct objc_protocol_list *protocols 协议链表 Class isa OBJC_ISA_AVAILABILITY;所有的类自身也是一个对象(该对象是一个单例)，这个对象的Class里面也有一个isa指针，它指向metaClass(元类)。元类用来表述类对象本身具备的元数据，每个类仅有一个“类对象”，而每个类仅有一个与之相关的元类。任何NSObject继承体系下的meta-class都使用NSObject的meta-class作为自己的所属类，而基类的meta-class的isa指针是指向它自己。这样就形成了一个完美的闭环。 实例(对象)在objc/objc.h中是如下定义id类型的对象: 12345/// A pointer to an instance of a class.typedef struct objc_object *id;struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;; 可以看到，这个结构体只有一个指向其类的isa指针。这样，当我们向一个Objective-C对象发送消息时，运行时库会根据实例对象的isa指针找到这个实例对象所属的类。runtime会在类的方法列表及父类的方法列表中去逐一寻找与消息对应的selector指向的方法。找到后即运行这个方法。 objc_cache方法缓存在runtime.h中方法缓存结构体时如下定义的： 123456789101112131415typedef struct objc_cache *Cache OBJC2_UNAVAILABLE;#define CACHE_BUCKET_NAME(B) ((B)-&gt;method_name)#define CACHE_BUCKET_IMP(B) ((B)-&gt;method_imp)#define CACHE_BUCKET_VALID(B) (B)#ifndef __LP64__#define CACHE_HASH(sel, mask) (((uintptr_t)(sel)&gt;&gt;2) &amp; (mask))#else#define CACHE_HASH(sel, mask) (((unsigned int)((uintptr_t)(sel)&gt;&gt;3)) &amp; (mask))#endifstruct objc_cache &#123; unsigned int mask /* total = mask + 1 */ OBJC2_UNAVAILABLE; unsigned int occupied OBJC2_UNAVAILABLE; Method buckets[1] OBJC2_UNAVAILABLE;&#125;; 该结构体的字段描述如下： mask：一个整数，指定分配的缓存bucket的总数。在方法查找过程中，Objective-C runtime使用这个字段来确定开始线性查找数组的索引位置。指向方法selector的指针与该字段做一个AND位操作(index = (mask &amp; selector))。这可以作为一个简单的hash散列算法。 occupied：一个整数，指定实际占用的缓存bucket的总数。 buckets：指向Method数据结构指针的数组。这个数组可能包含不超过mask+1个元素。需要注意的是，指针可能是NULL，表示这个缓存bucket没有被占用，另外被占用的bucket可能是不连续的。这个数组可能会随着时间而增长。 objc_ivar_list 变量列表12345678struct objc_ivar_list &#123; int ivar_count OBJC2_UNAVAILABLE;#ifdef __LP64__ int space OBJC2_UNAVAILABLE;#endif /* variable length structure */ struct objc_ivar ivar_list[1] OBJC2_UNAVAILABLE;&#125; category 类目1234567struct objc_category &#123; char *category_name OBJC2_UNAVAILABLE; char *class_name OBJC2_UNAVAILABLE; struct objc_method_list *instance_methods OBJC2_UNAVAILABLE; struct objc_method_list *class_methods OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;&#125; category_name 并不是category小括号里写的名字，而是类的名字 class_name 要扩展的类对象，编译期间这个值是不会有的，在app被runtime加载时才会根据name对应到类对象. instance_methods 实例方法 class_methods 类方法 protocols 遵循协议 协议列表12345struct objc_protocol_list &#123; struct objc_protocol_list *next; long count; Protocol *list[1];&#125;; 协议的结构体是一个链表。 使用runtime获取类和对象的信息 获取对象的类。 1Class object_getClass(id obj); 判断对象是否是某个类。 1BOOL object_isClass(id obj); 获取对象的类名。 1const char *object_getClassName(id obj); 改变对象的类名。 1Class object_setClass(id obj, Class cls); 获取一个类的父类。 1Class class_getSuperclass(Class cls); 在运行时环境下创建一个类。 12Class objc_allocateClassPair(Class superclass, const char *name, size_t extraBytes) 需要传入的参数：父类，类的名字，额外的字节大小(通常传入0即可)。如果父类传入了nil，那么将创建一个新的根类。 使用runtime操作方法 首先需要了解几个名词 IMP。IMP就是Implementation的缩写，顾名思义，它是指向一个方法实现的指针，每一个方法都有一个对应的IMP。默认情况下IMP被定义为无参数无返回值的函数。所以你需要到工程里搜索到这个选项并把它关闭，需要在Preprocessing设置中关闭Enable Strict Checking of objc_msgSend Calls选项。第一个参数是指向对象自身的指针(self)，第二个参数是方法选择器，然后是方法的实际参数。IMP的定义如下： 12345if !OBJC_OLD_DISPATCH_PROTOTYPEStypedef void (*IMP)(void /* id, SEL, ... */ );elsetypedef id (*IMP)(id, SEL, ...);endif SEL。SEL被称作选择子,是OC中对应的方法名，是对方法的一种包装。SEL的声明如下 typedef struct objc_selector *SEL，并没有给出objc_selector的内部样子…. Method。Method可以理解为IMP和SEL的一个封装。在SDK中是如下定义的： 1234567typedef struct objc_method *Method;struct objc_method &#123; SEL method_name char *method_types IMP method_imp &#125; Method转换为IMP、SEL。 Method-&gt;IMP 1IMP method_getImplementation(Method m) Method -&gt;SEL 1SEL method_getName(Method m) 获取类或实例的方法 123456- 获取实例方法Method class_getInstanceMethod ( Class cls, SEL name );- 获取类方法Method class_getClassMethod ( Class cls, SEL name );- 获取类中的所有方法Method * class_copyMethodList ( Class cls, unsigned int *outCount ); 为类或实例添加方法。 12BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) cls:需要添加方法的类。 name:方法的选择子，即 [obj dosomething]中的something。 imp: 方法的实现。 types:函数的类型。函数的类型主要包括两个：返回值类型和传入的参数。在apple的Library中有如下定义： 123456789101112131415161718192021222324c :A chari :An ints :A shortl :A long //l is treated as a 32-bit quantity on 64-bit programs.q :A long longC :An unsigned charI :An unsigned intS :An unsigned shortL :An unsigned longQ :An unsigned long longf :A floatd :A doubleB :A C++ bool or a C99 _Boolv :A void* :A character string (char *)@ :An object (whether statically typed or typed id)# :A class object (Class): :A method selector (SEL)[array type] : An array&#123;name=type...&#125; : A structure(name=type...) : A unionbnum : A bit field of num bits^type :A pointer to type? :An unknown type (among other things, this code is used for function pointers) 比如我们要创建一个 + dosomething:(NSString *)str的方法，那么对应的IMP函数的写法类似于这样： 123void dosomething(id self,SEL _cmd,NSString *str) &#123; NSLog("dosomething");&#125; 传入的types为v@:@,其中v代表void，第一个@代表id self，:代表SEL _cmd,第二个@代表NSString类型的str。这里再补充一点，当类或实例的方法是在父类中实现的，那么添加方法会覆盖父类中的实现，而如果在本类中已有该方法的实现，那么添加方法的返回值是NO，这个时候我们应该去动态的替换该方法。 动态替换类或实例的方法(Method Swizzling) 12IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) 方法替换是runtime常用的一种技术手段，在很多开源库里都可以看到它的身影，在后面的具体实例中会具体分析。 使用runtime获取类中的属性这部分参考自南峰子的博客在实际开发中个人并不常使用这种方式获取属性信息。 123456789101112131415161718// 获取类中指定名称实例成员变量的信息Ivar class_getInstanceVariable ( Class cls, const char *name );// 获取类成员变量的信息Ivar class_getClassVariable ( Class cls, const char *name );// 添加成员变量BOOL class_addIvar ( Class cls, const char *name, size_t size, uint8_t alignment, const char *types );// 获取整个成员变量列表Ivar * class_copyIvarList ( Class cls, unsigned int *outCount );- class_getInstanceVariable函数，它返回一个指向包含name指定的成员变量信息的objc_ivar结构体的指针(Ivar)。- class_getClassVariable函数，目前没有找到关于Objective-C中类变量的信息，一般认为Objective-C不支持类变量。注意，返回的列表不包含父类的成员变量和属性。 Objective-C不支持往已存在的类中添加实例变量，因此不管是系统库提供的提供的类，还是我们自定义的类，都无法动态添加成员变量。但如果我们通过运行时来创建一个类的话，又应该如何给它添加成员变量呢？这时我们就可以使用class_addIvar函数了。不过需要注意的是，这个方法只能在objc_allocateClassPair函数与objc_registerClassPair之间调用。另外，这个类也不能是元类。成员变量的按字节最小对齐量是1&lt;&lt;alignment。这取决于ivar的类型和机器的架构。如果变量的类型是指针类型，则传递log2(sizeof(pointer_type))。 class_copyIvarList函数，它返回一个指向成员变量信息的数组，数组中每个元素是指向该成员变量信息的objc_ivar结构体的指针。这个数组不包含在父类中声明的变量。outCount指针返回数组的大小。需要注意的是，我们必须使用free()来释放这个数组。 实战参考 动态创建类，获取类的父类，meta-class等。 123456789101112131415161718192021222324252627282930313233int testFunction(id obj, SEL _cmd)&#123; NSLog(@"current obj pointer is %p \n \ obj Class:%@, obj super Class:%@",obj,[obj class],[obj superclass]); Class currentClass = [obj class]; for( int i = 1; i &lt; 5; ++i ) &#123; NSLog(@"Following the isa pointer %d times gives %p",i,currentClass); NSLog(@"current class name:%@,meta-class:%@",currentClass,objc_getMetaClass([NSStringFromClass(currentClass) cStringUsingEncoding:NSUTF8StringEncoding])); currentClass = object_getClass(currentClass); &#125; NSLog(@"NSObject's class is %p", [NSObject class]); NSLog(@"NSObject's meta class is %p",object_getClass([NSObject class])); return 1;&#125;int main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... NSLog(@"Hello, World!"); Class aClass = objc_allocateClassPair([NSData class], "aClass", 0);#pragma clang diagnostic push#pragma clang diagnostic ignored"-Wundeclared-selector" class_addMethod(aClass, @selector(test), (IMP)testFunction, "i@:"); objc_registerClassPair(aClass); id obj = [[aClass alloc]init]; [obj performSelector:@selector(test)];#pragma clang diagnostic pop &#125; return 0;&#125; 打印结果如下： 123456789101112132016-06-13 13:42:12.446 testExample[39759:328465] Hello, World!2016-06-13 13:42:16.109 testExample[39759:328465] current obj pointer is 0x1002005a0 obj Class:aClass, obj super Class:NSData2016-06-13 13:42:16.109 testExample[39759:328465] Following the isa pointer 1 times gives 0x1002003402016-06-13 13:42:16.110 testExample[39759:328465] current class name:aClass,meta-class:aClass2016-06-13 13:42:16.110 testExample[39759:328465] Following the isa pointer 2 times gives 0x1002003702016-06-13 13:42:16.110 testExample[39759:328465] current class name:aClass,meta-class:aClass2016-06-13 13:42:16.110 testExample[39759:328465] Following the isa pointer 3 times gives 0x7fff7a84c1182016-06-13 13:42:16.110 testExample[39759:328465] current class name:NSObject,meta-class:NSObject2016-06-13 13:42:16.110 testExample[39759:328465] Following the isa pointer 4 times gives 0x7fff7a84c1182016-06-13 13:42:16.110 testExample[39759:328465] current class name:NSObject,meta-class:NSObject2016-06-13 13:42:16.110 testExample[39759:328465] NSObject's class is 0x7fff7a84c0f02016-06-13 13:42:16.110 testExample[39759:328465] NSObject's meta class is 0x7fff7a84c118 方法替换(Method Swizzling)在此例中我们截取UIViewController的viewWillAppear方法为例。 1234567891011121314151617181920212223242526272829303132333435@implementation UIViewController (Swizzle)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(rd_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)rd_viewWillAppear:(BOOL)animated &#123; [self rd_viewWillAppear:animated]; NSLog(@"you can do something here");&#125; 利用Method Swizzle可以达到很多事半功倍的效果，如果你想了解更多Method Swizzle的内容可以参考这个开源类库Aspects 参考链接 objective-c-runtime-yun-xing-shi-zhi-lei-yu-dui-xiang Objective-C Runtime Programming Guide]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>运行时技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa的使用（二）]]></title>
    <url>%2F2016%2F06%2F06%2FiOS-ReactiveCocoa-tutorial-advance%2F</url>
    <content type="text"><![CDATA[本文继续介绍ReactiveCocoa的使用。理解Connections在RAC中，RACMuticastConnection类代表了连接，signal默认情况下是冷信号，这意味着如果没有subsription，信号就不会成为热信号，这种行为通常是正确的，因为它意味着每当有新订阅者订阅时，都会重新计算数据，然而这种行为也带来了一定的副作用。connection通过RACSignal的-publish 或者 -multicast:方法创建，可以确保被subscribe多次也只执行一次，我们只需要将这些订阅连接起来。使用publish方法连接： 1234567891011121314RACSignal *signal = [[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@(1)]; return nil; &#125;] doNext:^(id x) &#123; NSLog(@"Do Next"); &#125;];RACMulticastConnection *connection = [signal publish];[connection.signal subscribeNext:^(id nextValue) &#123; NSLog(@"First %@", nextValue);&#125;];[connection.signal subscribeNext:^(id nextValue) &#123; NSLog(@"Second %@", nextValue);&#125;];[connection connect]; 打印结果类似如下 123Do NextFirst 0Second 0 与connection实现效果类似的是RACSignal的replay方法，replay方法将返回一个新的信号，当源信号被订阅时，会立即发送给订阅者全部历史的值，不会重复执行源信号中的订阅代码，不仅如此，订阅者还将收到所有未来发送过去的值。将上面的例子改成如下： 12345678910111213RACSignal *signal = [[[RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@(0)]; return nil; &#125;] doNext:^(id x) &#123; NSLog(@"Do Next");&#125;] replay];[signal subscribeNext:^(id nextValue) &#123; NSLog(@"First %@", nextValue);&#125;];[signal subscribeNext:^(id nextValue) &#123; NSLog(@"Second %@", nextValue);&#125;]; 在RACSignal的源码中我们看到replay方法的实现： 12345678- (RACSignal *)replayLast &#123; RACReplaySubject *subject = [[RACReplaySubject replaySubjectWithCapacity:1] setNameWithFormat:@"[%@] -replayLast", self.name]; RACMulticastConnection *connection = [self multicast:subject]; [connection connect]; return connection.signal;&#125; 在RACSignal中还有一个replaylast方法，replayLast返回一个新的信号，当源信号被订阅时，会立即发送给订阅者最新的值，不会重复执行源信号中的订阅代码。订阅者还会收到信号未来所有的值。这里就不再举出例子了。 replayLazily方法返回一个新的信号，会提供所有的值给订阅者。，当源信号被订阅时，会立即发送给订阅者全部历史的值，不会重复执行源信号中的订阅代码。跟replay不同的是，replayLazily被订阅生成新的信号之前是不会对源信号进行订阅的. RAC中的序列RACSequence代表RAC中的集合类，用于替代NSArray,NSDictionary等容器类，RAC通过添加-rac_sequence方法来使RACSequence代替Cocoa中的容器类。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开源框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReactiveCocoa使用入门]]></title>
    <url>%2F2016%2F06%2F04%2FiOS-ReactiveCocoa-tutorial-started%2F</url>
    <content type="text"><![CDATA[引语ReactiveCocoa(RAC)是一个有GitHub工程师开源的一套应用于iOS和OS X开发的新框架，本篇blog将简单介绍如何使用ReactiveCocoa处理UI层的响应事件。 使用RAC监听UITextfield在开发中我们常常会遇到这样的需求，当用户输入了一些内容后需要判断用户的输入是否合法，依据其输入的内容决定处理逻辑。比如用户注册和登录，我们需要判断其输入的账号是否含有非法字符，判断密码长度是否符合要求。在搜索界面，我们需要根据用户输入的内容进行联想搜索。如果按照通常的思路，我们会通过UITextField的delegate方法监听用户的输入内容，或是根据KVO监听文本的变化，而处理的事件通通的放在了VC中。如果我们的某个界面上有多个UITextField，那么在处理的逻辑中，需要判断究竟是哪个Textfield，根据textfield的不同做不同的事件处理。于是乎我们的处理逻辑会变成这样： 12345678910- (BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string &#123; if (textField == mytextfield1) &#123; //do something [self dosomething1WithText:textfield.text]; &#125;else if(textField == mytextfield2) &#123; //do something [self dosomething2:textField.text]; &#125;... return YES;&#125; 当处理的逻辑越来越多，VC会变得越来越重，逻辑的处理也开始变得麻烦起来。下面看看使用RAC如何处理这些逻辑。 RAC监听UITextfield的变化：123[self.textfield.rac_textSignal subscribeNext:^(NSString* text) &#123; NSLog(@"%@",text); &#125;]; 使用过滤器过滤出满足条件的事件：使用RACSignal的- (instancetype)filter:(BOOL (^)(id value))block;方法过滤出满足条件的事件。 12345[[self.textfield.rac_textSignal filter:^BOOL(NSString * text) &#123; return @([text isPhoneNumber]);&#125;] subscribeNext:^(NSString *phoneNumber) &#123; NSLog(@"%@",phoneNumber);&#125;]; 这样我们就把不同的textfield的事件分开了，甚至我们连代理都没有去写。 map处理除此之外，我们还可以使用- (instancetype)map:(id (^)(id value))block方法处理事件的数据，在map方法的返回结果中我们可以返回id类型的结果，并在filter传入的参数中给定并进行过滤处理。 1234567[[[self.textfield.rac_textSignal map:^id(NSString *text) &#123; return [text stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]]; &#125;] filter:^BOOL(NSString * trimmedStr) &#123; return [trimmedStr isPhoneNumber]; &#125;] subscribeNext:^(NSString *resultStr) &#123; //do something &#125;]; 使用RAC处理UIButton的响应事件12345[[[self.feedButton rac_signalForControlEvents:UIControlEventTouchUpInside] doNext:^(UIButton * btn) &#123; //do something with button &#125;] subscribeNext:^(id x) &#123; //do something when button touchupinside &#125;]; 使用RAC处理UIAlertView的代理响应事件UIAlertView的代理方法有多个，RAC仅仅给出了两个代理事件的处理，alertView:clickedButtonAtIndex:和alertView:willDismissWithButtonIndex:，其余的方法如有必要我们可以按照这两个方法进行补全，使用方法如下： 12345678UIAlertView *alert = [[UIAlertView alloc]initWithTitle:@"alert" message:@"message" delegate:nil cancelButtonTitle:@"取消" otherButtonTitles:@"确定", nil]; [alert.rac_willDismissSignal subscribeNext:^(NSNumber *index) &#123; NSLog(@"%@",index); &#125;]; [alert.rac_buttonClickedSignal subscribeNext:^(NSNumber *index) &#123; NSLog(@"%@",index); &#125;]; [alert show]; 使用RAC处理手势响应事件12345UITapGestureRecognizer *tap = [[UITapGestureRecognizer alloc]init];[tap.rac_gestureSignal subscribeNext:^(UITapGestureRecognizer *ges) &#123; NSLog(@"%@",ges);&#125;];[self.view1 addGestureRecognizer:tap]; 使用RAC监听某些值变化时UI层做出响应12345678RACSignal *signal = [RACSignal createSignal:^RACDisposable *(id&lt;RACSubscriber&gt; subscriber) &#123; [subscriber sendNext:@(self.isLoggin)]; [subscriber sendCompleted]; return nil; &#125;]; RAC(self.view1,hidden) = [signal map:^id(NSNumber *loggedIn) &#123; return loggedIn ; &#125;]; 监听某些值变化时，首先要创建一个信号量(RACSignal)，然后在subscriber中放入要传递到下一事件中的数据(sendNext:),使用RAC这个宏方法来处理信号量中要处理的UI层响应。 RAC框架概览这里提供一张ReactiveCocoa的类关系图 Streams流 Streams 表现为RACStream类，可以看做是流程中中里面流动的一系列事件，它们有顺序的依次通过，在第一个事件没有完成之前，你没法进行第二个。RACStream描述的就是这种线性的事件流的形态，比较抽象，它本身的使用意义并不很大，一般会以signals或者sequences等这些更高层次的表现形态代替。 信号量Signal。 在RAC中RACSiganl类代表了信号类，继承自RACStream只要有信号数据改变，内部就会接收到数据，并马上发出数据。RACSignal中的一些常用方法： 12345678910//创建信号量 + (RACSignal *)createSignal:(RACDisposable * (^)(id&lt;RACSubscriber&gt; subscriber))didSubscribe;//订阅信号- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock;- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock completed:(void (^)(void))completedBlock;- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock error:(void (^)(NSError *error))errorBlock completed:(void (^)(void))completedBlock;//发送信号- (void)sendNext:(id)value; 需要注意的是每次创建的信号(create方法)都是生成一个冷(Cold)信号，即便值发生了改变也不会有任何响应，而只有当订阅了该信号(subscribeNext:)后，信号才会成为一个热(hot)信号，值改变就会触发。 订阅者。 RACSubscriber表示订阅者的意思，确切的讲，RACSubscriber应该描述成一个协议，即满足该协议方法的任何类皆可以成为订阅者。每个创建的信号都会有一个订阅者来协助其发送数据，我们可以根据不同的逻辑，发送不同的事件,RACSubscriber协议的方法如下： 12345- (void)sendNext:(id)value- (void)sendError:(NSError *)errr; - (void)sendCompleted; 一个生命周期的Signal可以发送任意多个“next”事件，和一个“error”或者“completed”事件（当然“error”和“completed”只可能出现一种) 取消订阅。 RACDisposable类用于取消订阅和清理资源，在订阅者发出完成或者Error事件后会触发，可用于主动取消订阅某信号。常用方法: 12+ (instancetype)disposableWithBlock:(void (^)(void))block;- (void)dispose; RACSubjects(不知道应该怎么翻译) RACSubject可以认为是“可变的（mutable）”信号/自定义信号，它是嫁接非RAC代码到Signals世界的桥梁，很有用。它可以当信号的提供者也可以发送信号。可以看下其头文件是如下定义的： 1234567/// A subject can be thought of as a signal that you can manually control by sending next, completed, and error. They're most helpful in bridging the non-RAC world to RAC, since they let you manually control the sending of events.@interface RACSubject : RACSignal &lt;RACSubscriber&gt;/// Returns a new subject.+ (instancetype)subject;@end RAC中的控制流。 RACCommand:RAC中用于处理事件的类，可以把事件如何处理,事件中的数据如何传递，包装到这个类中，他可以很方便的监控事件的执行过程。使用方法如下： 12341. 创建命令- initWithSignalBlock:(RACSignal * (^)(id input))signalBlock2. 在signalBlock中，创建RACSignal，并且作为signalBlock的返回值3. 执行命令 - (RACSignal *)execute:(id)input 在使用时需要注意以下几点： signalBlock必须要返回一个信号，不能传nil。 如果不想要传递信号，直接创建空的信号[RACSignal empty]； RACCommand中信号如果数据传递完，必须调用[subscriber sendCompleted]，这时命令才会执行完毕，否则永远处于执行中。 RACCommand需要被强引用，否则接收不到RACCommand中的信号，因此RACCommand中的信号是延迟发送的。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开源框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目总结－啄米app]]></title>
    <url>%2F2016%2F05%2F30%2FiOS-joinme-expirience%2F</url>
    <content type="text"><![CDATA[有近一个多月没有更新博客了，大部分的时间都耗在了项目上。下面就谈谈在app中走过的那些路吧。 从UIWebview到WKWebview忘记什么时候开始，纯正的iOS native开发需求变的越来越小了，主要原因还是开发时间过长和上架更新慢。webapp由于其开发周期短，更新换代快，受到了大型企业的推崇（大企业主要是业务多）。但是webapp在移动端的体验性并不出色，并且其本身还有诸多限制因素。之前做的webapp开发大多采用的是基于cordova的混合开发，包括worklight，由于UIWebview本身存在内存泄漏的问题，导致了app在启动之初便占用了80+的内存。更别提其他的一些尚未加载的数据了。所以在这个app中有意的去尝试了下使用基于Webkit框架的WKWebview进行混合开发。WKWebview在性能上还是稍好一些的，不过回调方式和缓存处理与UIWebview存在很大的差异。 交互与回调方式UIWebview通过stringByEvaluatingJavaScriptFromString方法执行一段js代码，通过webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType方法可以实现从js调用native方法，这也是cordova的实现机制，通过插入一个iframe来实现调用native的方法。相比于UIWebview，WKWebview通过- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler可以实现js与native的交互，WKNavigationActionPolicy仅有两种选择，要么webview去跳转，要么不跳转而由开发者决定应该如何去处理请求。向WKWebview插入执行一段js代码比较复杂，在初始化WKWebview的时候应该对其configuration进行初始化，WKWebViewConfiguration的userContentController是控制插入脚本的管理者。对于UIWebview，使用cordova进行开发是不错的选择，而对于WKWebview，则可以使用webviewjavascriptbridge这个开源框架进行开发。 导航监听与网页标题监听WKWebview将网页的标题与进度添加为属性，这样我们可以通过observer来监听网页标题的改变和并自己定制进度条。 警告框UIWebview的警告框不需要做处理，不过也无法自定制警告框，而WKWebview将方法写成了代理，由开发者自己决定应该怎样去处理弹出的警告框。 － 打电话等url事件。在UIWebview中用户点中了某个电话会弹出警告框是否拨打电话，由于WKWebview的监听回调仅有跳转与不跳转两种，所以警告框等逻辑需要我们自己去写，简单的做法就是监听到tel:后，直接创建一个UIWebview去执行该url。 集成即时通讯之前集成即时通讯一直使用的是环信的，这次也不例外，不过这次由于使用了自己的用户体系，所以集成起来略显麻烦，由于环信的UI是作为一个project放在整个项目中的，然而环信的工程中使用了一些第三方库如SDWebImage等是无法再通过pod引用到workspace中的，否则会引发冲突，而且环信的工程中一些样式设计并不符合项目的设计，所以改动比较大。 图片浏览与上传很少有碰到在app中上传高清原图这种需求的，并且是多张上传，原因很简单－－4G的网络并不稳定。在app中使用了AssetsLibrary库来加载本地图片库，网络图片缓存和加载仍然使用SDWebImage，在使用瀑布流加载本地图片时一定记得不要直接加载原图，因为一张图片的大小高达5M，几十张图片就会导致内存直接撑爆了，所以Cell中的model直接携带了ALAsset，并仅在聚合页面加载小图。只有在高清图片显示时，才去加载原图。ALAsset中thumbnail方法返回的时缩略图的CGImageRef，可以转换成UIImage。上传时，需要给出图片的MIME类型，png或是jpg。多张图片上传并没有采用并发机制一起上传，而是放到了一个串行队列中一张张上传，有优点也有缺点吧，后期可能会改用并行队列来写，不过在线程的取消操作上可能会有些麻烦了。 总结就写这么多吧，随着项目本身变得庞大，越来越感觉一个人设计确实有些乏力了，没有能力相当的人讨论和交流。或许是时候该出去走一走了。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之打造属于自己的静态库和动态库]]></title>
    <url>%2F2016%2F05%2F27%2FiOS-make-your-own-static-and-dynamic-library%2F</url>
    <content type="text"><![CDATA[制作静态库 在iOS8之前，如果你想将一段代码分享给其他人使用而又不想让别人看到源代码，那么可以将源码以静态库的形势打包给他人使用。我们可以在这里创建一个静态库的工程: 创建完成后，工程中会自带两个以工程名命名的.h与.m文件，这两个文件不是我们需要的，可以删掉。导入我们需要打包的源码文件。 将工程的build－Configuration改成release，分别在模拟器以及真机环境下编译。编译完成后，在工程的products目录下可以看到我们生成的静态库文件{targetName.a}。 我们的静态库文件已经打包好了，但是还是有很多问题。下一步我们将把模拟器的arch和真机arch进行合并。进入到products文件夹下，找到我们刚才编译生成的文件。我们可以使用lipo命令查看我们编译生成文件所支持的arch。执行命令 lipo -info 可以查看某一个静态库文件所支持的architectures。模拟器的arch会有类似如下打印信息： ➜ Release-iphonesimulator lipo -info libRDStaticLib.a Architectures in the fat file: libRDStaticLib.a are: i386 x86_64 接下来我们将把模拟器的静态库文件与真机的静态库文件进行合并。lipo -create 可以将几个静态库文件合并为一个静态库文件，在后面加上-output + {libname}便可以生成一个合并的静态库文件。执行的代码类似如下： `lipo -create Release-iphoneos/libRDStaticLib.a Release-iphonesimulator/libRDStaticLib.a -output RDStaticLib.a` 将我们新生成的静态库文件和头文件拖入到工程中，在build setting选项中添加-ObjC选项，保证类目可以正常加载。然后便可以正常运行程序了。 拷贝头文件。如果我们的静态库仅仅包含几个头文件，每次手动的拷贝头文件也不是件麻烦的事。但是随着静态库工程变大，头文件会越来越多，每次手动的拷贝头文件就变得有些笨拙了。我们可以在target-Build Phases 中添加一个header phase 选项来控制库的头文件，或者也可以创建一个copy files phase，在Copy files中将头文件输出至指定的文件夹中。 关于bitcode。从xcode7、iOS9开始Apple开始使用bitcode技术对app进行瘦身。目前很多第三方的闭源库不支持bitcode，如果想让你的静态库支持bitcode，需要在OTHER_CFLAGS添加”-fembed-bitcode”选项。我们可以使用lipo -thin arm64 libRDStaticLib.a -output libRDStaticLib-arm64.a,将某个CPU的slice提取出来，解压该slicear -x libRDStaticLib-arm64.a,使用otool -l lib-util.o | grep bitcode查看该slice是否支持bitcode。 创建通用框架。如上面提到的，lipo其实是一个iOS的SDK工具，Xcode提供了一个创建通用框架的方法：新建一个Aggregate target。它不直接创建任何产品，它的目的是聚合另一个“target” 或 运行一些脚本，使用它通过”lipo”工具运行脚本，最终生产framework。我们需要在Build Phase中添加一个脚本，以便可以在编译时运行。关于如何编写脚本文件，可以参考这篇文章示例脚本： 12345678910111213141516171819202122232425262728293031# Sets the target folders and the final framework product.FMK_NAME=$&#123;PROJECT_NAME&#125;# Install dir will be the final output to the framework.# The following line create it in the root folder of the current project.INSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;FMK_NAME&#125;.framework# Working dir will be deleted after the framework creation.WRK_DIR=buildDEVICE_DIR=$&#123;WRK_DIR&#125;/Release-iphoneos/$&#123;FMK_NAME&#125;.frameworkSIMULATOR_DIR=$&#123;WRK_DIR&#125;/Release-iphonesimulator/$&#123;FMK_NAME&#125;.framework# -configuration $&#123;CONFIGURATION&#125;# Clean and Building both architectures.xcodebuild -configuration "Release" -target "$&#123;FMK_NAME&#125;" -sdk iphoneos clean buildxcodebuild -configuration "Release" -target "$&#123;FMK_NAME&#125;" -sdk iphonesimulator clean build# Cleaning the oldest.if [ -d "$&#123;INSTALL_DIR&#125;" ]thenrm -rf "$&#123;INSTALL_DIR&#125;"fimkdir -p "$&#123;INSTALL_DIR&#125;"cp -R "$&#123;DEVICE_DIR&#125;/" "$&#123;INSTALL_DIR&#125;/"# Uses the Lipo Tool to merge both binary files (i386 + armv6/armv7) into one Universal final product.lipo -create "$&#123;DEVICE_DIR&#125;/$&#123;FMK_NAME&#125;" "$&#123;SIMULATOR_DIR&#125;/$&#123;FMK_NAME&#125;" -output "$&#123;INSTALL_DIR&#125;/$&#123;FMK_NAME&#125;"rm -r "$&#123;WRK_DIR&#125;" 制作动态库WWDC2014上，苹果开放了动态库。动态库意味着可以在运行时加载，类似于苹果的其它framework，多个app可以共享使用同一份framework，动态加载意味着可以在运行时进行framework的替换，可以远程更新，然而App Store明令禁止使用开发者自定义的framework，由于动态库是iOS8之后推出的，老版本的系统并不支持，而且stackoverflow 上有一篇关于动态库上架appstore的论证，贴在这里will-appstore-reviewers-allow-us-to-use-dynamic-library-in-ios8，不过企业版是可行的，也就是说企业版可以实现动态更新包。关于创建动态库工程，上面已经给出了，创建一个Cocoa touch framework，创建的过程要比静态库简单很多。在Build Setting中的Linking选项中，有一个Mach-O Type选项，如果我们选择Static Library生成的同样也是静态库，只不过是该工程会生成一个framework而不单单是一个静态库.a文件。 参考iOS 静态库与动态库]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解和使用CoreData（一）]]></title>
    <url>%2F2016%2F05%2F24%2FiOS-understand-and-use-CoreData%2F</url>
    <content type="text"><![CDATA[概述CoreData是一个处理模型层的框架，也是一个数据持久化框架。CoreData帮助我们封装了繁琐的SQL语句，增加了图形化的管理，使开发者能更直观的了解对象存储的结构，这是CoreData的优点，也是它的缺点。与之前文章介绍的FMDB相比，CoreData更重，理解起来会稍微复杂些。不过如果我们学会了如何使用CoreData，使用起来也是很方便的。 CoreData中的一些重要概念持久化存储协调器NSPersistentStoreCoordinatorNSPersistentStoreCoordinator是连接持久化数据与内存数据的桥梁，持久化存储协调器可以将内存中的对象存储到本地数据库，也可以将本地数据库中的数据加载到内存。 持久化存储器NSPersistentStoreNSPersistentStore是持久化数据的存储器，一个NSPersistentStoreCoordinator可以链接多个持久化存储器。持久化存储器直接与底层数据库打交道。NSPersistentStore 类管理着和 SQLite 的实际交互，并且产生需要被执行的 SQL 代码。持久化存储协调器的角色就是简化调整 store 和 context 之间的交互过程. 管理对象上下文NSManagedObjectContextNSManagedObjectContext管理着在其内部的模型层对象NSManagedObjectModel,每个上下文中可以保存着多个模型对象，每个Context之间都是独立的。每个模型层的对象NSManagedObjectModel都知道自己所在的上下文。上下文环境的改变并不会立即同步到持久化存储，而是先保存在暂存区，只有当我们执行了save操作时才会同步到数据库。 模型存储对象NSManagedObjectModelNSManagedObjectModel是描述应用程序的数据模型，这个模型包含实体（Entity），特性（Property），读取请求（Fetch Request）等，包含了所有我们想存储的数据的定义。每一个 NSManagedObjectModel都有一个全局ID(类型为：NSManagedObjectID),我们可以通过这个全局ID在 ManagedObjectContext查询对应的ManagedObject。 属性描述类NSPropertyDescription用来描述模型对象的属性，类似于字典中的key值，CoreData中共有四种描述属性的类，都继承自NSPropertyDescription。 NSEntityDescriptionNSEntityDescription类描述了模型类的名称以及模型类所在的上下文,，当我们创建模型存储对象时，可以使用NSEntityDescription将模型插入到一个上下文中,相当于数据库中的表。 NSExpressionDescription对象的实例代表一个特殊的属性描述型。用来描述对象中的属性的类型. NSFetchedPropertyDescription用来描述查询属性,允许你通过一个fetch request来获取一个弱引用的单向关系获取数据。 NSRelationshipDescription用来描述模型存储对象的的relationships，包括relationship中的目标对象，最大数量，以及删除规则。 查询类NSFetchRequest用来查询在CoreData中的数据。一个搜索请求通常包含两个部分： NSPredicate：断言，类似于正则判断的匹配条件。 NSSortDescriptor：用来描述搜索结果的排序方式。 使用CoreData存储数据创建CoreData环境CoreData持久化链接器的创建在Xcode中有默认的生成，如果我们在创建项目的时候选择了’Use Core Data’，那么Xcode会自动帮助我们创建这些。下面给出示例代码： 123456789101112131415161718192021222324252627- (NSPersistentStoreCoordinator *)persistentStoreCoordinator &#123; // The persistent store coordinator for the application. This implementation creates and returns a coordinator, having added the store for the application to it. if (_persistentStoreCoordinator != nil) &#123; return _persistentStoreCoordinator; &#125; // Create the coordinator and store _persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]]; NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"CoreData.sqlite"]; NSError *error = nil; NSString *failureReason = @"There was an error creating or loading the application's saved data."; if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;error]) &#123; // Report any error we got. NSMutableDictionary *dict = [NSMutableDictionary dictionary]; dict[NSLocalizedDescriptionKey] = @"Failed to initialize the application's saved data"; dict[NSLocalizedFailureReasonErrorKey] = failureReason; dict[NSUnderlyingErrorKey] = error; error = [NSError errorWithDomain:@"YOUR_ERROR_DOMAIN" code:9999 userInfo:dict]; // Replace this with code to handle the error appropriately. // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. NSLog(@"Unresolved error %@, %@", error, [error userInfo]); abort(); &#125; return _persistentStoreCoordinator;&#125; 存储在document文件夹下： 1234- (NSURL *)applicationDocumentsDirectory &#123; // The directory the application uses to store the Core Data store file. This code uses a directory named "reddick-wang.CoreData" in the application's documents directory. return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];&#125; 创建上下文环境 1234567891011121314- (NSManagedObjectContext *)managedObjectContext &#123; // Returns the managed object context for the application (which is already bound to the persistent store coordinator for the application.) if (_managedObjectContext != nil) &#123; return _managedObjectContext; &#125; NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator]; if (!coordinator) &#123; return nil; &#125; _managedObjectContext = [[NSManagedObjectContext alloc] initWithConcurrencyType:NSMainQueueConcurrencyType]; [_managedObjectContext setPersistentStoreCoordinator:coordinator]; return _managedObjectContext;&#125; 创建模型： 123456789- (NSManagedObjectModel *)managedObjectModel &#123; // The managed object model for the application. It is a fatal error for the application not to be able to find and load its model. if (_managedObjectModel != nil) &#123; return _managedObjectModel; &#125; NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"CoreData" withExtension:@"momd"]; _managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL]; return _managedObjectModel;&#125; 添加实体类我们可以通过CoreData提供的对象图文件来编辑实体类，尾缀为.xcdatamodeld的文件是Core Data的对象图文件如下图所示：通过Add Entity按钮可以创建一个新的实体类，可以为实体类添加Attribute属性和Relationship关系属性，单击某个entity类，可以在右侧的inspector检查面板来进一步完善信息。如下图所示： Entity Name 和 Class Name实体的名称与类名是没有必要保持一致的，Class继承自NSManagedObject类，我们可以自定义名字。 Abstract Entity抽象类，并不会创建实例对象。 Parent Entity父实体，跟Obective－C中的继承机制保持一致。 定义属性和关系点击实体的某个属性可以在检查面板上看到属性的详细信息：每个属性都包含一个名字和类型，属性的名字不可以和NSObject的方法名或者NSManagedObject方法名相同，比如你不可以给一个属性命名为description，因为这个名字是NSObject的方法名。 Attributes Transient 临时属性是实体中你不想进行持久化存储的临时数据，Core Data并不会追踪你对临时属性变量的改变。 Optional 该属性是默认勾选的，代表了属性可以为空，不过最好别这么去处理，因为当属性的类型为number类型时，SQL存储会存储为NULL，而不像OC一样为nil，NULL并不是0值，所以当你搜索0的时候并不会等到这些结果。通常情况下，你可以为属性设置一个默认的值，这样更好些。 indexed 索引 AttributeType CoreData支持一系列的属性类型，String类型，日期类型，integer类型等。 Relationships and Fetched Properties 关系属性和读取属性CoreData支持一对一的关系属性和一对多的关系属性和读取属性。读取属性代表了一种弱的，单向的关系属性。比如部门和职员之间,读取属性可以代表目前的员工，而员工没必要反向关联部门。如果你想使用读取属性获取双向关系，比如员工可能属于多个部门，那么你可以在部门和员工分别创建一个读取属性，如果定义的是一对一的关系那么会返回一个nil或者某个对应的实体，如果是一对多的关系，会返回一个set集合。读取属性并不是自动监测更新的，你需要使用 refreshObject:mergeChanges:手动进行刷新。 自定义实体你可以子类化NSManagedObject来创建管理对象，像如下这样： 123456@interface MyManagedObject : NSManagedObject@property (nonatomic, strong) NSString *title;@property (nonatomic, strong) NSDate *date;@end 需要注意的是，属性被声明为strong 和 nonactomic，原因是CoreData并不会拷贝这些值，即便这些类实现了NSCopying协议。implementation方法如下： 1234@implementation MyManagedObject@dynamic title;@dynamic date;@end]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用FMDB做数据持久化]]></title>
    <url>%2F2016%2F05%2F22%2FiOS-use-FMDB-for-persistant-data-store%2F</url>
    <content type="text"><![CDATA[简介FMDB是iOS平台下一款将SQLite API进行了封装的第三方库，使用起来更加方便，屏蔽掉对底层的处理，使开发者能专注于业务逻辑。github地址 简单使用FMDB提供了对数据库操作的各种函数，包括增删改查等基本功能，同时也支持对数据操作的回滚操作。FMDB中使用FMDatabase或FMDatabaseQueue两个对象操作数据库，其中FMDatabaseQueue是对FMDatabase又做了一层封装以支持线程安全的访问。下文中都会以FMDatabase为例做介绍。 创建、打开、关闭数据库FMDatabase 提供了两个初始化函数： 12+ (instancetype)databaseWithPath:(NSString*)inPath;- (instancetype)initWithPath:(NSString*)inPath; 一个类方法以及一个实例方法。当inPath传入@””的时候会创建一个临时的数据库，关闭后即被销毁。传入nil时会创建一个in－memory 的数据库，关闭后也会被销毁。你可以像这样使用创建数据库： 123NSString *docsPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES)[0];NSString *dbPath = [docsPath stringByAppendingPathComponent:@"mydatabase.db"];FMDatabase *db = [FMDatabase databaseWithPath:dbPath]; 打开/关闭数据库： 123- (BOOL)open; //打开读写操作，如果数据库不存在就创建数据库。- (BOOL)close;- (BOOL)openWithFlags:(int)flags; //带选项的打开数据库 插入、更新、更改、删除操作FMDB对数据库的插入更新，更改以及删除操作仍然采用了SQLite的语法结构，所以我们如果学习过SQLite的语法，那么使用FMDB操作数据库就不会有问题。常用执行更新的操作函数的几个方法： 1234- (BOOL)executeUpdate:(NSString*)sql, ...- (BOOL)executeUpdateWithFormat:(NSString *)format, ...- (BOOL)executeUpdate:(NSString*)sql withArgumentsInArray:(NSArray *)arguments;- (BOOL)executeUpdate:(NSString*)sql withVAList: (va_list)args 示例： 创建表1234NSString *path = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)[0];path = [path stringByAppendingPathComponent:@"user.db"];FMDatabase *db = [[FMDatabase alloc]initWithPath:path];[db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_user (idKey integer PRIMARY KEY AUTOINCREMENT, userId text NOT NULL, userInfo text NOT NULL,orgID text NOT NULL)"]; 更新数据1[db executeUpdate:@"update t_user SET userInfo=?,orgID=? where userId=?",userInfo,orgID,userId]; 添加数据1[db executeUpdate:@"INSERT INTO t_user (userId,userInfo,orgID) VALUES (?,?,?)",userId,userInfo,orgID]; 查询FMDB的查询操作使用- (FMResultSet *)executeQuery:(NSString*)sql, ...函数进行查询操作，使用FMResultSet类接收返回的内容，当有查询到结果时，查询函数返回一个结果集，否则的话返回nil。在结果集中，我们需要使用loop操作来检查FMResultSet是否有多个值，FMResultSet提供了多种方法获取所得到的结果，可以根据创建表时的column的Index获取结果，也可以根据创建表时的列名称获取结果，FMResultSet也提供了获取不同返回结果的函数： 1234567- (NSString*)stringForColumn:(NSString*)columnName;- (NSString*)stringForColumnIndex:(int)columnIdx;- (double)doubleForColumnIndex:(int)columnIdx;- (double)doubleForColumn:(NSString*)columnName;- (BOOL)boolForColumnIndex:(int)columnIdx;- (BOOL)boolForColumn:(NSString*)columnName;更多的操作函数请参考SDK或官方文档。 在查询结束后需要手动关闭ResultSet。例如： 1234567NSString *userInfo = @"";FMResultSet * sets =[db executeQuery:@"select * from t_user where userId=?",userId];if ([sets next]) &#123; NSString *userId = [sets stringForColumn:@"userId"]; userInfo = [sets stringForColumn:@"userInfo"]; NSLog(@"find local user result: userId:%@,userInfo:%@",userId,userInfo); [sets close]; 使用线程安全的FMDatabaseQueue在上面提到的FMDatabase并不是线程安全的，如果我们在两个线程中同时对一个FMDatabase进行操作，那么可能会导致意想不到的结果，所以，在使用FMDatabase时一定要注意线程的问题，这点跟CoreData类似。下面将介绍线程安全的FMDatabaseQueue类，FMDatabaseQueue类封装了FMDatabase，并在内部包含了一个线程队列，所有的数据库操作均在一个同步线程上执行，这样就解决了资源的竞争。 FMDatabaseQueue的创建与FMDatabase类似： 123- (instancetype)initWithPath:(NSString*)aPath;- (instancetype)databaseQueueWithPath:(NSString*)aPath flags:(int)openFlags;- (instancetype)initWithPath:(NSString*)aPath flags:(int)openFlags; 数据库操作： 1- (void)inDatabase:(void (^)(FMDatabase *db))block; 所有的操作均在block中进行，在block中提供了一个FMDatabase，所以操作起来跟上面的FMDatabase一样。 带回滚的数据库操作： 1- (void)inTransaction:(void (^)(FMDatabase *db, BOOL *rollback))block; 示例：123456789101112131415_memberDB = [[FMDatabaseQueue alloc]initWithPath:[[self class] memberDBPath]];[_memberDB inDatabase:^(FMDatabase *db) &#123; [db executeUpdate:@"CREATE TABLE IF NOT EXISTS t_user (idKey integer PRIMARY KEY AUTOINCREMENT, userId text NOT NULL, userInfo text NOT NULL,orgID text NOT NULL)"]; &#125;];NSString *orgID = @"com.reddick";[_memberDB inDatabase:^(FMDatabase *db) &#123; FMResultSet *res = [db executeQuery:@"select * from t_user where orgID=?",orgID]; while ([res next]) &#123; @autoreleasepool &#123; NSString *userInfo = [res stringForColumnIndex:2]; NSLog(@"%@",userInfo); &#125; &#125; [res close];&#125;];]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SDWebImage源码浅析]]></title>
    <url>%2F2016%2F05%2F03%2FiOS-SDWebImage-Code-leaning%2F</url>
    <content type="text"><![CDATA[SDWebImage 是一款开源的IOS第三方异步下载图片类库，它提供一个UIImageView类别以支持加载来自网络的远程图片。具有缓存管理、异步下载、同一个URL下载次数控制和优化等特征。当然，你可以仅仅使用SDWebImage的部分功能，比如下载图片，图片处理或者缓存。SDWebImage的功能都可以单独拿出来使用。 下面是SDWebImage的类关系图: SDWebImage提供了几个常用的分类以便我们能快速上手使用。下面我们以UIimageView+WebCache为入口点，分析SDWebImage的工作过程。 123456789101112131415161718192021222324252627282930//从一个Url获取图片,最简单常用的方法- (void)sd_setImageWithURL:(NSURL *)url;//从url加载图片，在图片加载完成前会先加载一张图片展位图- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder;//同上，该方法可以配置一些可选参数 SDWebImageOptions的具体配置可以参考下文- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options;/* 从url获取图片，在完成时返回一个Block回调 在这里可以编写一些下载完毕后要做的事情 SDWebImageCompletionBlock : typedef void(^SDWebImageCompletionBlock)(UIImage *image, NSError *error, SDImageCacheType cacheType, NSURL *imageURL); 可以在block使用下载完成的图片，错误信息,缓存类型以及URL地址*/- (void)sd_setImageWithURL:(NSURL *)url completed:(SDWebImageCompletionBlock)completedBlock;//如果你看完了上面的几个方法 这两个就不介绍了吧~- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder completed:(SDWebImageCompletionBlock)completedBlock; - (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)option completed:(SDWebImageCompletionBlock)completedBlock;//下载一组url图片 同时进行动画循环显示- (void)sd_setAnimationImagesWithURLs:(NSArray *)arrayOfURLs;//取消当前图片下载- (void)sd_cancelCurrentImageLoad;//取消当前动画图片加载- (void)sd_cancelCurrentAnimatonImagesLoad; 以下是SDWebImage使用指南中给出的参考案例: 12345678910111213141516171819#import &lt;SDWebImage/UIImageView+WebCache.h&gt;...- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; static NSString *MyIdentifier = @"MyIdentifier"; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:MyIdentifier]; if (cell == nil) &#123; cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:MyIdentifier] autorelease]; &#125; // Here we use the new provided sd_setImageWithURL: method to load the web image [cell.imageView sd_setImageWithURL:[NSURL URLWithString:@"http://www.domain.com/path/to/image.jpg"] placeholderImage:[UIImage imageNamed:@"placeholder.png"]]; cell.textLabel.text = @"My Text"; return cell;&#125; 对于UIImageView+WebCache.h中的方法，其最终都会走向函数 12345- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock 只不过对于其他几个函数增加了一些默认的配置方便我们使用。 下载流程 取消当前ImageView的下载：在开始下载前，首先会取消掉Imageview之前的图片下载，SDWebImage为UIImageView动态的增加了多个属性以方便可以快速取消掉下载线程队列。 存储当前下载的url连接，检查并设置占位符图片。 如果URL存在，检查并设置activityView。否则提示空链接。 将图片下载操作交给SDWebImageManager进行下载。当下载完成或获得到缓存的图片后，SDWebImageManager通过block会掉将结果返回，此时ImageView将activityView停止动画，设置图片，移除占位符，并执行imageView完成时的回调操作。对UI的操作以及回调函数均放在主线程上以保证线程安全。 SDWebImageManager SDWebImageManager是SDWebImage的核心管理类之一，提供了下载，缓存，取消下载以及操作选项等一系列方法。 SDWebImageManager被设计成单例模式，提供了一个缓存管理器，一个图片下载器，一个线程数组等。同时在该管理类中，设计了一个私有类SDWebImageCombinedOperation该类是下载类，设计的思路与NSOperation类似。SDWebImageManager提供了一个下载图片的方法,你也可以像官方给出来的这样使用: 1234567891011SDWebImageManager *manager = [SDWebImageManager sharedManager];[manager downloadImageWithURL:imageURL options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize) &#123; // progression tracking code &#125; completed:^(UIImage *image, NSError *error, SDImageCacheType cacheType, BOOL finished, NSURL *imageURL) &#123; if (image) &#123; // do something with image &#125; &#125;]; SDWebImageManager在开始下载前，会检查是否是之前失败的下载链接，如果是失败的链接，会检查用户是否设置了SDWebImageRetryFailed选项，只有设置了SDWebImageRetryFailed选项，才会在失败后再进行一次下载。 接下来SDWebImageManager会询问SDImageCache类是否存在缓存，如果有缓存，检测是否可以使用缓存的图片，没有则向SDWebImageDownLoader添加一条下载的Operation，在下载过程中以及下载完成后需要多次检测是否取消了下载的操作。 SDImageCache图片缓存类。SDImageCache也是一个单例，主要提供跟缓存相关的操作。 缓存策略。SDImageCache提供了三种缓存策略(SDImageCacheType)，不缓存(SDImageCacheTypeNone)，内存缓存(SDImageCacheTypeMemory)，本地缓存(SDImageCacheTypeDisk)。 可配置选项。SDImageCache提供了很多方便配置的属性，比如是否解压缩图片(shouldDecompressImages)，是否关闭icloud(shouldDisableiCloud)，缓存时间(maxCacheAge)，最大缓存容量(maxCacheSize)等等。 API。SDImageCache对外提供了缓存路径，缓存的key，以及查找缓存的方法，同时提供了清理缓存，以及后台清理缓存的常用方法。 SDWebImageDownloader下载类SDWebImageDownloader也是一个可以作为单例使用的类，提供了下载的链接认证，下载头信息的配置信息以及下载线程超时时间等信息。 其他SDWebImageCompat该类定义了一些宏定义、常量。 SDWebImageDownloaderOperation类，图片下载类，在SDWebImageDownloader中使用。SDWebImageDecode图片解压缩类，SDWebImagePrefetcher图片预读类，在大图加载中使用。 除此之外还有一些常用的category比如NSData+ImageContentType分类中提供了通过读取字节流判断文件类型的方法: 1+ (NSString *)sd_contentTypeForImageData:(NSData *)data; 可以识别jpeg，png，gif和tiff文件类型.以上便是SDWebImage的源码解析。可能很多地方分析的并不透彻，也可能有的地方会有一些错误，还望大家指教。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>开源框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Objective-C 2.0读书笔记 (一)]]></title>
    <url>%2F2016%2F04%2F26%2FiOS-Effective-ObjectiveC-Book-leaning-1%2F</url>
    <content type="text"><![CDATA[引语本文主要记录在阅读Effective Objective 2.0一书中的一些感悟。 语法糖(syntactic sugar)Objective语法已繁琐著称，事实上确实如此。不过，在Objective－C 1.0以后我们有了这种非常简单的创建字面量常量的方法，就是语法糖。然后我们便可以不再去写某些繁琐的方法了： 创建NSString:1NSString *someStr = @""; 创建NSNumber:1NSNumber *num = @1; 创建字面量数组:1NSArray *array = @[]; 创建字面量字典:1NSDictionary *dict = @&#123;&lt;对象&gt;,&lt;键&gt;&#125;; 语法糖除了简化了语法代码之外，还有一些其他的好处： 12NSInteger i = 10;NSLog(@"%ld",i); 上面这段代码在64位操作系统上编译不会有任何问题，然而在32位系统上运行，会产生诸多警告，尽管仅仅是警告，但是作为一名合格的工程师，应该尽量消除掉这些警告信息。 12NSInteger i = 10;NSLog(@"%@",@i); 如果这么写就不会产生这种警告信息了。在使用字面量数组创建一组对象时，语法糖还可以帮我们潜在的问题。 123456id object1 = ...id object2 = ...id object3 = ...NSArray *arrayA = @[object1,object2,object3];NSArray *arrayB = [NSArray arrayWithObjects:object1,object2,object3,nil]; 如果object1和objcet3都是指向实体对象，而object2指向nil，那么使用语法糖的arrayA会直接抛出异常，而arrayB则会只有object1一个对象，因为在arrayWithObjects方法内部使用了可变参数方法接收参数，当碰到nil时会结束while循环，因此object3并不会被添加到数组中。 多用类型常量，少用#define预处理命令很多时候我们喜欢定义一些宏来简化我们的代码，比如定义一些颜色设置： 12#define RGB(r,g,b) [UIColor colorWithRed:(r) green:(g) blue:(b) alpha:1.0]#define deepSkyBlue [UIColor colorWithRed:0.0 green:0.7 blue:1 alpha:1.0] 使用宏可以使代码已读，也同意了更改的方式，因此我们提倡使用宏定义来处理一些事情，然而对于一些常量来说使用宏有利也会有弊，比如下面的定义 1#define kAnimationDuration 0.4 宏定义的常量不具有任何类型信息，只会在编译期间替换掉该宏常量，而且在运行期间不可更改。有个办法比预处理能更好的处理这种情况，我们可以使用static 和 const 关键字来处理这种问题。对于私有常量，我们可以这样定义： 1static NSTimeInterval kAnimationDuration = 0.4; 如果你不想让他在运行期间被更改掉，那么在static前面加上一个const关键字就可以了，对于这种常量需要在外部使用时，我们可以使用extern关键字 声明在.h中，而在内部对其进行初始化。这样编译器就会只生成一份变量空间。 理解属性@property我们很熟悉，但是深入理解它的可能并不多，属性的本质是setter和getter方法，如果使用了属性的话，编译器会在编译期合成属性对应的方法并向类中添加适当类型的实例变量。@synthesize关键字用来指定实例变量的名字: 1234@implementation Person@synthesize name = _name;@synthesize age = _age;@end 上面的代码会为属性名为name和age创建带下划线的实例变量，如果不写，编译器会默认创建这两个字段，如果我们想自定义，只需要把上面带下划线的变量名字替换成自己的变量名即可。若不想令编译器生成合成方法，可以自己实现。如果你只实现了其中一个存取方法，那么另一个存取方法编译器会自动帮助你实现。另外一种方式是使用@dynamic关键字，它会告诉编译器不要生成存取方法，不要生成实例变量，运行时这些会找到。比如在AFNetworking中AFURLSessionManager类，其responseSerializer便是使用了@dynamic属性，因为其setter方法重写,而没有生成getter方法。属性特质：nonactomic,read-only,copy,weak,assign,strong…这里便不一一介绍了，对于NSString和NSNumber常常使用copy属性，block对象同样是copy，对象属性一般使用strong和nonactomic，weak用来声明弱引用，assign用于基础类型，代理对象一般使用weak。]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Carthage 初探]]></title>
    <url>%2F2016%2F04%2F24%2FiOS-use-carthage-in-project%2F</url>
    <content type="text"><![CDATA[写在前面对于iOS开发者来说，CocoaPods是一个极其方便的Cocoa依赖管理器，你只需要简单输入几个命令就可以将喜欢的开源库加入到自己的工程中，但是正如很多时候我们也曾抱怨的，CocoaPods作为依赖管理的方式是侵入式的，它会自动帮我们处理好一切编译好的依赖和二进制文件（而这有时候并不是我们想要的）于是，一个便有了一个可DIY的Cocoa依赖管理工具诞生了：Carthage。在使用Carthage之前，曾用pod大量使用一些第三方的开源库，这便导致了项目在编译时慢的像一只蜗牛（因为pod会在编译时重新编译每一个库…）,另外一些项目由于并没有支持armv7s，导致我们的工程也没办法添加，虽然不会影响什么，但是总感觉怪怪的-.- CarthageCarthage的目标是用更简单的方式来为你的应用添加一个framework。基本的流程看起来会像这样： 创建一个包含你想要添加到工程中的框架的Cartfile列表。 运行Carthage，它会帮你拉取并编译你所列出的框架。 将编译完成的.framework二进制文件拖进你的工程中。 Carthage编译你的依赖文件，然后为你建立二进制的库文件，但是你可以完全保留你的工程结构和设置，Carthage不会自动修改你的工程文件或者是你的编译设置。这便是Carthage最大的优势：去中心化。把整个工程的编译设置以及参数设置统一交给开发者，让开发者拥有更多的抉择权。 安装Carthage提供了OS X上的PKG安装文件，你可以从这里找到release版，下载PKG文件运行。对于Carthage的安装，推荐使用Homebrew，对于不了解Homebrew的同学可以看这里Homwbrew 开始使用 创建一个Cartfile，将你想要使用的框架列在里面。 运行carthage update，这一步将获取依赖文件到一个Carthage.checkout文件夹中，然后编译每个依赖库。 在你的应用程序target的“General”设置标签中的“Embedded Binaries”区域，将框架从Carthage.build文件夹拖拽进去。 在target的”Build Phases”选项中，点击添加图标，添加新的”New Copy files Phase”。创建一个shell脚本，然后添加如下内容：`/usr/local/bin/carthage copy-frameworks` 添加完成后将你的依赖库也添加进去，他们可能看起来会像这样：`$(SRCROOT)/Carthage/Build/iOS/ReactiveCocoa.framework` 如果将debug信息也同时拷贝进了工程目录中，Xcode将会允许你在一些堆栈中进行断点调试。当你把app打包提交到appstore或者Testfight中时，Xcode同样会将这些文件拷贝进你的.xcarchive的dSYM子目录中。 升级库如果你修改了你的Cartfile或者想将每个依赖库更新至最新版本，仅需要执行carthage update即可。当然也可以仅仅更新某个库carthage update &lt;framework&gt; 自动重编译如果你想让你的依赖库在每次运行的时候都自动重新编译，仅需要在script phases中添加如下代码 /usr/local/bin/carthage build --platform &quot;$PLATFORM_NAME&quot; &quot;$SRCROOT&quot; 关于carthage的更多使用方法可以参考Carthage的官网Adding-frameworks-to-an-application 关于Carthage与CocoaPods的对比，这里有一篇比较详细的博客：Carthage 初探：四大优势与四大劣势]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-移植FFMpeg]]></title>
    <url>%2F2016%2F04%2F23%2FiOS-%E7%A7%BB%E6%A4%8DFFMpeg%2F</url>
    <content type="text"><![CDATA[准备条件 安装yasm (下载地址 1.3.0) 解压文件夹，进入到目录下执行 123./configuremakemake install 到https://github.com/libav/gas-preprocessor下载gas-preprocessor.pl 文件 执行命令:cp gas-preprocessor.pl /usr/bin/ 到/user/bin/目录下修改文件的权限:chmod 777 gas-preprocessor.pl ⚠️在OS X 10.11中由于引入了rootless权限机制，所以无法在/usr/bin目录下添加任何文件，只有Apple自身的签名软件可以，如果想运行上面的步骤需要到恢复界面关闭。重启电脑，按住 command + R，出现 OS X Utilities 界面后，在 Utilities 菜单中选择 Terminal ，运行 “csrutil disable; reboot” ，电脑自动重启。（开启 sip “csrutil enanble；reboot”） 搭建环境 下载ffmpeg脚本地址，该脚本会下载ffmpeg，并帮我们编译好各个版本的iPhone静态库文件。 在下载的文件目录下执行脚本文件: 1./build-ffmpeg.sh 将生成好的ffmpeg-iOS文件夹拖入到工程中。 工程中需要导入的其他库： 1234libiconv.tbd libbz2.tbdlibz.tbdVideoToolbox.framework 在工程的Build Settings中设置头文件的搜索路径 导入完以上ffmpeg后可以选择一个kxmovie作为播放器控制器，一个基于ffmpeg的开源播放器github地址:https://github.com/kolyvan/kxmovie 导入后编译会遇到一些小的问题，有一些枚举的名字加了AV的前缀，我们补充上就可以了，在xcode7.2下编译时会遇到”Implicit declaration of function ‘avpicture_deinterlace’ is invalid in C99”的错误，可以参考这里的解决方法issues，但是个人感觉这个方法并不可靠，此问题留作日后研究。 好了，准备工作都已经做好了，下面我们可以尝试播放一些视频了，本地的视频就不在这里讲解了，ffmpeg支持大部分的视频播放格式包括avi，rmvb,flv等等，网络视频支持rtmp，http，rtsp，hls等等。 播放流媒体视频 这里提供一个香港卫视的rtmp的直播地址：rtmp://live.hkstv.hk.lxdns.com/live/hks 在要播放的事件中加入如下代码即可： 12KxMovieViewController *movie = [KxMovieViewController movieViewControllerWithContentPath:@"rtmp://live.hkstv.hk.lxdns.com/live/hks" parameters:nil]; [self presentViewController:movie animated:YES completion:nil];]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods使用进阶]]></title>
    <url>%2F2016%2F03%2F03%2FiOS-advanced-use-CocoaPods%2F</url>
    <content type="text"><![CDATA[创建Podfile文件CocoaPods在iOS开发中已经成为了事实上的依赖库管理工具，做iOS开发如果不会使用CocoaPods,我只能呵呵哒了。什么？你会用pod install了? 你会pod update了?作为iOS强大的依赖库管理工具，Pod的用法可不止这些哦～。创建一个Podfile文件：很多人都会去touch一个文件，然后找个以前的项目copy下里面的内容。没必要，执行下面的命令就可以了：pod init，那么如何添加一个pod仓库就不详细讲了，下面我们讨论下Podfile中的其他使用： platform :ios, &#39;7.0&#39;指定适配的最低版本，有时候一些仓库只支持iOS8以上，这时候工程是跑不起来的，所以如果你的项目最低版本要求iOS7，那么要么换其他库，要么去查找仓库是否有老版本支持iOS7. use_frameworks!是否使用swift版本，如果你使用Objective-C开发，那么就要关闭掉这个选项，CocoaPods没办法指定每个项目使用OC版或者是swift版本，而是统一要么Objective-C，要么Swift! inhibit_all_warnings!忽略pods中的所有警告。如果你想让所有的target都可以使用相同的Pods 可以增加abstract_target字段,例如： 123456789101112pod 'ShowsKit'pod 'Fabric'# Has it's own copy of ShowsKit + ShowWebAuthtarget 'ShowsiOS' do pod 'ShowWebAuth'end# Has it's own copy of ShowsKit + ShowTVAuthtarget 'ShowsTV' do pod 'ShowTVAuth'end 指定开源库版本通常情况下，我们从pod添加开源库时并未指定版本号，其实这样是不安全的，如果pod的仓库频繁更新的话，一些老项目可能会因为所依赖的第三方仓库更新而导致无法跑起来。所以在使用时制定一个版本号或者一个版本是一个明智的选择。如pod &#39;Objection&#39;, &#39;0.9&#39; 当然你也可以增加波浪号来增加tag的区间，详细的内容可以参考CocoaPods的官方地址。pod &#39;Objection&#39;, &#39;～0.9&#39; 使用本地仓库如果你有些仓库是来自本地，那么指定它的路径就好啦～ pod &#39;AFNetworking&#39;, :path =&gt; &#39;~/Documents/AFNetworking&#39; 除此之外你也可以指定一个包含podspec的仓库：pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39; 当然，你也可以切换选择不同的分支或者切换tag亦或者是一个commit号：pod &#39;AFNetworking&#39;, :git =&gt; &#39;https://github.com/gowalla/AFNetworking.git&#39;, :branch =&gt; &#39;dev&#39;/:tag =&gt; &#39;0.7.0/:commit =&gt; &#39;082f8319af 以上便是Podfile的内容了。下面将介绍如何创建podspec，可能很多人不懂为什么要做podspec。试想如下情况：在一个项目中，如果你使用了CocoaPods导入了一个开源库，然而这个库并没有你想的那么好，它可能跟一些其他库有冲突(-.= 比如支付宝和ZBar)，也可能他写的一些方法你需要增加一些改动，然而最好的方法就是直接修改代码。嗯，没错，就是想直接改代码！可是如果在CocoaPods中改动的代码是不会同步到别人的机器上的，而且每次更新CocoaPods的话都要提心吊胆的是否写过的东西被改掉了,这时候podspec登场了，我们可以fork开源库的地址，然后配置下podspec，然后指定git更新的仓库地址，这样，只需要更新我们自己的仓库就好了，间接的相当于改了源码。 创建一个Podspec：你可以手动的创建一个spec文件，然后把值一个个的写进去，或者简单执行如下命令行: pod spec create来创建一个spec文件，一个spec文件的内容像下面这样： 123456789101112Pod::Spec.new do |spec| spec.name = 'Reachability' spec.version = '3.1.0' spec.license = &#123; :type =&gt; 'MIT' &#125; spec.homepage = 'https://github.com/tonymillion/Reachability' spec.authors = &#123; 'Tony Million' =&gt; 'tonymillion@gmail.com' &#125; spec.summary = 'ARC and GCD Compatible Reachability Class for iOS and OS X.' spec.source = &#123; :git =&gt; 'https://github.com/tonymillion/Reachability.git', :tag =&gt; 'v3.1.0' &#125; spec.source_files = 'Reachability.h,m' spec.framework = 'SystemConfiguration' spec.requires_arc = trueend 如何创建一个CocoaPods仓库：我们可以通过命令pod lib create &lt; YourLibrary &gt;来创建一个Pods仓库，这时候Pod会询问你repo的语言ObjC or Swift ,是否需要创建一个demo工程，使用测试框架：Specta/Kiwi/不使用,是否开启UITest，你的项目前缀（必须指定）,之后Pod会执行pod install来安装仓库，安装完成后会打开Xcode工程，这时候我们会看到一个Xcode工程，类似于下面这样： 你可以编辑工程中的podspec文件，和ReadMe文件，在Demo工程中增加使用示例，当然，如果你想增加测试，在Test文件夹下编写测试用例。 需要注意的是，在你开始编写工程前，需要先把你的Pod工程写好，即Development Pods工程，你需要将你自己的库文件添加到Development Pods/StrikethroughLabel/Pod/Classes/文件夹下，资源文件需要添加到该目录的Assets文件夹下。 然后，你需要编写你的podspec文件，该文件将指引Pod完成其所有需要做的工作。 关于podspec文件如何编写，这里有一篇比较好的文章 在你编写完podspec后需要执行pod lib lint 或者 pod spec lint (在包含podspec文件的文件夹下执行). 如果没有警告，说明你的spec文件编写的没有问题，如果你使用Objective-C编写工程的话请关闭掉工程中Podfile中的use_frameworks! 然后执行 pod install 这样就可以在Example工程中使用Pod中的文件了(每次你更新过Development Pod中的文件时，都需要执行pod install或者pod update去更新pods),如果你的工程可以正常运行，试着把它push到你的github上，然后在项目中试着使用。如果你还不满足于此，想把你的开源库分享给其他人，试着去提交到trunk上吧。指南在这里 参考文章：CocoaPods.org]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS多播代理(二)]]></title>
    <url>%2F2016%2F02%2F16%2FiOS-mutiple-delegate-with-NSProxy%2F</url>
    <content type="text"><![CDATA[使用NSProxy实现多播代理NSProxy 是Objective-C的另一个根类，是一个虚类，本身仅有几个创建方法和NSObject协议，调用任何其他方法都会触发消息转发机制，所以他是实现多播代理和模拟多继承的更好的方式。 因为NSProxy本身是一个虚类，甚至连init方法都没有，所以我们在创建时，需要自己写初始化方法。 1234567891011121314151617181920212223242526272829//RDBaseProxy.h@protocol RDBaseDelegate &lt;NSObject&gt;@required- (void)addProxyDelegate:(id )delegate;- (void)removeProxyDelegate:(id)delegate;@end@interface RDBaseProxy : NSProxy&lt;RDBaseDelegate&gt;- (instancetype)init;@end//RDBaseProxy.m@interface RDBaseProxy ()@property (nonatomic, strong) NSMutableArray *delegates;@end@implementation RDBaseProxy- (void)addProxyDelegate:(id)delegate &#123; [_delegates addObject:delegate];&#125;- (void)removeProxyDelegate:(id)delegate &#123; [_delegates removeObject:delegate];&#125;- (instancetype) init &#123; _delegates = [[NSMutableArray alloc] init]; return self;&#125; 这里的delegates便是处理消息的实体。 响应消息123456789- (BOOL)respondsToSelector:(SEL)aSelector &#123; BOOL result = FALSE; for (id obj in _delegates) &#123; if ([obj respondsToSelector:aSelector]) &#123; result = TRUE; &#125; &#125; return result;&#125; 处理响应消息的MethodSignature12345678- (NSMethodSignature *)methodSignatureForSelector:(SEL)sel &#123; for (id obj in _delegates) &#123; if ([obj methodSignatureForSelector:sel]) &#123; return [obj methodSignatureForSelector:sel]; &#125; &#125; return nil; //will cause an exception;&#125; 向数组中的所有实体转发消息12345678- (void)forwardInvocation:(NSInvocation *)invocation &#123; for (id obj in _delegates) &#123; id target = [obj methodSignatureForSelector:invocation.selector]; if (target) &#123; [invocation invokeWithTarget:obj]; &#125; &#125;&#125; 销毁12345- (void)finalize &#123; [super finalize]; [_delegates removeAllObjects]; _delegates = nil;&#125; 以上便是使用NSProxy实现多播代理的方式。 多重继承其实上面的方式也可以作为模拟多重继承来使用，不过使用数组的形式保存转发消息实体上并不优雅，因为使用者也不清楚该数组到底应该保存什么对象，能做什么，如果传入了错误的转发实体，可能会引起崩溃。所以在模拟多重继承上，更好的方式是将转发对象作为变量保存在proxy中。以下是Apple给出的例子(已转化为ARC版)： 1234567891011121314151617181920212223242526272829303132333435363738@interface TargetProxy : NSProxy &#123; id realObject1; id realObject2;&#125;@implementation TargetProxy- (id)initWithTarget1:(id)t1 target2:(id)t2 &#123; realObject1 = t1; realObject2 = t2; return self;&#125;- (void)dealloc &#123; realObject1 = nil; realObject2 = nil;&#125;- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector &#123; NSMethodSignature *sig; sig = [realObject1 methodSignatureForSelector:aSelector]; if (sig) return sig; sig = [realObject2 methodSignatureForSelector:aSelector]; return sig;&#125;// Invoke the invocation on whichever real object had a signature for it.- (void)forwardInvocation:(NSInvocation *)invocation &#123; id target = [realObject1 methodSignatureForSelector:[invocation selector]] ? realObject1 : realObject2; [invocation invokeWithTarget:target];&#125;// Override some of NSProxy's implementations to forward them...- (BOOL)respondsToSelector:(SEL)aSelector &#123; if ([realObject1 respondsToSelector:aSelector]) return YES; if ([realObject2 respondsToSelector:aSelector]) return YES; return NO;&#125;@end 这样的设计会直观一些。官方示例]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS多播代理 (一)]]></title>
    <url>%2F2016%2F02%2F16%2FiOS-mutiple-delegates-leaning%2F</url>
    <content type="text"><![CDATA[概述在iOS中实现回调的方法大概有以下几种： 协议代理 通知中心 匿名函数 KVO键值观察 在使用中，一对一的回调以上四种都可以实现，而对于一对多，范围大的回调，一般都会采用通知中心。 然而苹果的通知中心的实现在多线程编程时是有问题的，即通知的接收者所接收的通知有可能并不是在发出通知的线程上，这便导致了如果此时对象在执行dealloc的时候仍会接收到通知的问题。 在使用环信SDK的时候，我们常常会看到这样的代码： 12345678- (void)registerEaseMobNotification&#123; [self unRegisterEaseMobNotification]; // 将self 添加到SDK回调中，以便本类可以收到SDK回调 [[EaseMob sharedInstance].chatManager addDelegate:self delegateQueue:nil];&#125;- (void)unRegisterEaseMobNotification&#123; [[EaseMob sharedInstance].chatManager removeDelegate:self];&#125; 在使用时，我们会向chatmanager添加多个代理，然后每个代理都会接收到回调方法。普通的delegate只能是一对一的回调，无法做到一对多的回调。而多播代理正是对单一代理模式的一种扩展和延伸，多播代理的注册和取消注册都是成对出现的。那么如何实现一个多播代理呢？其实在XMPPFramework中已经写好了一个可用多播代理类GCDMulticastDelegate，而我们只需要拿出来直接用就可以了。由于GCDMulticastDelegate是在MRC下实现的，所以需要添加-fno-objc-arc来确保编译器可以在MRC下编译，同时由于.h文件中ARC下已经不允许在结构体内使用id类型的结构体了，所以我们将结构体改为如下形式。 1234567struct GCDMulticastDelegateListNode &#123; __unsafe_unretained id delegate; __unsafe_unretained dispatch_queue_t delegateQueue; struct GCDMulticastDelegateListNode * prev; struct GCDMulticastDelegateListNode * next; int32_t retainCount;&#125;; 在实现上，多播代理其实利用了iOS伪继承和消息转发机制，就是当类本身处理不了某些方法时去转发消息给其他类做处理。转发的关键步骤在这里： 12345678910111213141516171819202122232425262728293031323334- (void)forwardInvocation:(NSInvocation *)origInvocation&#123; NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init]; // All delegates MUST be invoked ASYNCHRONOUSLY. GCDMulticastDelegateListNode *node = delegateList; if (node != NULL) &#123; // Recall that new delegates are added to the beginning of the linked list. // The last delegate in the list is the first delegate that was added, so it will be the first that's invoked. // We're going to be moving backwards through the linked list as we invoke the delegates. // // Loop through the linked list so we can get a reference to the last delegate in the list. while (node-&gt;next != NULL) &#123; node = node-&gt;next; &#125; SEL selector = [origInvocation selector]; while (node != NULL) &#123; id delegate = node-&gt;delegate; if ([delegate respondsToSelector:selector]) &#123; NSInvocation *dupInvocation = [self duplicateInvocation:origInvocation]; dispatch_async(node-&gt;delegateQueue, ^&#123; NSAutoreleasePool *delegatePool = [[NSAutoreleasePool alloc] init]; [dupInvocation invokeWithTarget:delegate]; [delegatePool drain]; &#125;); &#125; node = node-&gt;prev; &#125; &#125; [pool release];&#125; 该方法是NSObject拥有，NSObject类内部实现只是调用了-(void)doesNotRecognizeSelector:(SEL)aSelector;方法，运行时系统在对象无法处理或转发一个消息时会调用这个方法。这个方法引发一个NSInvalidArgumentException异常并生成一个错误消息。而这里则是向每个代理转发消息。消息转发关键是重写了- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector方法，该方法是在向对象发送不能处理的消息的时候调用的。在代理能响应方法时会调用方法，如果代理并未响应方法，则会调用doNothing方法（即什么也不做)。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector&#123; GCDMulticastDelegateListNode *node; for (node = delegateList; node != NULL; node = node-&gt;next) &#123; NSMethodSignature *result = [node-&gt;delegate methodSignatureForSelector:aSelector]; if (result != nil) &#123; return result; &#125; &#125; // This causes a crash... // return [super methodSignatureForSelector:aSelector]; // This also causes a crash... // return nil; return [[self class] instanceMethodSignatureForSelector:@selector(doNothing)];&#125;下面以一个登录的多播代理为例，在名字改变时转发该消息。@protocol LoginDelegate &lt;NSObject&gt;@optional- (void)loginDidChange:(NSString *)userName;@end@interface LoginManager : NSObject&#123;&#125;@property (nonatomic, copy)NSString *userName;- (void)addDelegate:(id&lt;LoginDelegate&gt;)obj onQueue:(dispatch_queue_t)queue;- (void)removeDelegate:(id)obj;@endstatic LoginManager *instance = nil;@interface LoginManager ()@property (nonatomic, strong)GCDMulticastDelegate *delegate;@end@implementation LoginManager+ (instancetype)instance &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; instance = [[self alloc]init]; &#125;); return instance;&#125;- (instancetype)init &#123; if (self = [super init]) &#123; _delegate = [[GCDMulticastDelegate alloc]init]; &#125; return self;&#125;- (void)setUserName:(NSString *)userName &#123; _userName = [userName copy]; [(id &lt;LoginDelegate&gt;)_delegate loginDidChange:userName];&#125;- (void)addDelegate:(id&lt;LoginDelegate&gt;)obj onQueue:(dispatch_queue_t)queue &#123; queue = queue ? :dispatch_get_main_queue(); [_delegate addDelegate:obj delegateQueue:queue]; &#125;- (void)removeDelegate:(id)obj &#123; [_delegate removeDelegate:obj];&#125;@end 除了此种方法之外，还有另一种方式实现多播代理，会在另一篇文章中介绍。 参考链接伪继承与消息转发]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程开发（NSOperation篇）]]></title>
    <url>%2F2016%2F02%2F12%2FiOS-mutiple-thread-development-NSOperation%2F</url>
    <content type="text"><![CDATA[前言在多线程编程一中我们简单介绍了如何使用NSOperation，包括他的子类NSBlockOperation,本文主要介绍如何子类化NSOperation以提供自定义下载操作。 为什么使用NSOperation和NSOperationQueue在第二章中我们介绍了GCD的相关使用，NSOperationQueue是基于GCD的，是GCD的Objective－C版，但是既然我们熟悉了GCD，为什么还要使用NSOperation呢？ 以下是个人总结的几点经验： NSOperation是面向对象的，而GCD是C层次的封装。性能上GCD略胜一筹。 NSOperationQueue在处理有依赖关系的任务时更方便，原因是在其内部已经提供了一套完整的任务调度算法，而GCD则需要我们手动去处理依赖关系，NSOperation添加依赖和移除依赖关系的函数： 12- (void)addDependency:(NSOperation *)op;- (void)removeDependency:(NSOperation *)op; 对于每个加入到NSOperationQueue的Operation，都可以有自定义的优先级，NSOperationQueue会自动处理优先级最高的。而GCD则没有任务的优先级之说。并且，对于已经创建好的NSOperationQueue，我们可以动态的改变其优先级，是否为并发（设置maxConcurrentOperationCount），而GCD并不能做到。 NSOperation虽然并不支持取消操作，但是如果子类化NSOperation并重写部分方法，那么是可以做到取消异步操作的，而GCD则是一旦执行了便无法控制的，虽然我们也可以用异步处理GCD并且在其中添加__block 类型的标志变量来控制其是否被取消掉，但是处理起来相当麻烦。 基于以上几点，NSOperationQueue是有其优势的，如果你阅读过AFNetworking或者SDWebImage的源码，会发现他们也都是混合使用两者的。 自定义NSOperaion操作同步任务如果你需要子类化的Operation为一个同步任务，步骤比较简单： 子类化NSOperation 重写main方法，在main方法中实现自定义的操作。NSOperation的main方法给出了如下提示 The default implementation of this method does nothing. You should override this method to perform the desired task. In your implementation, do not invoke super. This method will automatically execute within an autorelease pool provided by NSOperation, so you do not need to create your own autorelease pool block in your implementation. 所以在使用时我们不需要调用super方法，也不需要将任务放置到autoreleasepool中。例如，我们可以创建一个下载图片的Operation: 12345678@interface DownLoadImageOperation : NSOperation- (instancetype)initWithImageUrl:(NSString *)url;@property (nonatomic,copy,readonly)NSString *imgUrl;@property (nonatomic,strong,readonly)NSData *responseData;@end .m文件的实现如下 123456789101112@implementation DownLoadImageOperation- (instancetype)initWithImageUrl:(NSString *)url &#123; if (self = [super init]) &#123; _imgUrl = [url copy]; &#125; return self;&#125;- (void)main &#123; _responseData = [NSData dataWithContentsOfURL:[NSURL URLWithString:self.imgUrl]];&#125;@end 在控制器中： 12345678910_queue = [[NSOperationQueue alloc]init];DownLoadImageOperation *operation = [[DownLoadImageOperation alloc]initWithImageUrl:@"http://star.xiziwang.net/uploads/allimg/140512/19_140512150412_1.jpg"];__weak typeof (&amp;* operation) wop = operation;[operation setCompletionBlock:^&#123; NSLog(@"finished download :%@",wop.responseData); // do something else&#125;];[_queue addOperation:operation]; 对于此类型的任务，即便我们调用了Operation的cancel方法或者NSOperationQueue的cancel方法，仍然是无法取消掉任务的，因为任务已经开始了，我们无法终止掉。 异步任务异步任务对比同步任务略显复杂，不过实现起来也并不难，对于异步的调度任务，主要增加的处理是监听以及判断其时候有被cancel掉，并对状态进行处理即可。 重写 isAsynchronous和 isConcurrent方法 1234567- (BOOL)isAsynchronous &#123; return YES;&#125;- (BOOL)isConcurrent &#123; return YES;&#125; 需要重写的属性 12@property (nonatomic,assign,readwrite,getter=isFinished)BOOL finished;@property (nonatomic,assign,readwrite,getter=isExecuting)BOOL executing; 在implementation中声明重写的变量 12@synthesize executing =_executing;@synthesize finished = _finished; 任务开始仍然在main中处理，在开始之前判断是否已经被queue取消掉了，如果取消掉了就执行finish操作。未被取消掉执行需要进行的任务。例子如下： 123456789101112- (void)main &#123; if(!self.isCancelled) &#123; [self willChangeValueForKey:@"isExecuting"]; _executing = YES; [self didChangeValueForKey:@"isExecuting"]; // 在这里开始处理你的任务 &#125;else &#123; [self finish]; &#125;&#125; 在任务完成或者因为异常终止时需要调用手动处理KVO，以便Operation可以正常结束和销毁 1234567891011- (void)finish&#123; //任务完成 [self willChangeValueForKey:@"isExecuting"]; [self willChangeValueForKey:@"isFinished"]; _executing = NO; _finished = YES; [self didChangeValueForKey:@"isExecuting"]; [self didChangeValueForKey:@"isFinished"];&#125; 你可以重写dealloc方法判断NSOperation是否执行并被销毁。 参考文章：asynchronous-methods-in-nsoperation apple ConcurrencyProgrammingGuide NSOperation autoreleasepool的问题]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 多线程开发(GCD进阶篇)]]></title>
    <url>%2F2016%2F02%2F09%2FiOS-mutiple-thread-development-GCD%2F</url>
    <content type="text"><![CDATA[上一篇文章我们简要介绍了如何进行iOS多线程进行开发，这一篇将详细介绍GCD的一些使用方法。有时候我们会碰到这样的情况,在多个并行任务完成处理的时候，我们想执行一个结束处理任务，如果使用serial queue,追加到队列的任务将是串行执行的，降低了效率,如果使用concurrent queue,又不得不考虑要在什么时候应该执行结束处理任务。在这种情况下我们需要使用dispatch_group来处理多个任务完成时的回调。 12345678910dispatch_queue_t asyncQ = dispatch_queue_create("com.reddick", DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create();for (NSInteger i= 0; i&lt; 10; ++i) &#123; dispatch_group_async(group, asyncQ, ^&#123; NSLog(@"%@",@(i)); &#125;);&#125;dispatch_group_notify(group, asyncQ, ^&#123; NSLog(@"finished");&#125;); 根据打印的结果可以发现，任务是并行执行的，并无调用顺序上的先后，但是总是在最后打印notify的结果。除此之外，dispatch_group还为我们提供了dispatch_group_wait函数仅等待全部任务结束。我们可以选择等待固定时间结束后执行任务，亦或者是永久等待所有任务都完成。通过dispatch_group_wait的返回值可以判断任务是否全部完成。 12345678910111213141516dispatch_queue_t asyncQ = dispatch_queue_create("com.reddick", DISPATCH_QUEUE_CONCURRENT); dispatch_group_t group = dispatch_group_create();for (NSInteger i= 0; i&lt; 10; ++i) &#123; dispatch_group_async(group, asyncQ, ^&#123; NSLog(@"%@",@(i)); &#125;);&#125;dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW, NSEC_PER_SEC *1);long result = dispatch_group_wait(group, time);if (result == 0) &#123; NSLog(@"任务已经全部完成");&#125;else &#123; NSLog(@"任务未全部完成");&#125; 对于同步执行，GCD还提供了一个简化的方法叫做void dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t)) 使用方法如下: 1234567dispatch_queue_t asyncQ = dispatch_queue_create("com.reddick", DISPATCH_QUEUE_CONCURRENT);NSArray *array = @[@"1",@"2",@"3"];dispatch_async(asyncQ, ^&#123; dispatch_apply([array count], asyncQ, ^(size_t i) &#123; NSLog(@"%@",array[i]); &#125;);&#125;); 除此之外还有个void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)函数，这个函数使用在并发线程队列中的，该函数会在他前面的所有任务都结束后才会调用(对于同步线程队列根本不需要考虑这些),在执行该函数后,你可以继续追加并发处理到该队列中。 信号量机制dispatch_semaphore 信号量基于计数器的一种多线程同步机制。在多个线程访问共有资源时候，会因为多线程的特性而引发数据出错的问题，而信号量则可以有效的防止共享资源的重入问题，保证一次仅有一个线程访问数据。GCD提供了三个semaphore函数，他们是：dispatch_semaphore_create 创建一个信号semaphore dispatch_semaphore_signal 发送一个信号dispatch_semaphore_wait 等待信号简单的介绍一下这三个函数，dispatch_semaphore_create会创建一个信号量，有一个整形的参数，我们可以理解为初始化的信号总量。dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制来同步任务和有限资源访问控制。使用方法如下: 1234567891011dispatch_queue_t asyncQ = dispatch_queue_create("com.reddick", DISPATCH_QUEUE_CONCURRENT);dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);NSArray *array = @[@"1",@"2",@"3"]; for (NSInteger i = 0; i &lt; [array count]; i++) &#123; dispatch_async(asyncQ, ^&#123; NSLog(@"%@",array[i]); dispatch_semaphore_signal(semaphore);&#125;);dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);&#125;NSLog(@"finished");]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS多线程开发(一)]]></title>
    <url>%2F2016%2F02%2F07%2FiOS-mutiple-thread-development-1%2F</url>
    <content type="text"><![CDATA[POSIX线程POSIX线程是UNIX创建线程的方式，偏于底层。 123456789101112131415161718192021222324252627282930313233343536- (void)createPosixThread &#123; pthread_attr_t attr; //线程属性 pthread_t posixThreadID; //线程ID int returnVal; //返回状态 returnVal = pthread_attr_init(&amp;attr); //初始化线程属性 assert(!returnVal); returnVal = pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);//创建多线程环境 assert(!returnVal); int threadError = pthread_create(&amp;posixThreadID, &amp;attr, &amp;threadStart, NULL); //创建线程，调用初始化函数 threadStart returnVal = pthread_attr_destroy(&amp;attr); assert(!returnVal); if (threadError != 0) &#123; // Report an error. &#125; pthread_join(posixThreadID, threadAction());//阻塞主线程等待线程完成&#125;/** * 线程入口函数 * * @return */void *threadStart() &#123; printf("thread start\n"); NSLog(@"%@",[NSThread currentThread]); return NULL;&#125;void* *threadAction() &#123;//回到主线程的&#125; NSThreadNSThread可以让你快速的在一个线程上执行一些比较耗时任务从而不会阻塞住线程，你可以通过threads来避免锁住主线程。 在OSX10.5之前，使用NSThread创建一个线程的唯一方法是使用detachNewThreadSelector:toTarget:withObject:方法，10.5之后你可以创建一个线程(init方法)然后执行start便可以开启一个线程。 子类化注意事项：你需要重写main方法来实现线程的入口，而且不需要调用super方法。 初始化一个线程:你可以通过- initWithTarget:selector:object:方法来创建一个线程，在创建完成后，线程并不会直接开始执行，而是需要显示的去调用[&lt;Thread&gt; start]方法来触发。当然你也可以通过直接调用+ (void)detachNewThreadSelector:(SEL)aSelector toTarget:(id)aTarget withObject:(id)anArgument方法来开启一个异步线程，target 和 selector 在线程执行结束之前并不会被释放。只有当线程执行完成时(调用exit)才会释放对象。如果这个线程是应用的第一个异步线程，应用程序将会发出NSWillBecomeMultiThreadedNotification的通知 常用方法：12345678+ (NSThread *)currentThread; //当前所在线程+ (BOOL)isMultiThreaded; 是否是多线程环境+ (void)sleepUntilDate:(NSDate *)date; 休眠至给定时间+ (void)sleepForTimeInterval:(NSTimeInterval)ti;//休眠s@property NSQualityOfService qualityOfService //线程的优先级@property (nullable, copy) NSString *name //线程的名称，住线程为main，线程id为1+ (NSThread *)mainThread //获取住线程 iOS SDK提供了一个NSObject的类目NSThreadPerformAdditions来支持在任意位置使用主线程与后台线程，支持线程阻塞操作(waitUntilDone)和runloop的模式(modes)(后面会有具体文章介绍runloop)在后台创建一个线程以执行任务：- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg在指定线程上执行任务：- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait;在主线程上执行任务：- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array; 使用一：12345678- (void)createAThread &#123; NSLog(@"%s,%@,",__func__,[NSThread currentThread]); NSThread *thead = [[NSThread alloc]initWithTarget:self selector:@selector(backgroundAction) object:nil]; [thead start];&#125;- (void)backgroundAction &#123; NSLog(@"%s,%@,",__func__,[NSThread currentThread]);&#125; 创建一个线程后在线程中执行任务，打印了当前的线程名称可以发现，在createThread中的线程和在backgroundAction中的线程不是同一个线程，打印结果类似于这样： 12-[ViewController createAThread],&lt;NSThread: 0x7c274020&gt;&#123;number = 1, name = main&#125;,-[ViewController backgroundAction],&lt;NSThread: 0x7b7773c0&gt;&#123;number = 2, name = (null)&#125;, 使用二：在已有的线程中添加任务，如果要使用已有线程，需要保证线程开启并且不会退出，并且该线程需要开启runloop。 1234567891011121314151617- (void)createTheadInbackGround &#123; NSThread *thead =[[NSThread alloc]initWithTarget:self selector:@selector(addRunLoop) object:nil]; [thead start]; [self performSelector:@selector(backgroundAction) onThread:thead withObject:nil waitUntilDone:NO modes:@[NSDefaultRunLoopMode]]; NSLog(@"-----------------");&#125;- (void)addRunLoop &#123; NSLog(@"%@",[NSThread currentThread]); [[NSRunLoop currentRunLoop] addPort:[NSMachPort port] forMode:NSRunLoopCommonModes]; [[NSRunLoop currentRunLoop] run];&#125;- (void)backgroundAction &#123; NSLog(@"%s,%@,",__func__,[NSThread currentThread]); sleep(1);&#125; 在线程开启时为runloop添加一个port可以保证runloop的持续运行，执行performSelector时，如果waitUntialDone 设置为NO，则会并发执行代码，住线程的log会先打印出来，如果waitUntilDonw 设置为NO，则当前线程会等待执行的任务完成才会继续向下执行，即阻塞住当前线程，保证线程的时序性。 NSOperationQueue线程队列管理着一系列的NSOperation,当一个operation被添加到线程队列后，operation会一直被线程持有直至其被取消或者完成任务。在未开始执行前，operation会依据他们各自的优先级以及依赖关系来确定他们的执行顺序，有依赖关系的operation会严格按照其依赖关系顺序执行，即便这些线程操作可能并不在一个线程队列中。你可以把线程队列简单的看做一个线程池，线程队列会完全控制整个线程池中任务的调度。NSOperation是一个线程任务，该类是被用来继承扩展的，在使用时需要继承NSOperation，然后重写main方法，在main方法中你可以执行需要执行的任务。启动线程任务可以有两种方式，你可以直接调用-(void)start方法在当前线程中启动线程任务，也可以直接把一个线程任务添加进一个线程队列中，而不需要调用start方法。iOS SDK提供了两个继承自NSOperation的类可以直接使用NSBlockOperation和NSInvocationOperation类 你可以像如下代码这样在线程中执行一个线程任务： 123456NSBlockOperation *block = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"%@",[NSThread currentThread]);&#125;];queue =[[NSOperationQueue alloc]init];[queue addOperation:block]; 依据打印的结果可以得知任务是在子线程中执行的。 1&lt;NSThread: 0x7c938950&gt;&#123;number = 2, name = (null)&#125; NSOperationQueue的常用方法12345678910111213141516171819202122232425262728//向线程队列中添加Operation- (void)addOperation:(NSOperation *)op;//向线程队列中添加一组线程操作 如果wait 为 YES 则阻塞线程- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait//向队列中添加一个block形式的Operation (类似于添加一个NSBlockOperation)- (void)addOperationWithBlock:(void (^)(void))block//当前线程队列允许创建的最大线程数@property NSInteger maxConcurrentOperationCount;//线程队列的名字@property (nullable, copy) NSString *name//线程队列的优先级@property NSQualityOfService qualityOfService//返回当前线程队列中未执行和正在执行的操作@property (readonly, copy) NSArray&lt;__kindof NSOperation *&gt; *operations;//取消线程队列中的所有任务 会对在每个线程中的每个任务都调用cancel方法- (void)cancelAllOperations;//阻塞线程直至所有任务完成- (void)waitUntilAllOperationsAreFinished;//返回主线程队列+ (NSOperationQueue *)mainQueue NSOperation常用方法1234567891011121314151617181920212223//开始执行Operation- (void)start;//Operation的主要任务- (void)main;//取消任务- (void)cancel;//向线程添加依赖关系- (void)addDependency:(NSOperation *)op;//移除依赖关系- (void)removeDependency:(NSOperation *)op;//线程任务的优先级@property NSOperationQueuePriority queuePriority;//操作完成时的回调@property (nullable, copy) void (^completionBlock)(void);//等待线程任务完成- (void)waitUntilFinished; GCDGCD 全称Grand Central Dispatch ，是苹果开发的一套基于C的多线程编程API，NSOperation便是在GCD的基础上封装的一套OC版的API，GCD相比于NSOperation，在进行简单的多线程编程中更有优势。在ARC环境下，dipatch对象将会像其他NSObject对象一样自动retain或者release。 概念dispatch_queue_t 线程队列 一个线程队列将会按照FIFO（先进先出）的顺序执行block，串行队列每次只执行一个回调，而并行队列则会并发执行block。 创建和管理线程队列获取主线程队列：dispatch_queue_t queue = dispatch_get_main_queue(void);主线程队列是被系统自动创建的，并且在main thread上执行任务，和global 并发队列不同的是，调用dispatch_suspend, dispatch_resume, dispatch_set_context这些方法将不会有任何效果，即住线程不能被挂起和唤起。 获取全局并发队列：dispatch_queue_t dispatch_get_global_queue( long identifier, unsigned long flags);该函数返回一个系统自定义的一个全局的并发队列，你可以只定线程队列的优先级。 identifier 是你想使用线程的优先级等级，iOS SDK 定义了四种队列的优先级: 1234- DISPATCH_QUEUE_PRIORITY_HIGH： 高优先级- DISPATCH_QUEUE_PRIORITY_DEFAULT: 默认优先级- DISPATCH_QUEUE_PRIORITY_LOW: 低优先级- DISPATCH_QUEUE_PRIORITY_BACKGROUND: 后台优先级 flags 目前暂未使用，传入0即可 创建一个自定义的线程队列：dispatch_queue_t dispatch_queue_create( const char *label dispatch_queue_attr_t attr);该函数会创建一个自定义的线程队列，你可以给线程队列命名，并设定其优先级属性等信息。 label:你可以定义个唯一的标识符来表示该线程队列，像download,sample等等，attr :线程的属性。你可以传入DISPATCH_QUEUE_SERIAL或者NULL来创建一个串行的线程队列，或者指定DISPATCH_QUEUE_CONCURRENT来创建一个异步线程。需要注意的是，尽管有ARC这一通过编译器自动管理内存的优秀技术，但是生成的queue必须由开发者手动的去管理，这是因为queue并没有像block那样具有作为Objective-C的处理技术。在结束队列的使用时,应该使用dispatch_release函数来释放(在iOS6之后可以使用ARC对gcd object进行管理了)。 获取当前线程队列dispatch_queue_t dispatch_get_current_queue( void);可能为空。 线程队列的一些其他常用方法：const char * dispatch_queue_get_label(dispatch_queue_t queue);返回线程的标识。 使用线程队列正如上面创建线程队列所讲，GCD提供了三种队列： Main: 任务将在住线程上串行执行。 Concurrent: FIFO执行任务,并发。 Serial: FIFO,串行。 iOS5之后，GCD将会自动创建四个默认的全局并发队列，你可以像如下这样调用异步执行一个代码块 123dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123; NSLog(@"%@",[NSThread currentThread]);&#125;); 同样的，你也可以在一个线程中串行执行代码 123dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;NSLog(@"%@",[NSThread currentThread]);&#125;); 可以看到打印的结果是这样的 1thread[1562:47784] &lt;NSThread: 0x7a656b20&gt;&#123;number = 1, name = main&#125; 这说明在GCD会自动处理任务需要在哪个线程中执行。需要注意的是如果在异步线程队列执行同步方法，那么执行并不是并发的，在同步的线程队列中执行异步调用，执行也不是并发的。除此之外，切勿在主线程中调用同步方法，那样会将主线程卡住。 GCD的其他用法： 在程序中只执行一次的代码，即便是并发调用，也只会执行一次，多用于单例中。 1234static dispatch_once_t onceToken;dispatch_once(&amp;onceToken, ^&#123; // done something that only create once&#125;); 延时执行某个任务： 12345double delayInSeconds = 1.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW ,delayInSeconds * NSEC_PER_SEC); dispatch_after(popTime, dispatch_get_main_queue(), ^(void)&#123; // code to be executed on the main queue after delay &#125;); 好了，关于多线程的简单实用就先介绍这么多，下一篇文章将会介绍GCD的一些高级用法。]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用脚本打包app]]></title>
    <url>%2F2016%2F01%2F31%2FiOS-archive-with-script%2F</url>
    <content type="text"><![CDATA[文章转载自 iOS自动打包并发布脚本xcodebuild 简介xcodebuild 是苹果提供的打包项目或者工程的命令，了解该命令最好的方式就是使用 man xcodebuild 查看其 man page. 尽管是英文，一定要老老实实的读一遍就好了。 DESCRIPTION xcodebuild builds one or more targets contained in an Xcode project, or builds a scheme contained in an Xcode workspace or Xcode project. Usage To build an Xcode project, run xcodebuild from the directory containing your project (i.e. the directory containing the name.xcodeproj package). If you have multiple projects in the this directory you will need to use -project to indicate which project should be built. By default, xcodebuild builds the first target listed in the project, with the default build configuration. The order of the targets is a property of the project and is the same for all users of the project. To build an Xcode workspace, you must pass both the -workspace and -scheme options to define the build. The parameters of the scheme will control which targets are built and how they are built, although you may pass other options to xcodebuild to override some parameters of the scheme. There are also several options that display info about the installed version of Xcode or about projects or workspaces in the local directory, but which do not initiate an action. These include -list, -showBuildSettings, -showsdks, -usage, and -version. 总结一下: 需要在包含 name.xcodeproj 的目录下执行 xcodebuild 命令，且如果该目录下有多个 projects，那么需要使用 -project 指定需要 build 的项目。 在不指定 build 的 target 的时候，默认情况下会 build project 下的第一个 target 当 build workspace 时，需要同时指定 -workspace 和 -scheme 参数，scheme 参数控制了哪些 targets 会被 build 以及以怎样的方式 build。 有一些诸如 -list, -showBuildSettings, -showsdks 的参数可以查看项目或者工程的信息，不会对 build action 造成任何影响，放心使用。 那么，xcodebuild 究竟如何使用呢？ 继续看文档: NAME xcodebuild – build Xcode projects and workspaces SYNOPSIS xcodebuild [-project name.xcodeproj] [[-target targetnamze] … | -alltargets] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …] xcodebuild [-project name.xcodeproj] -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …] xcodebuild -workspace name.xcworkspace -scheme schemename [[-destination destinationspecifier] …] [-destination-timeout value] [-configuration configurationname] [-sdk [sdkfullpath | sdkname]] [action …] [buildsetting=value …] [-userdefault=value …] xcodebuild -version [-sdk [sdkfullpath | sdkname]] [infoitem] xcodebuild -showsdks xcodebuild -showBuildSettings [-project name.xcodeproj | [-workspace name.xcworkspace -scheme schemename]] xcodebuild -list [-project name.xcodeproj | -workspace name.xcworkspace] xcodebuild -exportArchive -archivePath xcarchivepath -exportPath destinationpath -exportOptionsPlist path xcodebuild -exportLocalizations -project name.xcodeproj -localizationPath path [[-exportLanguage language] …] xcodebuild -importLocalizations -project name.xcodeproj -localizationPath path 挑几个我常用的形式介绍一下，较长的使用方式以序列号代替: xcodebuild -showsdks: 列出 Xcode 所有可用的 SDKs xcodebuild -showBuildSettings: 上述序号6的使用方式，查看当前工程 build setting 的配置参数，Xcode 详细的 build setting 参数参考官方文档 Xcode Build Setting Reference， 已有的配置参数可以在终端中以 buildsetting=value 的形式进行覆盖重新设置. xcodebuild -list: 上述序号7的使用方式，查看 project 中的 targets 和 configurations，或者 workspace 中 schemes。 xcodebuild [-project name.xcodeproj] [[-target targetname] ... | -alltargets] build: 上述序号1的使用方式，会 build 指定 project，其中 -target 和 -configuration 参数可以使用 xcodebuild -list 获得，-sdk 参数可由 xcodebuild -showsdks 获得，[buildsetting=value ...] 用来覆盖工程中已有的配置。可覆盖的参数参考官方文档 Xcode Build Setting Reference, action... 的可用选项如下, 打包的话当然用 build，这也是默认选项。 1* build Build the target in the build root (SYMROOT). This is the default action, and is used if no action is given. 1* analyze Build and analyze a target or scheme from the build root (SYMROOT). This requires specifying a scheme. 1* archive Archive a scheme from the build root (SYMROOT). This requires specifying a scheme. 1* test Test a scheme from the build root (SYMROOT). This requires specifying a scheme and optionally a destination. 1* installsrc Copy the source of the project to the source root (SRCROOT). 1* install Build the target and install it into the target’s installation directory in the distribution root (DSTROOT). 1* clean Remove build products and intermediate files from the build root (SYMROOT). xcodebuild -workspace name.xcworkspace -scheme schemename build: 上述序号3的使用方式，build 指定 workspace，当我们使用 CocoaPods 来管理第三方库时，会生成 xcworkspace 文件，这样就会用到这种打包方式. 使用xcodebuild和xcrun打包签名开始之前，可以新建一个测试工程 TestImg 来练习打包，在使用终端命令打包之前，请确认该工程也可以直接使用 Xcode 真机调试成功。 然后，打开终端，进入包含 TestImg.xcodeproj 的目录下，运行以下命令: xcodebuild -project TestImg.xcodeproj -target TestImg -configuration Release 如果 build 成功，会看到 ** BUILD SUCCEEDED ** 字样，且在终端会打印出这次 build 的签名信息，如下: Signing Identity: “iPhone Developer: xxx(59xxxxxx)”Provisioning Profile: “iOS Team Provisioning Profile: *” 且在该目录下会多出一个 build 目录，该目录下有 Release-iphoneos 和 TestImg.build 文件，根据我们 build -configuration 配置的参数不同，Release-iphoneos 的文件名会不同。 在 Release-iphoneos 文件夹下，有我们需要的TestImg.app文件，但是要安装到真机上，我们需要将该文件导出为ipa文件，这里使用 xcrun 命令。 xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/TestImg.app -o ~/Desktop/TestImg.ipa 这里又冒出一个 PackageApplication, 我刚开始也不知道这是个什么玩意儿，万能的google告诉我，这是 Xcode 包里自带的工具，使用 xcrun -sdk iphoneos -v PackageApplication -help 查看帮助信息. Usage:PackageApplication [-s signature] application [-o output_directory] [-verbose] [-plugin plugin] || -man || -help Options: [-s signature]: certificate name to resign application before packaging[-o output_directory]: specify output filename[-plugin plugin]: specify an optional plugin-help: brief help message-man: full documentation-v[erbose]: provide details during operation 如果执行成功，则会在你的桌面生成 TestImg.ipa 文件，这样就可以发布测试了。如果你遇到以下警告信息: Warning: –resource-rules has been deprecated in Mac OS X &gt;= 10.10! ResourceRules.plist: cannot read resources 请参考 stackoverflow 这个回答 将打包过程脚本化工作中，特别是所做项目进入测试阶段，肯定会经常打 Ad-hoc 包给测试人员进行测试，但是我们肯定不想每次进行打包的时候都要进行一些工程的设置修改，以及一系列的 next 按钮点击操作，现在就让这些操作都交给脚本化吧。 脚本化中使用如下的命令打包:xcodebuild -project name.xcodeproj -target targetname -configuration Release -sdk iphoneos build CODE_SIGN_IDENTITY=&amp;quot;$(CODE_SIGN_IDENTITY)&amp;quot; PROVISIONING_PROFILE=&amp;quot;$(PROVISIONING_PROFILE)&amp;quot; 或者 xcodebuild -workspace name.xcworkspace -scheme schemename -configuration Release -sdk iphoneos build CODE_SIGN_IDENTITY=&amp;quot;$(CODE_SIGN_IDENTITY)&amp;quot; PROVISIONING_PROFILE=&amp;quot;$(PROVISIONING_PROFILE)&amp;quot; 使用 xcrun 生成 ipa 文件:`xcrun -sdk iphoneos -v PackageApplication ./build/Release-iphoneos/$(target|scheme).app” 清除 build 过程中产生的中间文件 结合蒲公英分发平台，将 ipa 文件上传至蒲公英分发平台，同时在终端会打印上传结果以及上传应用后该应用的 URL。蒲公英分发平台能够方便地将 ipa 文件尽快分发到测试人员，该平台有开放 API，可避免人工上传。 该脚本的使用可使用 python autobuild.py -h 查看，与 xcodebuild 的使用相似: Usage: autobuild.py [options]Options:-h, --help: show this help message and exit-w name.xcworkspace, --workspace=name.xcworkspace: Build the workspace name.xcworkspace.-p name.xcodeproj, --project=name.xcodeproj: Build the project name.xcodeproj.-s schemename, --scheme=schemename: Build the scheme specified by schemename. Required if building a workspace.-t targetname, --target=targetname: Build the target specified by targetname. Required if building a project.-o output_filename, --output=output_filename: specify output filename 在脚本顶部，有几个全局变量，根据自己的项目情况修改。 123456CODE_SIGN_IDENTITY = "iPhone Distribution: companyname (9xxxxxxx9A)"PROVISIONING_PROFILE = "xxxxx-xxxx-xxx-xxxx-xxxxxxxxx"CONFIGURATION = "Release"SDK ="iphoneos"USER_KEY = "15d6xxxxxxxxxxxxxxxxxx"API_KEY = "efxxxxxxxxxxxxxxxxxxxx" 其中，CODE_SIGN_IDENTITY 为开发者证书标识，可以在 Keychain Access -&gt; Certificates -&gt; 选中证书右键弹出菜单 -&gt; Get Info -&gt; Common Name 获取，类似 iPhone Distribution: Company name Co. Ltd (xxxxxxxx9A), 包括括号内的内容。 PROVISIONING_PROFILE: 这个是 mobileprovision 文件的 identifier，获取方式： Xcode -&gt; Preferences -&gt; 选中申请开发者证书的 Apple ID -&gt; 选中开发者证书 -&gt; View Details… -&gt; 根据 Provisioning Profiles 的名字选中打包所需的 mobileprovision 文件 -&gt; 右键菜单 -&gt; Show in Finder -&gt; 找到该文件后，除了该文件后缀名的字符串就是 PROVISIONING_PROFILE 字段的内容。 当然也可以使用脚本获取, 此处参考 命令行获取mobileprovision文件的UUID: 12345678910#!/bin/bashif [ $# -ne 1 ]then echo “Usage: getmobileuuid the-mobileprovision-file-path” exit 1fimobileprovision_uuid=/usr/libexec/PlistBuddy -c &lt;span class="string"&gt;"Print UUID"&lt;/span&gt; /dev/stdin &amp;lt;&amp;lt;&amp;lt; $(/usr/bin/security cms -D -i &lt;span class="variable"&gt;$1&lt;/span&gt;)echo “UUID is:”echo $&#123;mobileprovision_uuid&#125; USER_KEY, API_KEY: 是蒲公英开放 API 的密钥。 该脚本可在 github 查看，如有任何问题，请留言回复。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-编写可变参数函数]]></title>
    <url>%2F2016%2F01%2F16%2FiOS-%E7%BC%96%E5%86%99%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在编写一些类的通用接口的时候，我们常常会碰到传递的参数个数不确定的问题，比如在UIAlertview中的init方法中的otherButtonTitles:(NSString *)otherButtonTitles, … 可变参数。iOS实现可变参数传递的方式是使用va_list。va_list是C语言提供的一种处理变长参数的方法。对于函数的定义，我们只需要在函数的最后加上…即可表示传入的参数是一个可变长的参数。当我们传入了可变参数后，我们需要定义一个可变参数列表的指针:va_list 来存储可变参数的列表。调用va_start函数.调用该函数会对va_list进行初始化操作，你需要传入两个参数，一个是va_list，一个是变参前最后一个固定参数。然后我们需要调用va_arg函数使指针移动，获取每个参数的值，va_arg函数需要传入两个参数，一个是可变参数列表，一个是可变参数的类型，我们可以使用循环读取每个参数的值。在最后我们使用va_end()函数置空整个参数列表，注意关掉参数列表是必要的，这样可以避免发生一些不必要的风险。下面是一个使用示例. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// .h文件@interface UIViewController (AlertAddition)-(void)showAlertWithTitle:(NSString *)title message:(NSString *)message clickBlock:(void (^)(NSInteger index,NSString *alertTitle))clickBlock cancelButtonTitle:(NSString *)cancleButtonTitle otherButtonTitle:(NSString *)otherButtonTitle, ...NS_REQUIRES_NIL_TERMINATION;// .m文件typedef void (^alertBlock)(NSInteger index,NSString *alertTitle);static void *alertKey = nil;@interface UIViewController (alertPrivate) &lt;uialertviewdelegate&gt;@property (nonatomic,copy)alertBlock alertBlock;@end@implementation UIViewController (AlertAddition)- (alertBlock)alertBlock &#123; return objc_getAssociatedObject(self, &amp;alertKey);&#125;-(void)setAlertBlock:(alertBlock)alertBlock &#123; objc_setAssociatedObject(self, &amp;alertKey, alertBlock, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;-(void)showAlertWithTitle:(NSString *)title message:(NSString *)message clickBlock:(void (^)(NSInteger, NSString *))clickBlock cancelButtonTitle:(NSString *)cancleButtonTitle otherButtonTitle:(NSString *)otherButtonTitle, ... &#123; self.alertBlock = clickBlock;UIAlertView *alert = [[UIAlertView alloc]initWithTitle:title message:message delegate:self cancelButtonTitle:cancleButtonTitle otherButtonTitles:otherButtonTitle,nil]; va_list list ; NSString *currentStr = nil; va_start(list, otherButtonTitle); while ((currentStr = va_arg(list, NSString*)))&#123; [alert addButtonWithTitle:currentStr]; &#125; va_end(list); [alert show];&#125;-(void)alertView:(UIAlertView *)alertView clickedButtonAtIndex:(NSInteger)buttonIndex &#123; if (self.alertBlock) &#123; self.alertBlock(buttonIndex,[alertView buttonTitleAtIndex:buttonIndex]); &#125; self.alertBlock = nil;&#125;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 版本宏的那些事]]></title>
    <url>%2F2016%2F01%2F16%2FiOS-%E7%89%88%E6%9C%AC%E5%AE%8F%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[iOS 的版本宏定义在usr/include文件夹下，主要包括Availability.h,AvailabilityInternal.h和AvailabilityMacros.h三个文件。主要作用便是在编译期对不同版本的iOS做出一些特殊的处理。在Availability.h文件中我们可以看到大量的iOS SDK宏定义： 12__IPHONE_OS_VERSION_MAX_ALLOWED // 当前编译环境允许的最大版本__IPHONE_OS_VERSION_MIN_REQUIRED // 当前编译环境支持的最小版本 这样我们就可以在程序中使用类似于#ifdef 这样的条件语句对版本进行处理了例如：在iOS8之后由于NSEraCalendarUnit等枚举变量被废弃，因此编译时会产生大量的警告： 由于系统的最低版本为iOS8 所以会产生大量的编译警告因此为了消除这些警告，我们可以定义如下宏：1234567891011121314151617181920212223242526#if __IPHONE_OS_VERSION_MIN_REQUIRED &lt; __IPHONE_8_0#define CLTYearCalendarUnit NSYearCalendarUnit#define CLTMonthCalenarUnit NSMonthCalendarUnit#define CLTWeekCalendarUnit NSWeekCalendarUnit#define CLTDayCalendarUnit NSDayCalendarUnit#define CLTHourCalendarUnit NSHourCalendarUnit#define CLTMinuteCalendarUnit NSMinuteCalendarUnit#define CLTSecondCalendarUnit NSSecondCalendarUnit#define CLTWeekdayCalendarUnit NSWeekdayCalendarUnit#define CLTWeekdayOrdinalCalendarUnit NSWeekdayOrdinalCalendarUnit#define CLTGregorianCalendar NSGregorianCalendar#else#define CLTYearCalendarUnit NSCalendarUnitYear#define CLTMonthCalenarUnit NSCalendarUnitMonth#define CLTDayCalendarUnit NSCalendarUnitDay#define CLTWeekCalendarUnit NSCalendarUnitWeekOfMonth //此处有两种选择#define CLTHourCalendarUnit NSCalendarUnitHour#define CLTMinuteCalendarUnit NSCalendarUnitMinute#define CLTSecondCalendarUnit NSCalendarUnitSecond#define CLTWeekdayCalendarUnit NSCalendarUnitWeekday#define CLTWeekdayOrdinalCalendarUnit NSCalendarUnitWeekdayOrdinal#define CLTGregorianCalendar NSCalendarIdentifierGregorian#endif 这样在使用这些枚举变量的时候，只需要使用自己自定义的宏名称，就不会产生大量的编译警告了。 对运行时的系统，如果想判断当前设备的版本，可以使用[UIDevice currentDevice].systemVersion方法来判断当前设备的版本号。我们可以定义如下宏帮助处理当前的设备版本： 1234567#define SYSTEM_VERSION_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedSame)#define SYSTEM_VERSION_GREATER_THAN(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedDescending)#define SYSTEM_VERSION_GREATER_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] == NSOrderedAscending)#define SYSTEM_VERSION_LESS_THAN_OR_EQUAL_TO(v) ([[[UIDevice currentDevice] systemVersion] compare:v options:NSNumericSearch] != NSOrderedDescending) 使用时： 123if (SYSTEM_VERSION_LESS_THAN(@"8.0")) &#123; // code here&#125;]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS国际化与本地化]]></title>
    <url>%2F2015%2F10%2F01%2FiOS-%E5%9B%BD%E9%99%85%E5%8C%96%E4%B8%8E%E6%9C%AC%E5%9C%B0%E5%8C%96%2F</url>
    <content type="text"><![CDATA[概述首先，需要清楚什么是国际化与本地化。简单说，国际化是一个应用程序国际兼容性设计的过程，比如： 以用户母语处理文本输入和输出； 处理不同的日期、时间以及数字格式； 利用适当的历法和时区处理数据；所以国际化的目的是为了使各个语言版本都有良好的体验性。而本地化的意义是将用户的界面和资源翻译成对应的语言。对于一般应用而言，更多关心的是应用程序的本地化。 iOS的本地化大体分为2种：文字的本地化和资源的国际化。下面将一一进行介绍。 文字本地化Xcode使用带有”.strings” 扩展名的文件来储存和检索app中使用的所有字符串，以支持每种语言。在工程中添加一个strings file文件如图所示：文件名需要保存为Localizable.strings，xcode会默认从该文件中读取你的本地化字符串，创建完成后便可以本地化你的程序了。在Localizable.strings文件中添加需要本地化的文本，格式类似于iOS中的字典，只不过冒号变成了引号：&quot;KEY&quot; = &quot;CONTENT&quot;;请注意在localizable.string中不要使用中文的引号，否则的话你会很难找到错误。在localizable.strings文件中添加如下内容: “content” = “content”; “space” = “space”; “recent” = “recent”; 键值对同样支持格式化字符串： “my name is %@” = “my name is %@”; 现在，当你想使用这些本地化字符串的时候，你需要像下面这样使用它们： NSLocalizedString(@”content”, nil); 做完上面的工作后，我们将开始翻译我们的这些文本，例如添加一个简体中文的本地化文件:添加完成后选择localizable.string文件，在右侧的Localization中选中chinese(Simplified)，这样你会发现原本是一个文件的localization.string文件竟然可以展开了，现在替换掉localization(Simplified)文件中的content 值便可完成文本的本地化： “content” = “内容”; “space” = “空间”; “recent” = “recent”; “my name is %@” = “我的名字叫 %@”; 以上便是文字的本地化，在模拟器上默认语言为英文，所以你将会看到英文内容。可以在设置中将语言切换为中文，这样便可以检验下本地化是不是成功了。 图片的国际化图片的国际化可以对不同的语言设置不同的图片，你可以采用如同文字本地化的方法一样，对图片进行加载： [UIImage imageNamed:NSLocalizedString(@”imagePic”, nil)]; 然后在本地化时变更图片名。只是对于少量的国际化语言而言这种方法会很方便。但是，当我们的国际化的语言变多时，便不得不要面对图片名字过多的问题。所以，对于图片资源的本地化，建议对本地化不同语言的文件夹。打开我们的工程文件，你会看到类似于zh-Hans.lproj,en.lproj这样的文件夹，我们只需要将名字相同的图片放到不同的语言包中即可，使用时依然如同没有国际化之前一样加载图片了。 本地化应用名本地化应用名可以创建一个名字为InfoPlist的strings文件(Xcode6之后默认不再创建该文件了)。在InfoPlist.strings(Simplified)中添加如下内容： “CFBundleDisplayName” = “我的应用”; 这样便完成了应用名称的本地化。 对于iOS9 Apple对Language Identifiers做了部分变更，链接在这里：Technical Note TN2418。 参考以及延伸：iOS应用国际化教程（2014版）如何测试你的国际化和本地化app]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发之控制器专场切换]]></title>
    <url>%2F2015%2F09%2F15%2FiOS-transition-between-controllers%2F</url>
    <content type="text"><![CDATA[转场动画在iOS开发中，常用的controller的切换方式主要有以下几种： Push/Pop.导航控制器的方法，可以快速的推出或关闭一个控制器。 tab.tabbrcontroller点击切换效果 PresentModal(模态视图),主要用于收集用户输入信息、临时呈现一些内容、临时改变工作模式、相应设备方向变化（用于针对不同方向分别是想两个ViewController的情况或者是显示一个新的view层级等。这几种情形都会暂时中断程序正常的执行流程。 添加子视图控制器(addChildViewController) 对于一般的转场效果而言，我们习惯使用Push/Pop操作去做导航切换，使用modal弹出模态视图去控制一些临时信息收集（图片选择/照相，登陆等)。苹果提供了几种可供选择的模态视图弹出风格：1234567891011typedef NS_ENUM(NSInteger, UIModalPresentationStyle) &#123; UIModalPresentationFullScreen = 0, UIModalPresentationPageSheet, UIModalPresentationFormSheet, UIModalPresentationCurrentContext , UIModalPresentationCustom ), UIModalPresentationOverFullScreen , UIModalPresentationOverCurrentContext , UIModalPresentationPopover, UIModalPresentationNone, &#125;;对于弹出时的风格动画可以通过设置需要弹出视图控制器的modalTransitionStyle属性： 123456typedef NS_ENUM(NSInteger, UIModalTransitionStyle) &#123; UIModalTransitionStyleCoverVertical = 0, UIModalTransitionStyleFlipHorizontal, UIModalTransitionStyleCrossDissolve, UIModalTransitionStylePartialCurl,&#125;; 对于转场切换的简单使用，这里不做过多介绍。下面主要介绍如何自定义转场切换以及动画。关于自定义转场动画的协议方法，主要定义在UIViewControllerTransitionCoordinator.h中。 UIViewControllerContextTransitioning该协议定义了转场上下文环境的一些方法。比如转场的容器视图控制器，是否在进行动画，是否取消，弹出风格等等1234567891011121314- (nullable UIView *)containerView;- (BOOL)isAnimated;- (BOOL)isInteractive;- (BOOL)transitionWasCancelled;- (UIModalPresentationStyle)presentationStyle;- (void)updateInteractiveTransition:(CGFloat)percentComplete;- (void)finishInteractiveTransition;- (void)cancelInteractiveTransition;- (void)completeTransition:(BOOL)didComplete;- (nullable __kindof UIView *)viewForKey:(NSString *)key NS_AVAILABLE_IOS(8_0);- (CGAffineTransform)targetTransform NS_AVAILABLE_IOS(8_0);- (CGRect)initialFrameForViewController:(UIViewController *)vc;- (CGRect)finalFrameForViewController:(UIViewController *)vc; UIViewControllerAnimatedTransitioning主要用于定义切换时的动画转场效果。这个动画的运行时间是固定的，而且无法进行交互。 12345//动画时间- (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;//动画转场上下文，自定义的动画部分在此处进行，在执行完动画后需要显式调用[transitionContext completeTransition:YES];- (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;- (void)animationEnded:(BOOL) transitionComplete; UIViewControllerInteractiveTransitioning负责交互动画的对象，负责交互转场动画。该对象是通过加快／减慢动画切换的过程，来响应触发事件或者随时间变化的程序输入。对象也可以提高切换的逆过程来响应变化。1234- (void)startInteractiveTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext;@optional- (CGFloat)completionSpeed;- (UIViewAnimationCurve)completionCurve; UIViewControllerTransitioningDelegate用于支持自定义切换或切换交互，定义了一组供animator对象实现的协议，来自定义切换。可以为动画的三个阶段单独提供animator对象：presenting，dismissing，interacting 123456@optional- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForPresentedController:(UIViewController *)presented presentingController:(UIViewController *)presenting sourceController:(UIViewController *)source;- (nullable id &lt;UIViewControllerAnimatedTransitioning&gt;)animationControllerForDismissedController:(UIViewController *)dismissed;- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForPresentation:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;- (nullable id &lt;UIViewControllerInteractiveTransitioning&gt;)interactionControllerForDismissal:(id &lt;UIViewControllerAnimatedTransitioning&gt;)animator;- (nullable UIPresentationController *)presentationControllerForPresentedViewController:(UIViewController *)presented presentingViewController:(UIViewController *)presenting sourceViewController:(UIViewController *)source ; UIPercentDrivenInteractiveTransitioniOS7提供了一个默认的基于百分比的动画实现UIPercentDrivenInteractiveTransition，如果不必要可以直接扩展这个类。该类需要绑定需要实现手势控制的VC，同时把手势操作添加到该VC上，然后在处理手势动作的时候，调用接口中的方法去更新当前的动画进度。 定义切换时的动画效果和动画式切换的方式一致在需切换的VC中实现UIViewControllerTransitioningDelegate，实现interactiveController方法。对于无交互(类似于导航控制器的手势交互)动画式转场，首先需要设置转场控制器的transitioningDelegate。当然由于进场动画和出场动画可能会不同，可以设置不同的动画对象。其次对于someObject需要实现UIViewControllerAnimatedTransitioning协议，下面给出苹果官方demo中的实现。123456789101112131415161718192021222324252627282930313233343536- (NSTimeInterval)transitionDuration:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; return 0.35;&#125;- (void)animateTransition:(id&lt;UIViewControllerContextTransitioning&gt;)transitionContext&#123; UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIView *containerView = transitionContext.containerView; UIView *fromView; UIView *toView; if ([transitionContext respondsToSelector:@selector(viewForKey:)]) &#123; fromView = [transitionContext viewForKey:UITransitionContextFromViewKey]; toView = [transitionContext viewForKey:UITransitionContextToViewKey]; &#125; else &#123; fromView = fromViewController.view; toView = toViewController.view; &#125; fromView.frame = [transitionContext initialFrameForViewController:fromViewController]; toView.frame = [transitionContext finalFrameForViewController:toViewController]; fromView.alpha = 1.0f; toView.alpha = 0.0f; [containerView addSubview:toView]; NSTimeInterval transitionDuration = [self transitionDuration:transitionContext]; [UIView animateWithDuration:transitionDuration animations:^&#123; fromView.alpha = 0.0f; toView.alpha = 1.0; &#125; completion:^(BOOL finished) &#123; // When we complete, tell the transition context // passing along the BOOL that indicates whether the transition // finished or not. BOOL wasCancelled = [transitionContext transitionWasCancelled]; [transitionContext completeTransition:!wasCancelled]; &#125;];&#125;以上便是无交互动画转场的简单实现对于交互式的转场动画，会略微麻烦些，主要是需要增加手势操作，并控制手势交互过程中的百分比进度控制即可。 参考链接 控制器转场动画 iOS7之定制ViewController切换效果 Apple官方demo]]></content>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[reveal app入门]]></title>
    <url>%2F2015%2F09%2F01%2FiOS-reveal-tutorial%2F</url>
    <content type="text"><![CDATA[什么是revealreveal是mac上一款强大的UI分析工具，它可以非常方便的查看你的app的效果和图层关系，当然它也可以查看别人家的app。 下载与安装reveal并不是免费的，有30天的免费试用期。不过确实是一款值得购买的app（虽然有点小贵），破解神马的请百度搜索。官方的下载地址：Revealapp 官方下载链接，百度网盘下载地址：百度网盘下载链接 v1.5.1 安装与使用reveal提供了3种将reveal集成到app中的方案，下面将逐一介绍。 静态链接库方式打开下载到本地的RevealApp 点击状态栏上的help-&gt;Show Reveal Library in Finder ，将Reveal.framework拖入到你的工程中，拖入时可以选择Copy items if needed （如果你这样做了，记得当Revealapp更新时将framework重新拖入一遍），点击确定。接下来进入到project中点击Build Phases 将Link Binary With Libraries中的revealapp.framework移除掉。点击 Build Settings 选项 搜索 Other Linker Flags 设置项 在其中添加-ObjC -lz -framework Reveal。好了，下面可以运行模拟器测试我们的app了，如果是在真机上运行，请确保真机和mac运行在同一Wi-Fi环境下。当app运行时，我们可以切换到Reveal中，点击no connection列表，如果运行成功的话，便可以看到这里多了一个我们的app选项，点击便可以查看app的层次结构了。 动态加载添加动态库的方法同静态链接库类似，只不过这回我们添加 libReveal.dylib 文件到app中，在 Link Binary With Libraries 移除掉libReveal.dylib(如果它存在的话),添加如下几个系统库libz.dylib、CFNetwork.framework、QuartzCore.framework、CoreGraphics.framework。为了在运行在调试器外部的设备上动态加载该库,我们需要将 libReveal.dylib 作为构建程序的一部分，为此，我们需要添加一段脚本到程序中。在 Build Phases 选项中添加一段脚本: set -e if [ -n &quot;${CODE_SIGN_IDENTITY}&quot; ]; then codesign -fs &quot;${CODE_SIGN_IDENTITY}&quot; &quot;${BUILT_PRODUCTS_DIR}/${FULL_PRODUCT_NAME}/libReveal.dylib&quot; fi 在AppDelegate中 1234567891011121314151617181920212223242526272829- (BOOL)application:(UIApplication * )application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [self loadReveal]; return YES;&#125;#pragma mark - Reveal - (void)loadReveal &#123; if (NSClassFromString(@"IBARevealLoader") == nil) &#123; NSString *revealLibName = @"libReveal"; NSString *revealLibExtension = @"dylib"; NSString *error; NSString *dyLibPath = [[NSBundle mainBundle] pathForResource:revealLibName ofType:revealLibExtension]; if (dyLibPath != nil) &#123; NSLog(@"Loading dynamic library: %@", dyLibPath); void *revealLib = dlopen([dyLibPath cStringUsingEncoding:NSUTF8StringEncoding], RTLD_NOW); if (revealLib == NULL) &#123; error = [NSString stringWithUTF8String:dlerror()]; &#125; &#125; else &#123; error = @"File not found."; &#125; if (error != nil) &#123; NSString *message = [NSString stringWithFormat:@"%@.%@ failed to load with error: %@", revealLibName, revealLibExtension, error]; [[[UIAlertView alloc] initWithTitle:@"Reveal library could not be loaded" message:message delegate:nil cancelButtonTitle:@"OK" otherButtonTitles:nil] show]; &#125; &#125; &#125; 通过CocoaPods引入Revealapp如果你对CocoaPods不熟悉，请参考这里：CocoaPods教程在你的Profile文件中添加如下：pod &#39;Reveal-iOS-SDK&#39;, :configurations =&gt; [&#39;Debug&#39;]保存Profile文件后在profile文件路径下执行 pod install 或者 pod update至此便完成了Revealapp的集成. 注意：从CocoaPods集成Revealapp需要保证CocoaPods的版本]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>